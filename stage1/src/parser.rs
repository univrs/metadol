// Generated by dol-codegen from Metal DOL declarations
// Do not edit manually - regenerate from source .dol files

// Source: dol/parser.dol
/// Represents a parsing error with location information.
#[derive(Debug, Clone)]
pub struct Precedence {
    pub r#type: String,
}

impl Precedence {
    pub fn new(r#type: String) -> Self {
        Self {
            r#type,
        }
    }
}


#[derive(Debug, Clone)]
pub struct ParseError {
    pub message: String,
    pub span: String,
    pub kind: String,
}

impl ParseError {
    pub fn new(message: String, span: String, kind: String) -> Self {
        Self {
            message,
            span,
            kind,
        }
    }

    pub fn to_string() -> String {
        return (self.message + (" at line " + (self.span.line.to_string() + (", column " + self.span.column.to_string()))));
    }
}


/// Parser state maintaining position in token stream and accumulated errors.
#[derive(Debug, Clone)]
pub struct ParseErrorKind {
    pub r#type: String,
}

impl ParseErrorKind {
    pub fn new(r#type: String) -> Self {
        Self {
            r#type,
        }
    }
}


/// Main entry point: parses DOL source code into an AST.
/// Returns either the parsed file or a list of errors.
#[derive(Debug, Clone)]
pub struct Parser {
    pub tokens: String,
    pub pos: String,
    pub errors: String,
}

impl Parser {
    pub fn new(tokens: String, pos: String, errors: String) -> Self {
        Self {
            tokens,
            pos,
            errors,
        }
    }

    pub fn current() -> Token {
        if (self.pos >= self.tokens.length()) {
    return Token(TokenKind::Eof, Span(0, 0, 0, 0), "");
};
        return self.tokens(self.pos);
    }

    pub fn peek(offset: u64) -> Token {
        let idx = (self.pos + offset);
        if (idx >= self.tokens.length()) {
    return Token(TokenKind::Eof, Span(0, 0, 0, 0), "");
};
        return self.tokens(idx);
    }

    pub fn advance() -> Token {
        let token = self.current();
        if (self.pos < self.tokens.length()) {
    self.pos = (self.pos + 1);
};
        return token;
    }

    pub fn check(kind: TokenKind) -> bool {
        return (self.current().kind == kind);
    }

    pub fn check_any(kinds: Vec<TokenKind>) -> bool {
        let current_kind = self.current().kind;
        for kind in kinds {
            if (current_kind == kind) {
    return true;
};
        }
        return false;
    }

    pub fn consume(kind: TokenKind, msg: String) -> Result<Token, ParseError> {
        if self.check(kind) {
    return Ok(self.advance());
};
        let err = ParseError((msg + (", found '" + (self.current().text + "'"))), self.current().span, ParseErrorKind::UnexpectedToken);
        self.errors.push(err);
        return Err(err);
    }

    pub fn match_any(kinds: Vec<TokenKind>) -> bool {
        if self.check_any(kinds) {
    self.advance();
    return true;
};
        return false;
    }

    pub fn match_kind(kind: TokenKind) -> bool {
        if self.check(kind) {
    self.advance();
    return true;
};
        return false;
    }

    pub fn synchronize() {
        self.advance();
        while !self.check(TokenKind::Eof) {
            if ((self.peek(-1).kind == TokenKind::RBrace) || (self.peek(-1).kind == TokenKind::Semicolon)) {
    return;
};
            match self.current().kind {
    Module | Use | Pub | Gene | Trait | System | Constraint | Evolves | Fun | Exegesis => {
    return;
},
    _ => {
    self.advance()
}
};
        }
    }

    pub fn report_error(message: String, span: Span, kind: ParseErrorKind) {
        let err = ParseError(message, span, kind);
        self.errors.push(err);
    }

    pub fn is_at_end() -> bool {
        return self.check(TokenKind::Eof);
    }

    pub fn parse_file() -> DolFile {
        let file = DolFile(None, vec![], vec![]);
        while self.match_kind(TokenKind::Newline) {
        }
        if self.check(TokenKind::Module) {
    match self.parse_module() {
    Ok(mod_decl) => {
    file.module_decl = Some(mod_decl);
},
    Err(_) => {
    self.synchronize()
}
}
};
        while self.check(TokenKind::Use) {
            match self.parse_use() {
    Ok(use_stmt) => {
    file.uses.push(use_stmt)
},
    Err(_) => {
    self.synchronize()
}
};
        }
        while !self.is_at_end() {
            while self.match_kind(TokenKind::Newline) {
            }
            if self.is_at_end() {
    break;
};
            match self.parse_declaration() {
    Ok(decl) => {
    file.declarations.push(decl)
},
    Err(_) => {
    self.synchronize()
}
};
        }
        return file;
    }

    pub fn parse_module() -> Result<ModuleDecl, ParseError> {
        let start = self.current().span;
        self.consume(TokenKind::Module, "Expected 'module'")?;
        let name = self.parse_qualified_name()?;
        let version = None;
        if self.match_kind(TokenKind::At) {
    let ver_token = self.consume(TokenKind::Ident, "Expected version number")?;
    version = Some(ver_token.text);
};
        self.match_kind(TokenKind::Newline);
        return Ok(ModuleDecl(name, version, Span(start.start, self.peek(-1).span.end, start.line, start.column)));
    }

    pub fn parse_use() -> Result<UseStmt, ParseError> {
        let start = self.current().span;
        self.consume(TokenKind::Use, "Expected 'use'")?;
        let path = self.parse_qualified_name()?;
        let items = vec![];
        if self.match_kind(TokenKind::Dot) {
    if self.match_kind(TokenKind::LBrace) {
    loop {
        let item = self.consume(TokenKind::Ident, "Expected identifier in use list")?;
        items.push(item.text);
        if !self.match_kind(TokenKind::Comma) {
    break;
};
    }
    self.consume(TokenKind::RBrace, "Expected '}' after use list")?
}
};
        self.match_kind(TokenKind::Newline);
        return Ok(UseStmt(path, items, Span(start.start, self.peek(-1).span.end, start.line, start.column)));
    }

    pub fn parse_qualified_name() -> Result<String, ParseError> {
        let first = self.consume(TokenKind::Ident, "Expected identifier")?;
        let name = first.text;
        while (self.check(TokenKind::Dot) && (self.peek(1).kind == TokenKind::Ident)) {
            self.advance();
            let part = self.advance();
            name = (name + ("." + part.text));
        }
        return Ok(name);
    }

    pub fn parse_declaration() -> Result<Decl, ParseError> {
        let is_pub = self.match_kind(TokenKind::Pub);
        let is_sex = self.match_kind(TokenKind::Sex);
        match self.current().kind {
    Gene => {
    return self.parse_gene(is_pub);
},
    Trait => {
    return self.parse_trait(is_pub);
},
    System => {
    return self.parse_system(is_pub);
},
    Constraint => {
    return self.parse_constraint(is_pub);
},
    Evolves => {
    return self.parse_evolves(is_pub);
},
    Fun => {
    return self.parse_function(is_pub, is_sex);
},
    Var => {
    return self.parse_var_decl(is_pub, is_sex);
},
    Exegesis => {
    return self.parse_exegesis();
},
    Extern => {
    return self.parse_extern(is_pub, is_sex);
},
    _ => {
    let err = ParseError(("Expected declaration, found '" + (self.current().text + "'")), self.current().span, ParseErrorKind::InvalidDeclaration);
    self.errors.push(err);
    return Err(err);
}
};
    }

    pub fn parse_gene(is_pub: bool) -> Result<Decl, ParseError> {
        let start = self.current().span;
        self.consume(TokenKind::Gene, "Expected 'gene'")?;
        let name = self.consume(TokenKind::Ident, "Expected gene name")?;
        let type_params = vec![];
        if self.match_kind(TokenKind::Lt) {
    type_params = self.parse_type_params()?;
    self.consume(TokenKind::Gt, "Expected '>' after type parameters")?
};
        self.consume(TokenKind::LBrace, "Expected '{' after gene name")?;
        let members = vec![];
        let exegesis = None;
        while (!self.check(TokenKind::RBrace) && !self.is_at_end()) {
            while self.match_kind(TokenKind::Newline) {
            }
            if self.check(TokenKind::RBrace) {
    break;
};
            match self.current().kind {
    Has => {
    let field = self.parse_field()?;
    members.push(GeneMember::Field(field))
},
    Type => {
    let type_alias = self.parse_type_member()?;
    members.push(GeneMember::TypeAlias(type_alias))
},
    Fun => {
    let method = self.parse_method(false)?;
    members.push(GeneMember::Method(method))
},
    Sex => {
    self.advance();
    if self.check(TokenKind::Fun) {
    let method = self.parse_method(true)?;
    members.push(GeneMember::Method(method))
} else {
    let err = ParseError("Expected 'fun' after 'sex' in gene body", self.current().span, ParseErrorKind::UnexpectedToken);
    return Err(err);
}
},
    Exegesis => {
    let ex = self.parse_exegesis_block()?;
    exegesis = Some(ex);
},
    _ => {
    let err = ParseError(("Unexpected token in gene body: '" + (self.current().text + "'")), self.current().span, ParseErrorKind::UnexpectedToken);
    self.errors.push(err);
    self.synchronize()
}
};
        }
        self.consume(TokenKind::RBrace, "Expected '}' after gene body")?;
        return Ok(Decl::Gene(GeneDecl(name.text, is_pub, type_params, members, exegesis, Span(start.start, self.peek(-1).span.end, start.line, start.column))));
    }

    pub fn parse_field() -> Result<FieldDecl, ParseError> {
        let start = self.current().span;
        self.consume(TokenKind::Has, "Expected 'has'")?;
        let name = self.consume(TokenKind::Ident, "Expected field name")?;
        self.consume(TokenKind::Colon, "Expected ':' after field name")?;
        let type_expr = self.parse_type()?;
        let default_value = None;
        if self.match_kind(TokenKind::Eq) {
    let expr = self.parse_expression()?;
    default_value = Some(expr);
};
        self.match_kind(TokenKind::Newline);
        return Ok(FieldDecl(name.text, type_expr, default_value, Span(start.start, self.peek(-1).span.end, start.line, start.column)));
    }

    pub fn parse_trait(is_pub: bool) -> Result<Decl, ParseError> {
        let start = self.current().span;
        self.consume(TokenKind::Trait, "Expected 'trait'")?;
        let name = self.consume(TokenKind::Ident, "Expected trait name")?;
        let type_params = vec![];
        if self.match_kind(TokenKind::Lt) {
    type_params = self.parse_type_params()?;
    self.consume(TokenKind::Gt, "Expected '>' after type parameters")?
};
        let supertraits = vec![];
        if self.match_kind(TokenKind::Colon) {
    supertraits = self.parse_trait_bounds()?;
};
        self.consume(TokenKind::LBrace, "Expected '{' after trait declaration")?;
        let members = vec![];
        let exegesis = None;
        while (!self.check(TokenKind::RBrace) && !self.is_at_end()) {
            while self.match_kind(TokenKind::Newline) {
            }
            if self.check(TokenKind::RBrace) {
    break;
};
            match self.current().kind {
    Is => {
    let method = self.parse_trait_method()?;
    members.push(TraitMember::Required(method))
},
    Fun => {
    let method = self.parse_method(false)?;
    members.push(TraitMember::Provided(method))
},
    Type => {
    let assoc = self.parse_associated_type()?;
    members.push(TraitMember::Associated(assoc))
},
    Exegesis => {
    let ex = self.parse_exegesis_block()?;
    exegesis = Some(ex);
},
    _ => {
    let err = ParseError("Unexpected token in trait body", self.current().span, ParseErrorKind::UnexpectedToken);
    self.errors.push(err);
    self.synchronize()
}
};
        }
        self.consume(TokenKind::RBrace, "Expected '}' after trait body")?;
        return Ok(Decl::Trait(TraitDecl(name.text, is_pub, type_params, supertraits, members, exegesis, Span(start.start, self.peek(-1).span.end, start.line, start.column))));
    }

    pub fn parse_trait_method() -> Result<MethodSig, ParseError> {
        let start = self.current().span;
        self.consume(TokenKind::Is, "Expected 'is'")?;
        let name = self.consume(TokenKind::Ident, "Expected method name")?;
        let params = self.parse_params()?;
        let return_type = None;
        if self.match_kind(TokenKind::Arrow) {
    return_type = Some(self.parse_type()?);
};
        self.match_kind(TokenKind::Newline);
        return Ok(MethodSig(name.text, params, return_type, Span(start.start, self.peek(-1).span.end, start.line, start.column)));
    }

    pub fn parse_system(is_pub: bool) -> Result<Decl, ParseError> {
        let start = self.current().span;
        self.consume(TokenKind::System, "Expected 'system'")?;
        let name = self.parse_qualified_name()?;
        let version = None;
        if self.match_kind(TokenKind::At) {
    let ver = self.consume(TokenKind::Ident, "Expected version")?;
    version = Some(ver.text);
};
        self.consume(TokenKind::LBrace, "Expected '{' after system declaration")?;
        let requirements = vec![];
        let statements = vec![];
        let exegesis = None;
        while (!self.check(TokenKind::RBrace) && !self.is_at_end()) {
            while self.match_kind(TokenKind::Newline) {
            }
            if self.check(TokenKind::RBrace) {
    break;
};
            match self.current().kind {
    Requires => {
    let req = self.parse_requires()?;
    requirements.push(req)
},
    Exegesis => {
    let ex = self.parse_exegesis_block()?;
    exegesis = Some(ex);
},
    Ident => {
    let stmt = self.parse_system_statement()?;
    statements.push(stmt)
},
    _ => {
    let err = ParseError("Unexpected token in system body", self.current().span, ParseErrorKind::UnexpectedToken);
    self.errors.push(err);
    self.synchronize()
}
};
        }
        self.consume(TokenKind::RBrace, "Expected '}' after system body")?;
        return Ok(Decl::System(SystemDecl(name, is_pub, version, requirements, statements, exegesis, Span(start.start, self.peek(-1).span.end, start.line, start.column))));
    }

    pub fn parse_requires() -> Result<RequiresStmt, ParseError> {
        let start = self.current().span;
        self.consume(TokenKind::Requires, "Expected 'requires'")?;
        let name = self.parse_qualified_name()?;
        let version_constraint = None;
        if self.check_any(vec![TokenKind::Ge, TokenKind::Le, TokenKind::Eq, TokenKind::Lt, TokenKind::Gt]) {
    let op = self.advance();
    let ver = self.consume(TokenKind::Ident, "Expected version")?;
    version_constraint = Some(VersionConstraint(op.text, ver.text));
};
        self.match_kind(TokenKind::Newline);
        return Ok(RequiresStmt(name, version_constraint, Span(start.start, self.peek(-1).span.end, start.line, start.column)));
    }

    pub fn parse_system_statement() -> Result<SystemStmt, ParseError> {
        let start = self.current().span;
        let subject = self.parse_qualified_name()?;
        self.consume(TokenKind::Has, "Expected 'has' in system statement")?;
        let property = self.parse_qualified_name()?;
        self.match_kind(TokenKind::Newline);
        return Ok(SystemStmt(subject, property, Span(start.start, self.peek(-1).span.end, start.line, start.column)));
    }

    pub fn parse_constraint(is_pub: bool) -> Result<Decl, ParseError> {
        let start = self.current().span;
        self.consume(TokenKind::Constraint, "Expected 'constraint'")?;
        let name = self.parse_qualified_name()?;
        let version = None;
        if self.match_kind(TokenKind::At) {
    let ver = self.consume(TokenKind::Ident, "Expected version")?;
    version = Some(ver.text);
};
        self.consume(TokenKind::LBrace, "Expected '{' after constraint declaration")?;
        let laws = vec![];
        let exegesis = None;
        while (!self.check(TokenKind::RBrace) && !self.is_at_end()) {
            while self.match_kind(TokenKind::Newline) {
            }
            if self.check(TokenKind::RBrace) {
    break;
};
            match self.current().kind {
    Law => {
    let law = self.parse_law()?;
    laws.push(law)
},
    Exegesis => {
    let ex = self.parse_exegesis_block()?;
    exegesis = Some(ex);
},
    _ => {
    let err = ParseError("Expected 'law' in constraint body", self.current().span, ParseErrorKind::UnexpectedToken);
    self.errors.push(err);
    self.synchronize()
}
};
        }
        self.consume(TokenKind::RBrace, "Expected '}' after constraint body")?;
        return Ok(Decl::Constraint(ConstraintDecl(name, is_pub, version, laws, exegesis, Span(start.start, self.peek(-1).span.end, start.line, start.column))));
    }

    pub fn parse_law() -> Result<LawDecl, ParseError> {
        let start = self.current().span;
        self.consume(TokenKind::Law, "Expected 'law'")?;
        let name = self.consume(TokenKind::Ident, "Expected law name")?;
        let params = vec![];
        if self.match_kind(TokenKind::LBracket) {
    params = self.parse_law_params()?;
    self.consume(TokenKind::RBracket, "Expected ']' after law parameters")?
};
        self.consume(TokenKind::Colon, "Expected ':' after law name")?;
        let body = self.parse_expression()?;
        self.match_kind(TokenKind::Newline);
        return Ok(LawDecl(name.text, params, body, Span(start.start, self.peek(-1).span.end, start.line, start.column)));
    }

    pub fn parse_evolves(is_pub: bool) -> Result<Decl, ParseError> {
        let start = self.current().span;
        self.consume(TokenKind::Evolves, "Expected 'evolves'")?;
        let from_name = self.parse_qualified_name()?;
        let from_version = None;
        if self.match_kind(TokenKind::At) {
    let ver = self.consume(TokenKind::Ident, "Expected version")?;
    from_version = Some(ver.text);
};
        self.consume(TokenKind::Arrow, "Expected '->' in evolves declaration")?;
        let to_name = self.parse_qualified_name()?;
        let to_version = None;
        if self.match_kind(TokenKind::At) {
    let ver = self.consume(TokenKind::Ident, "Expected version")?;
    to_version = Some(ver.text);
};
        self.consume(TokenKind::LBrace, "Expected '{' after evolves declaration")?;
        let migrations = vec![];
        let exegesis = None;
        while (!self.check(TokenKind::RBrace) && !self.is_at_end()) {
            while self.match_kind(TokenKind::Newline) {
            }
            if self.check(TokenKind::RBrace) {
    break;
};
            match self.current().kind {
    Ident => {
    let migration = self.parse_migration()?;
    migrations.push(migration)
},
    Exegesis => {
    let ex = self.parse_exegesis_block()?;
    exegesis = Some(ex);
},
    _ => {
    let err = ParseError("Unexpected token in evolves body", self.current().span, ParseErrorKind::UnexpectedToken);
    self.errors.push(err);
    self.synchronize()
}
};
        }
        self.consume(TokenKind::RBrace, "Expected '}' after evolves body")?;
        return Ok(Decl::Evolves(EvolvesDecl(from_name, from_version, to_name, to_version, is_pub, migrations, exegesis, Span(start.start, self.peek(-1).span.end, start.line, start.column))));
    }

    pub fn parse_migration() -> Result<MigrationStmt, ParseError> {
        let start = self.current().span;
        let field = self.consume(TokenKind::Ident, "Expected field name")?;
        let kind: MigrationKind = __uninitialized__;
        let target: String = __uninitialized__;
        let transform = None;
        if self.match_kind(TokenKind::FatArrow) {
    let new_name = self.consume(TokenKind::Ident, "Expected new field name")?;
    kind = MigrationKind::Rename;
    target = new_name.text;
} else { if self.match_kind(TokenKind::Arrow) {
    kind = MigrationKind::Transform;
    target = field.text;
    let expr = self.parse_expression()?;
    transform = Some(expr);
} else {
    let err = ParseError("Expected '->' or '=>' in migration", self.current().span, ParseErrorKind::UnexpectedToken);
    return Err(err);
} };
        self.match_kind(TokenKind::Newline);
        return Ok(MigrationStmt(field.text, kind, target, transform, Span(start.start, self.peek(-1).span.end, start.line, start.column)));
    }

    pub fn parse_function(is_pub: bool, is_sex: bool) -> Result<Decl, ParseError> {
        let start = self.current().span;
        self.consume(TokenKind::Fun, "Expected 'fun'")?;
        let name = self.consume(TokenKind::Ident, "Expected function name")?;
        let type_params = vec![];
        if self.match_kind(TokenKind::Lt) {
    type_params = self.parse_type_params()?;
    self.consume(TokenKind::Gt, "Expected '>' after type parameters")?
};
        let params = self.parse_params()?;
        let return_type = None;
        if self.match_kind(TokenKind::Arrow) {
    return_type = Some(self.parse_type()?);
};
        let where_clause = vec![];
        if self.check(TokenKind::Where) {
    where_clause = self.parse_where_clause()?;
};
        let body = self.parse_block()?;
        return Ok(Decl::Function(FunctionDecl(name.text, is_pub, is_sex, type_params, params, return_type, where_clause, body, Span(start.start, self.peek(-1).span.end, start.line, start.column))));
    }

    pub fn parse_method(is_sex: bool) -> Result<MethodDecl, ParseError> {
        let start = self.current().span;
        self.consume(TokenKind::Fun, "Expected 'fun'")?;
        let name = self.consume(TokenKind::Ident, "Expected method name")?;
        let type_params = vec![];
        if self.match_kind(TokenKind::Lt) {
    type_params = self.parse_type_params()?;
    self.consume(TokenKind::Gt, "Expected '>' after type parameters")?
};
        let params = self.parse_params()?;
        let return_type = None;
        if self.match_kind(TokenKind::Arrow) {
    return_type = Some(self.parse_type()?);
};
        let body = self.parse_block()?;
        return Ok(MethodDecl(name.text, is_sex, type_params, params, return_type, body, Span(start.start, self.peek(-1).span.end, start.line, start.column)));
    }

    pub fn parse_var_decl(is_pub: bool, is_sex: bool) -> Result<Decl, ParseError> {
        let start = self.current().span;
        self.consume(TokenKind::Var, "Expected 'var'")?;
        let name = self.consume(TokenKind::Ident, "Expected variable name")?;
        let type_expr = None;
        if self.match_kind(TokenKind::Colon) {
    type_expr = Some(self.parse_type()?);
};
        let init_value = None;
        if self.match_kind(TokenKind::Eq) {
    init_value = Some(self.parse_expression()?);
};
        self.match_kind(TokenKind::Newline);
        return Ok(Decl::Variable(VarDecl(name.text, is_pub, is_sex, type_expr, init_value, Span(start.start, self.peek(-1).span.end, start.line, start.column))));
    }

    pub fn parse_extern(is_pub: bool, is_sex: bool) -> Result<Decl, ParseError> {
        let start = self.current().span;
        self.consume(TokenKind::Extern, "Expected 'extern'")?;
        let abi = "C";
        if self.check(TokenKind::StringLiteral) {
    let abi_token = self.advance();
    abi = abi_token.text.trim_quotes();
};
        self.consume(TokenKind::Fun, "Expected 'fun' after extern")?;
        let name = self.consume(TokenKind::Ident, "Expected function name")?;
        let params = self.parse_params()?;
        let return_type = None;
        if self.match_kind(TokenKind::Arrow) {
    return_type = Some(self.parse_type()?);
};
        self.match_kind(TokenKind::Newline);
        return Ok(Decl::Extern(ExternDecl(name.text, is_pub, is_sex, abi, params, return_type, Span(start.start, self.peek(-1).span.end, start.line, start.column))));
    }

    pub fn parse_exegesis() -> Result<Decl, ParseError> {
        let ex = self.parse_exegesis_block()?;
        return Ok(Decl::Exegesis(ex));
    }

    pub fn parse_exegesis_block() -> Result<ExegesisBlock, ParseError> {
        let start = self.current().span;
        self.consume(TokenKind::Exegesis, "Expected 'exegesis'")?;
        self.consume(TokenKind::LBrace, "Expected '{' after exegesis")?;
        let content = "";
        let depth = 1;
        while ((depth > 0) && !self.is_at_end()) {
            let token = self.advance();
            match token.kind {
    LBrace => {
    depth = (depth + 1);
},
    RBrace => {
    depth = (depth - 1);
},
    _ => {
}
};
            if (depth > 0) {
    content = (content + token.text);
    if !self.check(TokenKind::RBrace) {
    content = (content + " ");
}
};
        }
        return Ok(ExegesisBlock(content.trim(), Span(start.start, self.peek(-1).span.end, start.line, start.column)));
    }

    pub fn parse_type() -> Result<TypeExpr, ParseError> {
        if self.check(TokenKind::Enum) {
    return self.parse_enum_type();
};
        let base = self.parse_base_type()?;
        if self.match_kind(TokenKind::Question) {
    return Ok(TypeExpr::Optional(Box::new(base)));
};
        return Ok(base);
    }

    pub fn parse_base_type() -> Result<TypeExpr, ParseError> {
        let name_token = self.consume(TokenKind::Ident, "Expected type name")?;
        let name = name_token.text;
        let type_args = vec![];
        if self.match_kind(TokenKind::Lt) {
    loop {
        let arg = self.parse_type()?;
        type_args.push(arg);
        if !self.match_kind(TokenKind::Comma) {
    break;
};
    }
    self.consume(TokenKind::Gt, "Expected '>' after type arguments")?
};
        if (type_args.length() > 0) {
    return Ok(TypeExpr::Generic(name, type_args));
};
        return Ok(TypeExpr::Named(name));
    }

    pub fn parse_enum_type() -> Result<TypeExpr, ParseError> {
        let start = self.current().span;
        self.consume(TokenKind::Enum, "Expected 'enum'")?;
        self.consume(TokenKind::LBrace, "Expected '{' after enum")?;
        let variants = vec![];
        while (!self.check(TokenKind::RBrace) && !self.is_at_end()) {
            while self.match_kind(TokenKind::Newline) {
            }
            while self.match_kind(TokenKind::Comma) {
            }
            if self.check(TokenKind::RBrace) {
    break;
};
            let variant = self.consume(TokenKind::Ident, "Expected variant name")?;
            let value = None;
            if self.match_kind(TokenKind::Eq) {
    let val_expr = self.parse_expression()?;
    value = Some(val_expr);
};
            variants.push(EnumVariant(variant.text, value));
            if !self.match_kind(TokenKind::Comma) {
    self.match_kind(TokenKind::Newline)
};
        }
        self.consume(TokenKind::RBrace, "Expected '}' after enum variants")?;
        return Ok(TypeExpr::Enum(variants));
    }

    pub fn parse_type_params() -> Result<Vec<TypeParam>, ParseError> {
        let params = vec![];
        loop {
            let name = self.consume(TokenKind::Ident, "Expected type parameter name")?;
            let bounds = vec![];
            if self.match_kind(TokenKind::Colon) {
    bounds = self.parse_trait_bounds()?;
};
            let default_type = None;
            if self.match_kind(TokenKind::Eq) {
    default_type = Some(self.parse_type()?);
};
            params.push(TypeParam(name.text, bounds, default_type));
            if !self.match_kind(TokenKind::Comma) {
    break;
};
        }
        return Ok(params);
    }

    pub fn parse_trait_bounds() -> Result<Vec<String>, ParseError> {
        let bounds = vec![];
        loop {
            let bound = self.parse_qualified_name()?;
            bounds.push(bound);
            if !self.match_kind(TokenKind::Plus) {
    break;
};
        }
        return Ok(bounds);
    }

    pub fn parse_type_member() -> Result<TypeAlias, ParseError> {
        let start = self.current().span;
        self.consume(TokenKind::Type, "Expected 'type'")?;
        let name = self.consume(TokenKind::Ident, "Expected type alias name")?;
        self.consume(TokenKind::Eq, "Expected '=' after type name")?;
        let type_expr = self.parse_type()?;
        self.match_kind(TokenKind::Newline);
        return Ok(TypeAlias(name.text, type_expr, Span(start.start, self.peek(-1).span.end, start.line, start.column)));
    }

    pub fn parse_associated_type() -> Result<AssociatedType, ParseError> {
        let start = self.current().span;
        self.consume(TokenKind::Type, "Expected 'type'")?;
        let name = self.consume(TokenKind::Ident, "Expected associated type name")?;
        let bounds = vec![];
        if self.match_kind(TokenKind::Colon) {
    bounds = self.parse_trait_bounds()?;
};
        self.match_kind(TokenKind::Newline);
        return Ok(AssociatedType(name.text, bounds, Span(start.start, self.peek(-1).span.end, start.line, start.column)));
    }

    pub fn parse_params() -> Result<Vec<Param>, ParseError> {
        self.consume(TokenKind::LParen, "Expected '(' for parameters")?;
        let params = vec![];
        if !self.check(TokenKind::RParen) {
    loop {
        let is_variadic = false;
        if (self.check(TokenKind::Dot) && ((self.peek(1).kind == TokenKind::Dot) && (self.peek(2).kind == TokenKind::Dot))) {
    self.advance();
    self.advance();
    self.advance();
    is_variadic = true;
};
        let name = self.consume(TokenKind::Ident, "Expected parameter name")?;
        let type_expr = None;
        if self.match_kind(TokenKind::Colon) {
    type_expr = Some(self.parse_type()?);
};
        let default_value = None;
        if self.match_kind(TokenKind::Eq) {
    default_value = Some(self.parse_expression()?);
};
        params.push(Param(name.text, type_expr, default_value, is_variadic));
        if !self.match_kind(TokenKind::Comma) {
    break;
};
    }
};
        self.consume(TokenKind::RParen, "Expected ')' after parameters")?;
        return Ok(params);
    }

    pub fn parse_law_params() -> Result<Vec<Param>, ParseError> {
        let params = vec![];
        loop {
            let name = self.consume(TokenKind::Ident, "Expected parameter name")?;
            let type_expr = None;
            if self.match_kind(TokenKind::Colon) {
    type_expr = Some(self.parse_type()?);
};
            params.push(Param(name.text, type_expr, None, false));
            if !self.match_kind(TokenKind::Comma) {
    break;
};
        }
        return Ok(params);
    }

    pub fn parse_where_clause() -> Result<Vec<WhereClause>, ParseError> {
        self.consume(TokenKind::Where, "Expected 'where'")?;
        let clauses = vec![];
        loop {
            let type_name = self.consume(TokenKind::Ident, "Expected type name")?;
            self.consume(TokenKind::Colon, "Expected ':' after type name")?;
            let bounds = self.parse_trait_bounds()?;
            clauses.push(WhereClause(type_name.text, bounds));
            if !self.match_kind(TokenKind::Comma) {
    break;
};
        }
        return Ok(clauses);
    }

    pub fn parse_block() -> Result<Block, ParseError> {
        let start = self.current().span;
        self.consume(TokenKind::LBrace, "Expected '{'")?;
        let stmts = vec![];
        while (!self.check(TokenKind::RBrace) && !self.is_at_end()) {
            while self.match_kind(TokenKind::Newline) {
            }
            if self.check(TokenKind::RBrace) {
    break;
};
            let stmt = self.parse_statement()?;
            stmts.push(stmt);
            self.match_any(vec![TokenKind::Semicolon, TokenKind::Newline]);
        }
        self.consume(TokenKind::RBrace, "Expected '}'")?;
        return Ok(Block(stmts, Span(start.start, self.peek(-1).span.end, start.line, start.column)));
    }

    pub fn parse_statement() -> Result<Stmt, ParseError> {
        match self.current().kind {
    Let => {
    return self.parse_let();
},
    Var => {
    return self.parse_local_var();
},
    Return => {
    return self.parse_return();
},
    If => {
    return self.parse_if();
},
    Match => {
    return self.parse_match();
},
    For => {
    return self.parse_for();
},
    While => {
    return self.parse_while();
},
    Loop => {
    return self.parse_loop();
},
    Break => {
    return self.parse_break();
},
    Continue => {
    return self.parse_continue();
},
    Sex => {
    return self.parse_sex_block();
},
    _ => {
    return self.parse_expr_or_assign();
}
};
    }

    pub fn parse_let() -> Result<Stmt, ParseError> {
        let start = self.current().span;
        self.consume(TokenKind::Let, "Expected 'let'")?;
        let name = self.consume(TokenKind::Ident, "Expected variable name")?;
        let type_expr = None;
        if self.match_kind(TokenKind::Colon) {
    type_expr = Some(self.parse_type()?);
};
        self.consume(TokenKind::Eq, "Expected '=' after let binding")?;
        let value = self.parse_expression()?;
        return Ok(Stmt::Let(LetStmt(name.text, type_expr, value, Span(start.start, self.peek(-1).span.end, start.line, start.column))));
    }

    pub fn parse_local_var() -> Result<Stmt, ParseError> {
        let start = self.current().span;
        self.consume(TokenKind::Var, "Expected 'var'")?;
        let name = self.consume(TokenKind::Ident, "Expected variable name")?;
        let type_expr = None;
        if self.match_kind(TokenKind::Colon) {
    type_expr = Some(self.parse_type()?);
};
        let value = None;
        if self.match_kind(TokenKind::Eq) {
    value = Some(self.parse_expression()?);
};
        return Ok(Stmt::Var(VarStmt(name.text, type_expr, value, Span(start.start, self.peek(-1).span.end, start.line, start.column))));
    }

    pub fn parse_return() -> Result<Stmt, ParseError> {
        let start = self.current().span;
        self.consume(TokenKind::Return, "Expected 'return'")?;
        let value = None;
        if !self.check_any(vec![TokenKind::RBrace, TokenKind::Semicolon, TokenKind::Newline]) {
    value = Some(self.parse_expression()?);
};
        return Ok(Stmt::Return(ReturnStmt(value, Span(start.start, self.peek(-1).span.end, start.line, start.column))));
    }

    pub fn parse_if() -> Result<Stmt, ParseError> {
        let start = self.current().span;
        self.consume(TokenKind::If, "Expected 'if'")?;
        let condition = self.parse_expression()?;
        let then_block = self.parse_block()?;
        let else_block = None;
        if self.match_kind(TokenKind::Else) {
    if self.check(TokenKind::If) {
    let elif = self.parse_if()?;
    else_block = Some(Block(vec![elif], elif.span()));
} else {
    else_block = Some(self.parse_block()?);
}
};
        return Ok(Stmt::If(IfStmt(condition, then_block, else_block, Span(start.start, self.peek(-1).span.end, start.line, start.column))));
    }

    pub fn parse_match() -> Result<Stmt, ParseError> {
        let start = self.current().span;
        self.consume(TokenKind::Match, "Expected 'match'")?;
        let scrutinee = self.parse_expression()?;
        self.consume(TokenKind::LBrace, "Expected '{' after match expression")?;
        let arms = vec![];
        while (!self.check(TokenKind::RBrace) && !self.is_at_end()) {
            while self.match_kind(TokenKind::Newline) {
            }
            if self.check(TokenKind::RBrace) {
    break;
};
            let arm = self.parse_match_arm()?;
            arms.push(arm);
        }
        self.consume(TokenKind::RBrace, "Expected '}' after match arms")?;
        return Ok(Stmt::Match(MatchStmt(scrutinee, arms, Span(start.start, self.peek(-1).span.end, start.line, start.column))));
    }

    pub fn parse_match_arm() -> Result<MatchArm, ParseError> {
        let start = self.current().span;
        let pattern = self.parse_pattern()?;
        let body: ArmBody = __uninitialized__;
        if self.match_kind(TokenKind::FatArrow) {
    let expr = self.parse_expression()?;
    body = ArmBody::Expr(expr);
} else {
    let block = self.parse_block()?;
    body = ArmBody::Block(block);
};
        self.match_kind(TokenKind::Newline);
        return Ok(MatchArm(pattern, body, Span(start.start, self.peek(-1).span.end, start.line, start.column)));
    }

    pub fn parse_pattern() -> Result<Pattern, ParseError> {
        let start = self.current().span;
        if self.match_kind(TokenKind::Underscore) {
    return Ok(Pattern::Wildcard(start));
};
        if self.check(TokenKind::IntLiteral) {
    let lit = self.advance();
    return Ok(Pattern::Literal(LiteralPattern::Int(lit.text.parse_int())));
};
        if self.check(TokenKind::StringLiteral) {
    let lit = self.advance();
    return Ok(Pattern::Literal(LiteralPattern::String(lit.text.trim_quotes())));
};
        if self.check(TokenKind::BoolTrue) {
    self.advance();
    return Ok(Pattern::Literal(LiteralPattern::Bool(true)));
};
        if self.check(TokenKind::BoolFalse) {
    self.advance();
    return Ok(Pattern::Literal(LiteralPattern::Bool(false)));
};
        let patterns = vec![self.parse_simple_pattern()?];
        while self.match_kind(TokenKind::Pipe) {
            patterns.push(self.parse_simple_pattern()?);
        }
        if (patterns.length() > 1) {
    return Ok(Pattern::Or(patterns));
};
        return Ok(patterns(0));
    }

    pub fn parse_simple_pattern() -> Result<Pattern, ParseError> {
        let start = self.current().span;
        if self.match_kind(TokenKind::Underscore) {
    return Ok(Pattern::Wildcard(start));
};
        let name = self.consume(TokenKind::Ident, "Expected pattern")?;
        if self.match_kind(TokenKind::LBrace) {
    let fields = vec![];
    while (!self.check(TokenKind::RBrace) && !self.is_at_end()) {
        let field_name = self.consume(TokenKind::Ident, "Expected field name")?;
        let field_pattern = None;
        if self.match_kind(TokenKind::Colon) {
    field_pattern = Some(self.parse_pattern()?);
};
        fields.push(FieldPattern(field_name.text, field_pattern));
        if !self.match_kind(TokenKind::Comma) {
    break;
};
    }
    self.consume(TokenKind::RBrace, "Expected '}' after pattern fields")?;
    return Ok(Pattern::Constructor(name.text, fields));
};
        if self.match_kind(TokenKind::LParen) {
    let args = vec![];
    while (!self.check(TokenKind::RParen) && !self.is_at_end()) {
        let arg = self.parse_pattern()?;
        args.push(arg);
        if !self.match_kind(TokenKind::Comma) {
    break;
};
    }
    self.consume(TokenKind::RParen, "Expected ')' after pattern args")?;
    return Ok(Pattern::Tuple(name.text, args));
};
        return Ok(Pattern::Binding(name.text));
    }

    pub fn parse_for() -> Result<Stmt, ParseError> {
        let start = self.current().span;
        self.consume(TokenKind::For, "Expected 'for'")?;
        let binding = self.consume(TokenKind::Ident, "Expected loop variable")?;
        self.consume(TokenKind::In, "Expected 'in' after loop variable")?;
        let iterable = self.parse_expression()?;
        let body = self.parse_block()?;
        return Ok(Stmt::For(ForStmt(binding.text, iterable, body, Span(start.start, self.peek(-1).span.end, start.line, start.column))));
    }

    pub fn parse_while() -> Result<Stmt, ParseError> {
        let start = self.current().span;
        self.consume(TokenKind::While, "Expected 'while'")?;
        let condition = self.parse_expression()?;
        let body = self.parse_block()?;
        return Ok(Stmt::While(WhileStmt(condition, body, Span(start.start, self.peek(-1).span.end, start.line, start.column))));
    }

    pub fn parse_loop() -> Result<Stmt, ParseError> {
        let start = self.current().span;
        self.consume(TokenKind::Loop, "Expected 'loop'")?;
        let body = self.parse_block()?;
        return Ok(Stmt::Loop(LoopStmt(body, Span(start.start, self.peek(-1).span.end, start.line, start.column))));
    }

    pub fn parse_break() -> Result<Stmt, ParseError> {
        let start = self.current().span;
        self.consume(TokenKind::Break, "Expected 'break'")?;
        return Ok(Stmt::Break(BreakStmt(start)));
    }

    pub fn parse_continue() -> Result<Stmt, ParseError> {
        let start = self.current().span;
        self.consume(TokenKind::Continue, "Expected 'continue'")?;
        return Ok(Stmt::Continue(ContinueStmt(start)));
    }

    pub fn parse_sex_block() -> Result<Stmt, ParseError> {
        let start = self.current().span;
        self.consume(TokenKind::Sex, "Expected 'sex'")?;
        let body = self.parse_block()?;
        return Ok(Stmt::Sex(SexBlock(body, Span(start.start, self.peek(-1).span.end, start.line, start.column))));
    }

    pub fn parse_expr_or_assign() -> Result<Stmt, ParseError> {
        let start = self.current().span;
        let expr = self.parse_expression()?;
        if self.check_any(vec![TokenKind::Eq, TokenKind::Bind]) {
    let op = self.advance();
    let value = self.parse_expression()?;
    return Ok(Stmt::Assign(AssignStmt(expr, op.text, value, Span(start.start, self.peek(-1).span.end, start.line, start.column))));
};
        if (self.check(TokenKind::Plus) && (self.peek(1).kind == TokenKind::Eq)) {
    self.advance();
    self.advance();
    let value = self.parse_expression()?;
    return Ok(Stmt::Assign(AssignStmt(expr, "+=", value, Span(start.start, self.peek(-1).span.end, start.line, start.column))));
};
        if (self.check(TokenKind::Minus) && (self.peek(1).kind == TokenKind::Eq)) {
    self.advance();
    self.advance();
    let value = self.parse_expression()?;
    return Ok(Stmt::Assign(AssignStmt(expr, "-=", value, Span(start.start, self.peek(-1).span.end, start.line, start.column))));
};
        return Ok(Stmt::Expr(ExprStmt(expr, Span(start.start, self.peek(-1).span.end, start.line, start.column))));
    }

    pub fn parse_expression() -> Result<Expr, ParseError> {
        return self.parse_precedence(0);
    }

    pub fn parse_precedence(min_prec: i32) -> Result<Expr, ParseError> {
        let left = self.parse_prefix()?;
        while !self.is_at_end() {
            let prec = self.get_precedence();
            if (prec < min_prec) {
    break;
};
            let next_prec = prec;
            if self.is_right_associative() {
    next_prec = prec;
} else {
    next_prec = (prec + 1);
};
            let op = self.parse_infix_op();
            let right = self.parse_precedence(next_prec)?;
            left = Expr::Binary(BinaryExpr(Box::new(left), op, Box::new(right), Span(left.span().start, right.span().end, left.span().line, left.span().column)));
        }
        return Ok(left);
    }

    pub fn parse_prefix() -> Result<Expr, ParseError> {
        let start = self.current().span;
        if self.check_any(vec![TokenKind::Minus, TokenKind::Not, TokenKind::Bang]) {
    let op_token = self.advance();
    let op = match op_token.kind {
    Minus => {
    UnaryOp::Neg
},
    Not => {
    UnaryOp::Not
},
    Bang => {
    UnaryOp::Bang
},
    _ => {
    UnaryOp::Neg
}
};
    let operand = self.parse_prefix()?;
    return Ok(Expr::Unary(UnaryExpr(op, Box::new(operand), Span(start.start, operand.span().end, start.line, start.column))));
};
        if self.match_kind(TokenKind::Quote) {
    let expr = self.parse_prefix()?;
    return Ok(Expr::Quote(QuoteExpr(Box::new(expr), Span(start.start, expr.span().end, start.line, start.column))));
};
        if self.match_kind(TokenKind::LParen) {
    let expr = self.parse_expression()?;
    self.consume(TokenKind::RParen, "Expected ')' after expression")?;
    return Ok(expr);
};
        if self.match_kind(TokenKind::IdiomOpen) {
    let expr = self.parse_expression()?;
    self.consume(TokenKind::IdiomClose, "Expected '|]' after idiom expression")?;
    return Ok(Expr::Idiom(IdiomExpr(Box::new(expr), Span(start.start, self.peek(-1).span.end, start.line, start.column))));
};
        if self.match_kind(TokenKind::LBracket) {
    let elements = vec![];
    if !self.check(TokenKind::RBracket) {
    loop {
        let elem = self.parse_expression()?;
        elements.push(elem);
        if !self.match_kind(TokenKind::Comma) {
    break;
};
    }
};
    self.consume(TokenKind::RBracket, "Expected ']' after array elements")?;
    return Ok(Expr::Array(ArrayExpr(elements, Span(start.start, self.peek(-1).span.end, start.line, start.column))));
};
        if self.check(TokenKind::IntLiteral) {
    let token = self.advance();
    return Ok(Expr::Literal(Literal::Int(token.text.parse_int())));
};
        if self.check(TokenKind::FloatLiteral) {
    let token = self.advance();
    return Ok(Expr::Literal(Literal::Float(token.text.parse_float())));
};
        if self.check(TokenKind::StringLiteral) {
    let token = self.advance();
    return Ok(Expr::Literal(Literal::String(token.text.trim_quotes())));
};
        if self.match_kind(TokenKind::BoolTrue) {
    return Ok(Expr::Literal(Literal::Bool(true)));
};
        if self.match_kind(TokenKind::BoolFalse) {
    return Ok(Expr::Literal(Literal::Bool(false)));
};
        if self.check(TokenKind::Pipe) {
    return self.parse_lambda();
};
        if self.check(TokenKind::If) {
    return self.parse_if_expr();
};
        if self.check(TokenKind::Match) {
    return self.parse_match_expr();
};
        if self.check(TokenKind::Ident) {
    return self.parse_identifier_expr();
};
        if self.check(TokenKind::This) {
    let token = self.advance();
    return Ok(Expr::This(ThisExpr(token.span)));
};
        let err = ParseError(("Expected expression, found '" + (self.current().text + "'")), self.current().span, ParseErrorKind::InvalidExpression);
        self.errors.push(err);
        return Err(err);
    }

    pub fn get_precedence() -> i32 {
        match self.current().kind {
    Or => {
    return 10;
},
    And => {
    return 20;
},
    Eq | Ne => {
    return 30;
},
    Lt | Le | Gt | Ge => {
    return 40;
},
    Pipe | BackPipe => {
    return 50;
},
    Compose => {
    return 60;
},
    Bind => {
    return 70;
},
    Apply => {
    return 80;
},
    Plus | Minus => {
    return 90;
},
    Star | Slash | Percent => {
    return 100;
},
    StarStar => {
    return 110;
},
    _ => {
    return 0;
}
};
    }

    pub fn is_right_associative() -> bool {
        match self.current().kind {
    StarStar => {
    return true;
},
    _ => {
    return false;
}
};
    }

    pub fn parse_infix_op() -> BinOp {
        let token = self.advance();
        match token.kind {
    Plus => {
    return BinOp::Add;
},
    Minus => {
    return BinOp::Sub;
},
    Star => {
    return BinOp::Mul;
},
    Slash => {
    return BinOp::Div;
},
    Percent => {
    return BinOp::Mod;
},
    StarStar => {
    return BinOp::Pow;
},
    Eq => {
    return BinOp::Eq;
},
    Ne => {
    return BinOp::Ne;
},
    Lt => {
    return BinOp::Lt;
},
    Le => {
    return BinOp::Le;
},
    Gt => {
    return BinOp::Gt;
},
    Ge => {
    return BinOp::Ge;
},
    And => {
    return BinOp::And;
},
    Or => {
    return BinOp::Or;
},
    Pipe => {
    return BinOp::Pipe;
},
    BackPipe => {
    return BinOp::BackPipe;
},
    Compose => {
    return BinOp::Compose;
},
    Bind => {
    return BinOp::Bind;
},
    Apply => {
    return BinOp::Apply;
},
    _ => {
    return BinOp::Add;
}
};
    }

    pub fn parse_identifier_expr() -> Result<Expr, ParseError> {
        let start = self.current().span;
        let name = self.advance();
        let expr: Expr = Expr::Ident(IdentExpr(name.text, name.span));
        loop {
            if self.match_kind(TokenKind::LParen) {
    let args = self.parse_call_args()?;
    expr = Expr::Call(CallExpr(Box::new(expr), args, Span(start.start, self.peek(-1).span.end, start.line, start.column)));
} else { if self.match_kind(TokenKind::Dot) {
    let field = self.consume(TokenKind::Ident, "Expected field name")?;
    if self.match_kind(TokenKind::LParen) {
    let args = self.parse_call_args()?;
    expr = Expr::MethodCall(MethodCallExpr(Box::new(expr), field.text, args, Span(start.start, self.peek(-1).span.end, start.line, start.column)));
} else {
    expr = Expr::Field(FieldExpr(Box::new(expr), field.text, Span(start.start, field.span.end, start.line, start.column)));
}
} else { if self.match_kind(TokenKind::LBracket) {
    let index = self.parse_expression()?;
    self.consume(TokenKind::RBracket, "Expected ']' after index")?;
    expr = Expr::Index(IndexExpr(Box::new(expr), Box::new(index), Span(start.start, self.peek(-1).span.end, start.line, start.column)));
} else { if self.match_kind(TokenKind::LBrace) {
    let fields = self.parse_struct_fields()?;
    expr = Expr::Struct(StructExpr(name.text, fields, Span(start.start, self.peek(-1).span.end, start.line, start.column)));
} else {
    break;
} } } };
        }
        return Ok(expr);
    }

    pub fn parse_call_args() -> Result<Vec<Arg>, ParseError> {
        let args = vec![];
        if !self.check(TokenKind::RParen) {
    loop {
        let name = None;
        if (self.check(TokenKind::Ident) && (self.peek(1).kind == TokenKind::Colon)) {
    let name_token = self.advance();
    self.advance();
    name = Some(name_token.text);
};
        let value = self.parse_expression()?;
        args.push(Arg(name, value));
        if !self.match_kind(TokenKind::Comma) {
    break;
};
    }
};
        self.consume(TokenKind::RParen, "Expected ')' after arguments")?;
        return Ok(args);
    }

    pub fn parse_struct_fields() -> Result<Vec<StructField>, ParseError> {
        let fields = vec![];
        while (!self.check(TokenKind::RBrace) && !self.is_at_end()) {
            while self.match_kind(TokenKind::Newline) {
            }
            if self.check(TokenKind::RBrace) {
    break;
};
            let name = self.consume(TokenKind::Ident, "Expected field name")?;
            self.consume(TokenKind::Colon, "Expected ':' after field name")?;
            let value = self.parse_expression()?;
            fields.push(StructField(name.text, value));
            if !self.match_kind(TokenKind::Comma) {
    self.match_kind(TokenKind::Newline)
};
        }
        self.consume(TokenKind::RBrace, "Expected '}' after struct fields")?;
        return Ok(fields);
    }

    pub fn parse_lambda() -> Result<Expr, ParseError> {
        let start = self.current().span;
        self.consume(TokenKind::Pipe, "Expected '|' to start lambda")?;
        let params = vec![];
        if !self.check(TokenKind::Pipe) {
    loop {
        let param_name = self.consume(TokenKind::Ident, "Expected parameter name")?;
        let param_type = None;
        if self.match_kind(TokenKind::Colon) {
    param_type = Some(self.parse_type()?);
};
        params.push(LambdaParam(param_name.text, param_type));
        if !self.match_kind(TokenKind::Comma) {
    break;
};
    }
};
        self.consume(TokenKind::Pipe, "Expected '|' after lambda parameters")?;
        let body: LambdaBody = __uninitialized__;
        if self.check(TokenKind::LBrace) {
    let block = self.parse_block()?;
    body = LambdaBody::Block(block);
} else {
    let expr = self.parse_expression()?;
    body = LambdaBody::Expr(Box::new(expr));
};
        return Ok(Expr::Lambda(LambdaExpr(params, body, Span(start.start, self.peek(-1).span.end, start.line, start.column))));
    }

    pub fn parse_if_expr() -> Result<Expr, ParseError> {
        let start = self.current().span;
        self.consume(TokenKind::If, "Expected 'if'")?;
        let condition = self.parse_expression()?;
        self.consume(TokenKind::LBrace, "Expected '{' after if condition")?;
        let then_expr = self.parse_expression()?;
        self.consume(TokenKind::RBrace, "Expected '}' after then expression")?;
        self.consume(TokenKind::Else, "Expected 'else' in if expression")?;
        self.consume(TokenKind::LBrace, "Expected '{' after else")?;
        let else_expr = self.parse_expression()?;
        self.consume(TokenKind::RBrace, "Expected '}' after else expression")?;
        return Ok(Expr::If(IfExpr(Box::new(condition), Box::new(then_expr), Box::new(else_expr), Span(start.start, self.peek(-1).span.end, start.line, start.column))));
    }

    pub fn parse_match_expr() -> Result<Expr, ParseError> {
        let start = self.current().span;
        self.consume(TokenKind::Match, "Expected 'match'")?;
        let scrutinee = self.parse_expression()?;
        self.consume(TokenKind::LBrace, "Expected '{' after match expression")?;
        let arms = vec![];
        while (!self.check(TokenKind::RBrace) && !self.is_at_end()) {
            while self.match_kind(TokenKind::Newline) {
            }
            if self.check(TokenKind::RBrace) {
    break;
};
            let arm = self.parse_match_arm()?;
            arms.push(arm);
        }
        self.consume(TokenKind::RBrace, "Expected '}' after match arms")?;
        return Ok(Expr::Match(MatchExpr(Box::new(scrutinee), arms, Span(start.start, self.peek(-1).span.end, start.line, start.column))));
    }
}


pub fn parse(source: String) -> Result<DolFile, Vec<ParseError>> {
    let tokens = lex(source);
    let parser = Parser(tokens, 0, vec![]);
    let file = parser.parse_file();
    if (parser.errors.length() > 0) {
    return Err(parser.errors);
};
    return Ok(file);
}


pub fn parse_with_diagnostics(source: String) -> Tuple<Option<DolFile>, Vec<String>> {
    match parse(source) {
    Ok(file) => {
    return (Some(file), vec![]);
},
    Err(errors) => {
    let messages = vec![];
    for err in errors {
        messages.push(err.to_string());
    }
    return (None, messages);
}
};
}


pub fn parse_expression_string(source: String) -> Result<Expr, ParseError> {
    let tokens = lex(source);
    let parser = Parser(tokens, 0, vec![]);
    return parser.parse_expression();
}


