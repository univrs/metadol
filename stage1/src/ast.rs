// Generated by dol-codegen from Metal DOL declarations
// Do not edit manually - regenerate from source .dol files

// Source: dol/ast.dol
/// Declarations are the top-level constructs in DOL.
/// Each declaration introduces a new named entity into the namespace.
#[derive(Debug, Clone)]
pub struct DolFile {
    pub declarations: String,
    pub span: String,
}

impl DolFile {
    pub fn new(declarations: String, span: String) -> Self {
        Self {
            declarations,
            span,
        }
    }
}


/// A gene is DOL's primary data structure, similar to a struct but with
/// built-in support for constraints, methods, and optional enum types.
#[derive(Debug, Clone)]
pub struct Decl {
    pub r#type: String,
    pub span: String,
}

impl Decl {
    pub fn new(r#type: String, span: String) -> Self {
        Self {
            r#type,
            span,
        }
    }
}


/// A field is a named component of a gene with optional default value.
#[derive(Debug, Clone)]
pub struct GeneDecl {
    pub name: String,
    pub is_pub: String,
    pub type_params: String,
    pub type_def: String,
    pub fields: String,
    pub methods: String,
    pub constraints: String,
    pub exegesis: String,
    pub span: String,
}

impl GeneDecl {
    pub fn new(name: String, is_pub: String, type_params: String, type_def: String, fields: String, methods: String, constraints: String, exegesis: String, span: String) -> Self {
        Self {
            name,
            is_pub,
            type_params,
            type_def,
            fields,
            methods,
            constraints,
            exegesis,
            span,
        }
    }
}


/// A type parameter for generic types, optionally bounded.
#[derive(Debug, Clone)]
pub struct Field {
    pub name: String,
    pub ty: String,
    pub default_value: String,
    pub is_pub: String,
    pub span: String,
}

impl Field {
    pub fn new(name: String, ty: String, default_value: String, is_pub: String, span: String) -> Self {
        Self {
            name,
            ty,
            default_value,
            is_pub,
            span,
        }
    }
}


/// A trait defines a contract with required methods, provided methods,
/// and laws that implementations must satisfy.
#[derive(Debug, Clone)]
pub struct TypeParam {
    pub name: String,
    pub bounds: String,
    pub span: String,
}

impl TypeParam {
    pub fn new(name: String, bounds: String, span: String) -> Self {
        Self {
            name,
            bounds,
            span,
        }
    }
}


/// A method signature declares a method without providing an implementation.
#[derive(Debug, Clone)]
pub struct TraitDecl {
    pub name: String,
    pub is_pub: String,
    pub type_params: String,
    pub super_traits: String,
    pub required_methods: String,
    pub provided_methods: String,
    pub laws: String,
    pub exegesis: String,
    pub span: String,
}

impl TraitDecl {
    pub fn new(name: String, is_pub: String, type_params: String, super_traits: String, required_methods: String, provided_methods: String, laws: String, exegesis: String, span: String) -> Self {
        Self {
            name,
            is_pub,
            type_params,
            super_traits,
            required_methods,
            provided_methods,
            laws,
            exegesis,
            span,
        }
    }
}


/// A law is a property that must hold for all valid implementations.
#[derive(Debug, Clone)]
pub struct MethodSig {
    pub name: String,
    pub type_params: String,
    pub params: String,
    pub return_type: String,
    pub span: String,
}

impl MethodSig {
    pub fn new(name: String, type_params: String, params: String, return_type: String, span: String) -> Self {
        Self {
            name,
            type_params,
            params,
            return_type,
            span,
        }
    }
}


/// A system is a stateful component that encapsulates state transitions
/// and side effects, similar to actors or services.
#[derive(Debug, Clone)]
pub struct LawDecl {
    pub name: String,
    pub type_params: String,
    pub params: String,
    pub body: String,
    pub exegesis: String,
    pub span: String,
}

impl LawDecl {
    pub fn new(name: String, type_params: String, params: String, body: String, exegesis: String, span: String) -> Self {
        Self {
            name,
            type_params,
            params,
            body,
            exegesis,
            span,
        }
    }
}


/// A constraint is a boolean predicate that must always hold.
/// Constraints enable runtime validation and compile-time verification.
#[derive(Debug, Clone)]
pub struct SystemDecl {
    pub name: String,
    pub is_pub: String,
    pub type_params: String,
    pub uses: String,
    pub states: String,
    pub functions: String,
    pub constraints: String,
    pub exegesis: String,
    pub span: String,
}

impl SystemDecl {
    pub fn new(name: String, is_pub: String, type_params: String, uses: String, states: String, functions: String, constraints: String, exegesis: String, span: String) -> Self {
        Self {
            name,
            is_pub,
            type_params,
            uses,
            states,
            functions,
            constraints,
            exegesis,
            span,
        }
    }
}


/// Evolution declarations describe schema migrations between versions.
#[derive(Debug, Clone)]
pub struct ConstraintDecl {
    pub name: String,
    pub params: String,
    pub body: String,
    pub exegesis: String,
    pub span: String,
}

impl ConstraintDecl {
    pub fn new(name: String, params: String, body: String, exegesis: String, span: String) -> Self {
        Self {
            name,
            params,
            body,
            exegesis,
            span,
        }
    }
}


/// A change describes a single modification in an evolution.
#[derive(Debug, Clone)]
pub struct EvolvesDecl {
    pub from_type: String,
    pub from_version: String,
    pub to_type: String,
    pub to_version: String,
    pub changes: String,
    pub migrate: String,
    pub exegesis: String,
    pub span: String,
}

impl EvolvesDecl {
    pub fn new(from_type: String, from_version: String, to_type: String, to_version: String, changes: String, migrate: String, exegesis: String, span: String) -> Self {
        Self {
            from_type,
            from_version,
            to_type,
            to_version,
            changes,
            migrate,
            exegesis,
            span,
        }
    }
}


/// A function declaration includes pure functions and side-effectful functions.
/// Side effects are marked with `sex` (side effect execution).
#[derive(Debug, Clone)]
pub struct Change {
    pub r#type: String,
    pub span: String,
}

impl Change {
    pub fn new(r#type: String, span: String) -> Self {
        Self {
            r#type,
            span,
        }
    }
}


/// A parameter is a named, typed input to a function.
#[derive(Debug, Clone)]
pub struct FunctionDecl {
    pub name: String,
    pub is_pub: String,
    pub is_sex: String,
    pub is_extern: String,
    pub type_params: String,
    pub params: String,
    pub return_type: String,
    pub body: String,
    pub where_clause: String,
    pub exegesis: String,
    pub span: String,
}

impl FunctionDecl {
    pub fn new(name: String, is_pub: String, is_sex: String, is_extern: String, type_params: String, params: String, return_type: String, body: String, where_clause: String, exegesis: String, span: String) -> Self {
        Self {
            name,
            is_pub,
            is_sex,
            is_extern,
            type_params,
            params,
            return_type,
            body,
            where_clause,
            exegesis,
            span,
        }
    }
}


/// A where predicate constrains type parameters.
#[derive(Debug, Clone)]
pub struct Param {
    pub name: String,
    pub ty: String,
    pub default_value: String,
    pub is_variadic: String,
    pub span: String,
}

impl Param {
    pub fn new(name: String, ty: String, default_value: String, is_variadic: String, span: String) -> Self {
        Self {
            name,
            ty,
            default_value,
            is_variadic,
            span,
        }
    }
}


/// Type expressions represent types in DOL source code.
/// They range from primitive types to complex generic and function types.
#[derive(Debug, Clone)]
pub struct WherePredicate {
    pub type_name: String,
    pub bounds: String,
    pub span: String,
}

impl WherePredicate {
    pub fn new(type_name: String, bounds: String, span: String) -> Self {
        Self {
            type_name,
            bounds,
            span,
        }
    }
}


/// An enum variant is a single case in an enumeration.
#[derive(Debug, Clone)]
pub struct TypeExpr {
    pub r#type: String,
    pub span: String,
}

impl TypeExpr {
    pub fn new(r#type: String, span: String) -> Self {
        Self {
            r#type,
            span,
        }
    }
}


/// Expressions are the computational core of DOL.
/// They produce values and can be composed in complex ways.
#[derive(Debug, Clone)]
pub struct EnumVariant {
    pub name: String,
    pub fields: String,
    pub span: String,
}

impl EnumVariant {
    pub fn new(name: String, fields: String, span: String) -> Self {
        Self {
            name,
            fields,
            span,
        }
    }
}


/// A call argument may be positional or named.
#[derive(Debug, Clone)]
pub struct Expr {
    pub r#type: String,
    pub span: String,
}

impl Expr {
    pub fn new(r#type: String, span: String) -> Self {
        Self {
            r#type,
            span,
        }
    }
}


/// A field initializer in struct construction.
#[derive(Debug, Clone)]
pub struct CallArg {
    pub name: String,
    pub value: String,
    pub span: String,
}

impl CallArg {
    pub fn new(name: String, value: String, span: String) -> Self {
        Self {
            name,
            value,
            span,
        }
    }
}


/// A lambda parameter may have optional type annotation.
#[derive(Debug, Clone)]
pub struct FieldInit {
    pub name: String,
    pub value: String,
    pub span: String,
}

impl FieldInit {
    pub fn new(name: String, value: String, span: String) -> Self {
        Self {
            name,
            value,
            span,
        }
    }
}


/// An else branch can be another if or a block.
#[derive(Debug, Clone)]
pub struct LambdaParam {
    pub name: String,
    pub ty: String,
    pub span: String,
}

impl LambdaParam {
    pub fn new(name: String, ty: String, span: String) -> Self {
        Self {
            name,
            ty,
            span,
        }
    }
}


/// Binary operators for two-operand expressions.
#[derive(Debug, Clone)]
pub struct ElseBranch {
    pub r#type: String,
    pub span: String,
}

impl ElseBranch {
    pub fn new(r#type: String, span: String) -> Self {
        Self {
            r#type,
            span,
        }
    }
}


/// Unary operators for single-operand expressions.
#[derive(Debug, Clone)]
pub struct BinOp {
    pub r#type: String,
}

impl BinOp {
    pub fn new(r#type: String) -> Self {
        Self {
            r#type,
        }
    }
}


/// Match arms connect patterns to expressions.
#[derive(Debug, Clone)]
pub struct UnaryOp {
    pub r#type: String,
}

impl UnaryOp {
    pub fn new(r#type: String) -> Self {
        Self {
            r#type,
        }
    }
}


/// Patterns destructure values and bind variables.
#[derive(Debug, Clone)]
pub struct MatchArm {
    pub pattern: String,
    pub guard: String,
    pub body: String,
    pub span: String,
}

impl MatchArm {
    pub fn new(pattern: String, guard: String, body: String, span: String) -> Self {
        Self {
            pattern,
            guard,
            body,
            span,
        }
    }
}


/// A field pattern in struct destructuring.
#[derive(Debug, Clone)]
pub struct Pattern {
    pub r#type: String,
    pub span: String,
}

impl Pattern {
    pub fn new(r#type: String, span: String) -> Self {
        Self {
            r#type,
            span,
        }
    }
}


/// Binding mode controls how pattern variables are bound.
#[derive(Debug, Clone)]
pub struct FieldPattern {
    pub name: String,
    pub pattern: String,
    pub span: String,
}

impl FieldPattern {
    pub fn new(name: String, pattern: String, span: String) -> Self {
        Self {
            name,
            pattern,
            span,
        }
    }
}


/// Statements are executed for their effects.
/// Unlike expressions, statements do not produce values.
#[derive(Debug, Clone)]
pub struct BindingMode {
    pub r#type: String,
}

impl BindingMode {
    pub fn new(r#type: String) -> Self {
        Self {
            r#type,
        }
    }
}


/// A block is a sequence of statements with an optional trailing expression.
/// The trailing expression (without semicolon) becomes the block's value.
#[derive(Debug, Clone)]
pub struct Stmt {
    pub r#type: String,
    pub span: String,
}

impl Stmt {
    pub fn new(r#type: String, span: String) -> Self {
        Self {
            r#type,
            span,
        }
    }
}


/// Visibility controls access to declarations.
#[derive(Debug, Clone)]
pub struct Block {
    pub stmts: String,
    pub expr: String,
    pub span: String,
}

impl Block {
    pub fn new(stmts: String, expr: String, span: String) -> Self {
        Self {
            stmts,
            expr,
            span,
        }
    }
}


/// Attributes provide metadata for declarations.
#[derive(Debug, Clone)]
pub struct Visibility {
    pub r#type: String,
    pub span: String,
}

impl Visibility {
    pub fn new(r#type: String, span: String) -> Self {
        Self {
            r#type,
            span,
        }
    }
}


/// An attribute argument can be a simple value or key-value pair.
#[derive(Debug, Clone)]
pub struct Attribute {
    pub name: String,
    pub args: String,
    pub span: String,
}

impl Attribute {
    pub fn new(name: String, args: String, span: String) -> Self {
        Self {
            name,
            args,
            span,
        }
    }
}


/// Helper functions for working with AST nodes.
#[derive(Debug, Clone)]
pub struct AttrArg {
    pub r#type: String,
    pub span: String,
}

impl AttrArg {
    pub fn new(r#type: String, span: String) -> Self {
        Self {
            r#type,
            span,
        }
    }
}


pub fn ident(name: String, span: Span) -> Expr {
    return Expr(Expr::Ident(name), span);
}


pub fn int_lit(value: i64, span: Span) -> Expr {
    return Expr(Expr::IntLit(value, None), span);
}


pub fn string_lit(value: String, span: Span) -> Expr {
    return Expr(Expr::StringLit(value, false), span);
}


pub fn bool_lit(value: bool, span: Span) -> Expr {
    return Expr(Expr::BoolLit(value), span);
}


pub fn binary(op: BinOp, left: Expr, right: Expr, span: Span) -> Expr {
    return Expr(Expr::Binary(op, Box::new(left), Box::new(right)), span);
}


pub fn call(callee: Expr, args: Vec<Expr>, span: Span) -> Expr {
    let call_args = args.map(|arg| { CallArg(None, arg, arg.span) });
    return Expr(Expr::Call(Box::new(callee), call_args), span);
}


pub fn empty_block(span: Span) -> Block {
    return Block(vec![], None, span);
}


pub fn expr_block(expr: Expr, span: Span) -> Block {
    return Block(vec![], Some(expr), span);
}


pub fn is_primitive(ty: TypeExpr) -> bool {
    match ty.type {
    Int8 => {
    return true;
},
    Int16 => {
    return true;
},
    Int32 => {
    return true;
},
    Int64 => {
    return true;
},
    UInt8 => {
    return true;
},
    UInt16 => {
    return true;
},
    UInt32 => {
    return true;
},
    UInt64 => {
    return true;
},
    Float32 => {
    return true;
},
    Float64 => {
    return true;
},
    Bool => {
    return true;
},
    String => {
    return true;
},
    Char => {
    return true;
},
    Void => {
    return true;
},
    _ => {
    return false;
}
};
}


pub fn type_name(ty: TypeExpr) -> Option<String> {
    match ty.type {
    Named(path) => {
    if (path.length() > 0) {
    return Some(path((path.length() - 1)));
};
    return None;
},
    Generic(name, args(_)) => {
    return Some(name);
},
    _ => {
    return None;
}
};
}


