// Generated by dol-codegen from Metal DOL declarations
// Do not edit manually - regenerate from source .dol files

// Source: dol/main.dol
/// sex extern read_file
#[derive(Debug, Clone)]
pub struct ReadFile {
}

impl ReadFile {
    pub fn new() -> Self {
        Self {
        }
    }
}


/// sex extern write_file
#[derive(Debug, Clone)]
pub struct WriteFile {
}

impl WriteFile {
    pub fn new() -> Self {
        Self {
        }
    }
}


/// sex extern println
#[derive(Debug, Clone)]
pub struct Println {
}

impl Println {
    pub fn new() -> Self {
        Self {
        }
    }
}


/// sex extern eprintln
#[derive(Debug, Clone)]
pub struct Eprintln {
}

impl Eprintln {
    pub fn new() -> Self {
        Self {
        }
    }
}


/// sex extern exit
#[derive(Debug, Clone)]
pub struct Exit {
}

impl Exit {
    pub fn new() -> Self {
        Self {
        }
    }
}


/// Main entry point for the DOL compiler.
/// 
/// Parses command-line arguments and dispatches to the appropriate
/// command handler. All commands follow Unix conventions for exit codes.
#[derive(Debug, Clone)]
pub struct CompileResult {
    pub r#type: String,
}

impl CompileResult {
    pub fn new(r#type: String) -> Self {
        Self {
            r#type,
        }
    }
}


pub fn main(args: Vec<String>) -> i32 {
    if (args.length() < 2) {
    print_usage();
    return 1;
};
    let command = args.get(1);
    match command {
    "compile" => {
    return handle_compile(args);
},
    "check" => {
    return handle_check(args);
},
    "parse" => {
    return handle_parse(args);
},
    "help" | "--help" | "-h" => {
    print_usage();
    return 0;
},
    "version" | "--version" | "-v" => {
    println("dol 0.4.0");
    return 0;
},
    _ => {
    eprintln(("Error: Unknown command '" + (command + "'")));
    print_usage();
    return 1;
}
};
}


pub fn handle_compile(args: Vec<String>) -> i32 {
    if (args.length() < 5) {
    eprintln("Error: compile requires <input> -o <output>");
    eprintln("Usage: dol compile <input.dol> -o <output.rs>");
    return 1;
};
    let input_path = args.get(2);
    let flag = args.get(3);
    let output_path = args.get(4);
    if (flag != "-o") {
    eprintln(("Error: Expected '-o' flag, got '" + (flag + "'")));
    return 1;
};
    match compile_file(input_path, output_path) {
    CompileResult::Ok(_) => {
    println(("[OK] Compiled " + (input_path + (" -> " + output_path))));
    return 0;
},
    CompileResult::FileError(msg) => {
    eprintln(("[ERROR] File error: " + msg));
    return 2;
},
    CompileResult::ParseError(err) => {
    eprintln(("[ERROR] Parse error at line " + (err.line.to_string() + ":")));
    eprintln(("  " + err.message));
    return 3;
},
    CompileResult::TypeError(err) => {
    eprintln(("[ERROR] Type error: " + err.message));
    return 4;
},
    CompileResult::CodegenError(msg) => {
    eprintln(("[ERROR] Code generation error: " + msg));
    return 5;
}
};
}


pub fn handle_check(args: Vec<String>) -> i32 {
    if (args.length() < 3) {
    eprintln("Error: check requires <input>");
    eprintln("Usage: dol check <input.dol>");
    return 1;
};
    let input_path = args.get(2);
    match check_file(input_path) {
    CompileResult::Ok(_) => {
    println(("[OK] " + (input_path + " is valid")));
    return 0;
},
    CompileResult::FileError(msg) => {
    eprintln(("[ERROR] File error: " + msg));
    return 2;
},
    CompileResult::ParseError(err) => {
    eprintln(("[ERROR] Parse error at line " + (err.line.to_string() + ":")));
    eprintln(("  " + err.message));
    return 3;
},
    CompileResult::TypeError(err) => {
    eprintln(("[ERROR] Type error: " + err.message));
    return 4;
},
    CompileResult::CodegenError(msg) => {
    eprintln(("[ERROR] Unexpected error: " + msg));
    return 5;
}
};
}


pub fn handle_parse(args: Vec<String>) -> i32 {
    if (args.length() < 3) {
    eprintln("Error: parse requires <input>");
    eprintln("Usage: dol parse <input.dol>");
    return 1;
};
    let input_path = args.get(2);
    match parse_file_cmd(input_path) {
    CompileResult::Ok(ast) => {
    println(("[OK] " + (input_path + " parsed successfully")));
    println("");
    println(("Module: " + ast.name));
    println(("Version: " + ast.version));
    println(("Declarations: " + ast.declarations.length().to_string()));
    return 0;
},
    CompileResult::FileError(msg) => {
    eprintln(("[ERROR] File error: " + msg));
    return 2;
},
    CompileResult::ParseError(err) => {
    eprintln(("[ERROR] Parse error at line " + (err.line.to_string() + ":")));
    eprintln(("  " + err.message));
    return 3;
},
    CompileResult::TypeError(_) => {
    eprintln("[ERROR] Unexpected type error during parse");
    return 4;
},
    CompileResult::CodegenError(msg) => {
    eprintln(("[ERROR] Unexpected error: " + msg));
    return 5;
}
};
}


pub fn compile_file(input_path: String, output_path: String) -> CompileResult<Unit> {
    let source = match read_file(input_path) {
    Some(content) => {
    content
},
    None => {
    return CompileResult::FileError(("Could not read file: " + input_path));
}
};
    let tokens = lex(source);
    let ast = match parse(tokens) {
    Ok(module) => {
    module
},
    Err(err) => {
    return CompileResult::ParseError(err);
}
};
    let type_env = TypeEnv::new();
    match typecheck(ast, type_env) {
    Ok(typed_ast) => {
    let codegen = RustCodegen::new();
    let rust_code = match codegen.generate(typed_ast) {
    Ok(code) => {
    code
},
    Err(msg) => {
    return CompileResult::CodegenError(msg);
}
};
    if write_file(output_path, rust_code) {
    return CompileResult::Ok(());
} else {
    return CompileResult::FileError(("Could not write file: " + output_path));
}
},
    Err(err) => {
    return CompileResult::TypeError(err);
}
};
}


pub fn check_file(input_path: String) -> CompileResult<Unit> {
    let source = match read_file(input_path) {
    Some(content) => {
    content
},
    None => {
    return CompileResult::FileError(("Could not read file: " + input_path));
}
};
    let tokens = lex(source);
    let ast = match parse(tokens) {
    Ok(module) => {
    module
},
    Err(err) => {
    return CompileResult::ParseError(err);
}
};
    let type_env = TypeEnv::new();
    match typecheck(ast, type_env) {
    Ok(_) => {
    return CompileResult::Ok(());
},
    Err(err) => {
    return CompileResult::TypeError(err);
}
};
}


pub fn parse_file_cmd(input_path: String) -> CompileResult<Module> {
    let source = match read_file(input_path) {
    Some(content) => {
    content
},
    None => {
    return CompileResult::FileError(("Could not read file: " + input_path));
}
};
    let tokens = lex(source);
    match parse(tokens) {
    Ok(module) => {
    return CompileResult::Ok(module);
},
    Err(err) => {
    return CompileResult::ParseError(err);
}
};
}


pub fn print_usage() {
    println("DOL Compiler 0.4.0");
    println("");
    println("USAGE:");
    println("    dol <command> [options]");
    println("");
    println("COMMANDS:");
    println("    compile <input> -o <output>  Compile DOL to Rust");
    println("    check <input>                Validate DOL file");
    println("    parse <input>                Parse and show AST info");
    println("    help                         Show this message");
    println("    version                      Show version");
    println("");
    println("EXAMPLES:");
    println("    dol compile main.dol -o main.rs");
    println("    dol check lib.dol");
    println("    dol parse module.dol");
    println("");
    println("EXIT CODES:");
    println("    0  Success");
    println("    1  Invalid arguments");
    println("    2  File I/O error");
    println("    3  Parse error");
    println("    4  Type error");
    println("    5  Code generation error");
}


