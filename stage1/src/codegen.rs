// Generated by dol-codegen from Metal DOL declarations
// Do not edit manually - regenerate from source .dol files

// Source: dol/codegen.dol
/// Main entry point for code generation.
/// Takes a parsed DOL file and returns generated Rust source code.
#[derive(Debug, Clone)]
pub struct RustCodegen {
    pub output: String,
    pub indent: String,
}

impl RustCodegen {
    pub fn new(output: String, indent: String) -> Self {
        Self {
            output,
            indent,
        }
    }

    pub fn emit(s: String) {
        self.output = (self.output + s);
    }

    pub fn emit_line(s: String) {
        let indent_str = "";
        let i = 0;
        while (i < self.indent) {
            indent_str = (indent_str + "    ");
            i = (i + 1);
        }
        self.output = (self.output + (indent_str + (s + "
")));
    }

    pub fn emit_newline() {
        self.output = (self.output + "
");
    }

    pub fn push_indent() {
        self.indent = (self.indent + 1);
    }

    pub fn pop_indent() {
        if (self.indent > 0) {
    self.indent = (self.indent - 1);
};
    }

    pub fn gen_file(file: DolFile) -> String {
        self.output = "";
        self.indent = 0;
        self.emit_line("// Generated from DOL source");
        self.emit_line("// Do not edit manually");
        self.emit_newline();
        match file.module {
    Some(mod_decl) => {
    let mod_name = mod_decl.path.join("::");
    self.emit_line(("//! Module: " + mod_name));
    if (mod_decl.version != None) {
    self.emit_line(("//! Version: " + mod_decl.version.unwrap().to_string()))
};
    self.emit_newline()
},
    None => {
}
};
        self.emit_line("use std::collections::HashMap;");
        self.emit_newline();
        for use_decl in file.uses {
            self.gen_use(use_decl);
        }
        if (file.uses.length() > 0) {
    self.emit_newline()
};
        for decl in file.declarations {
            self.gen_decl(decl);
            self.emit_newline();
        }
        return self.output;
    }

    pub fn gen_use(use_decl: UseDecl) {
        let path = use_decl.path.join("::");
        match use_decl.items {
    UseItems.All => {
    self.emit_line(("use " + (path + "::*;")))
},
    UseItems.Single => {
    match use_decl.alias {
    Some(alias) => {
    self.emit_line(("use " + (path + (" as " + (alias + ";")))))
},
    None => {
    self.emit_line(("use " + (path + ";")))
}
}
},
    UseItems::Named(items) => {
    let item_strs = vec![];
    for item in items {
        match item.alias {
    Some(alias) => {
    item_strs.push((item.name + (" as " + alias)))
},
    None => {
    item_strs.push(item.name)
}
};
    }
    self.emit_line(("use " + (path + ("::{" + (item_strs.join(", ") + "};")))))
}
};
    }

    pub fn gen_decl(decl: Decl) {
        match decl {
    Decl::Gene(gene) => {
    self.gen_gene(gene)
},
    Decl::Trait(trait_) => {
    self.gen_trait(trait_)
},
    Decl::Constraint(constraint) => {
    self.gen_constraint_validator(constraint)
},
    Decl::System(system) => {
    self.gen_system(system)
},
    Decl::Evolution(evolution) => {
    self.gen_evolution(evolution)
},
    Decl::Function(func) => {
    self.gen_function(func)
},
    Decl::Enum(name, variants) => {
    self.gen_enum(name, variants)
}
};
    }

    pub fn gen_gene(gene: GeneDecl) {
        let name = self.pascal_case(gene.name);
        if (gene.exegesis != "") {
    self.emit_line(("/// " + gene.exegesis.replace("
", "
/// ")))
};
        self.emit_line("#[derive(Debug, Clone, PartialEq)]");
        let vis = self.gen_visibility(gene.visibility);
        let type_params_str = "";
        if (gene.type_params != None) {
    type_params_str = self.gen_type_params(gene.type_params.unwrap());
};
        self.emit_line((vis + ("struct " + (name + (type_params_str + " {")))));
        self.push_indent();
        for stmt in gene.statements {
            match stmt {
    Statement::HasField(field) => {
    self.gen_field(field)
},
    _ => {
}
};
        }
        self.pop_indent();
        self.emit_line("}");
        self.emit_newline();
        let has_methods = false;
        for stmt in gene.statements {
            match stmt {
    Statement::Function(func) => {
    has_methods = true;
},
    _ => {
}
};
        }
        if has_methods {
    self.emit_line(("impl" + (type_params_str + (" " + (name + (type_params_str + " {"))))));
    self.push_indent();
    for stmt in gene.statements {
        match stmt {
    Statement::Function(func) => {
    self.gen_method(func);
    self.emit_newline()
},
    _ => {
}
};
    }
    self.pop_indent();
    self.emit_line("}")
};
    }

    pub fn gen_field(field: HasField) {
        let field_name = self.snake_case(field.name);
        let field_type = self.gen_type(field.type_);
        if (field.constraint != None) {
    self.emit_line(("/// Constraint: " + self.gen_expr(field.constraint.unwrap())))
};
        self.emit_line(("pub " + (field_name + (": " + (field_type + ",")))));
    }

    pub fn gen_enum(name: String, variants: Vec<EnumVariant>) {
        let enum_name = self.pascal_case(name);
        self.emit_line("#[derive(Debug, Clone, PartialEq)]");
        self.emit_line(("pub enum " + (enum_name + " {")));
        self.push_indent();
        for variant in variants {
            let variant_name = self.pascal_case(variant.name);
            match variant.fields {
    Some(fields) => {
    if (fields.length() == 0) {
    self.emit_line((variant_name + ","))
} else {
    let first_field = fields(0);
    if (first_field.name != "") {
    self.emit_line((variant_name + " {"));
    self.push_indent();
    for field in fields {
        let f_name = self.snake_case(field.name);
        let f_type = self.gen_type(field.type_);
        self.emit_line((f_name + (": " + (f_type + ","))));
    }
    self.pop_indent();
    self.emit_line("},")
} else {
    let types = vec![];
    for field in fields {
        types.push(self.gen_type(field.type_));
    }
    self.emit_line((variant_name + ("(" + (types.join(", ") + "),"))))
}
}
},
    None => {
    self.emit_line((variant_name + ","))
}
};
        }
        self.pop_indent();
        self.emit_line("}");
    }

    pub fn gen_trait(trait_: TraitDecl) {
        let name = self.pascal_case(trait_.name);
        if (trait_.exegesis != "") {
    self.emit_line(("/// " + trait_.exegesis.replace("
", "
/// ")))
};
        let vis = self.gen_visibility(trait_.visibility);
        let type_params_str = "";
        if (trait_.type_params != None) {
    type_params_str = self.gen_type_params(trait_.type_params.unwrap());
};
        let bounds = "";
        if (trait_.supertraits.length() > 0) {
    let bound_strs = vec![];
    for supertrait in trait_.supertraits {
        bound_strs.push(self.pascal_case(supertrait));
    }
    bounds = (": " + bound_strs.join(" + "));
};
        self.emit_line((vis + ("trait " + (name + (type_params_str + (bounds + " {"))))));
        self.push_indent();
        for assoc in trait_.associated_types {
            self.emit_line(("type " + (self.pascal_case(assoc.name) + ";")));
        }
        if (trait_.associated_types.length() > 0) {
    self.emit_newline()
};
        for stmt in trait_.statements {
            match stmt {
    Statement::Function(func) => {
    self.gen_trait_method(func);
    self.emit_newline()
},
    _ => {
}
};
        }
        for law in trait_.laws {
            self.emit_line(("// Law: " + law.name));
            self.emit_line(("// " + self.gen_expr(law.body)));
            self.emit_newline();
        }
        self.pop_indent();
        self.emit_line("}");
    }

    pub fn gen_trait_method(func: FunctionDecl) {
        let vis = self.gen_visibility(func.visibility);
        let name = self.snake_case(func.name);
        let params = self.gen_params(func.params);
        let return_type = "";
        match func.return_type {
    Some(ty) => {
    return_type = (" -> " + self.gen_type(ty));
},
    None => {
}
};
        if (func.body.length() > 0) {
    self.emit_line(("fn " + (name + ("(" + (params + (")" + (return_type + " {")))))));
    self.push_indent();
    self.gen_block(func.body);
    self.pop_indent();
    self.emit_line("}")
} else {
    self.emit_line(("fn " + (name + ("(" + (params + (")" + (return_type + ";")))))))
};
    }

    pub fn gen_function(func: FunctionDecl) {
        let vis = self.gen_visibility(func.visibility);
        let name = self.snake_case(func.name);
        let type_params_str = "";
        if (func.type_params != None) {
    type_params_str = self.gen_type_params(func.type_params.unwrap());
};
        let params = self.gen_params(func.params);
        let return_type = "";
        match func.return_type {
    Some(ty) => {
    return_type = (" -> " + self.gen_type(ty));
},
    None => {
}
};
        self.emit_line((vis + ("fn " + (name + (type_params_str + ("(" + (params + (")" + (return_type + " {")))))))));
        self.push_indent();
        self.gen_block(func.body);
        self.pop_indent();
        self.emit_line("}");
    }

    pub fn gen_method(method: FunctionDecl) {
        let vis = self.gen_visibility(method.visibility);
        let name = self.snake_case(method.name);
        let type_params_str = "";
        if (method.type_params != None) {
    type_params_str = self.gen_type_params(method.type_params.unwrap());
};
        let self_param = "&self";
        match method.purity {
    Purity.Sex => {
    self_param = "&mut self";
},
    Purity.Pure => {
}
};
        let params = self.gen_params(method.params);
        if (params != "") {
    params = (self_param + (", " + params));
} else {
    params = self_param;
};
        let return_type = "";
        match method.return_type {
    Some(ty) => {
    return_type = (" -> " + self.gen_type(ty));
},
    None => {
}
};
        self.emit_line((vis + ("fn " + (name + (type_params_str + ("(" + (params + (")" + (return_type + " {")))))))));
        self.push_indent();
        self.gen_block(method.body);
        self.pop_indent();
        self.emit_line("}");
    }

    pub fn gen_constraint_validator(constraint: ConstraintDecl) {
        let name = (self.snake_case(constraint.name) + "_validator");
        if (constraint.exegesis != "") {
    self.emit_line(("/// " + constraint.exegesis.replace("
", "
/// ")))
};
        self.emit_line(("pub fn " + (name + "() -> Result<(), &'static str> {")));
        self.push_indent();
        for stmt in constraint.statements {
            match stmt {
    Statement::Matches(subject, target, span) => {
    self.emit_line(("// Validate: " + (subject + (" matches " + target))));
    self.emit_line(("if " + (self.snake_case(subject) + (" != " + (self.snake_case(target) + " {")))));
    self.push_indent();
    self.emit_line(("return Err("" + (subject + (" does not match " + (target + "");")))));
    self.pop_indent();
    self.emit_line("}")
},
    Statement::Never(subject, action, span) => {
    self.emit_line(("// Validate: " + (subject + (" never " + action))));
    self.emit_line(("if " + (self.snake_case(subject) + ("_" + (self.snake_case(action) + " {")))));
    self.push_indent();
    self.emit_line(("return Err("" + (subject + (" must never " + (action + "");")))));
    self.pop_indent();
    self.emit_line("}")
},
    Statement::Requires(subject, requirement, span) => {
    self.emit_line(("// Validate: " + (subject + (" requires " + requirement))));
    self.emit_line(("if !" + (self.snake_case(subject) + ("_has_" + (self.snake_case(requirement) + " {")))));
    self.push_indent();
    self.emit_line(("return Err("" + (subject + (" requires " + (requirement + "");")))));
    self.pop_indent();
    self.emit_line("}")
},
    _ => {
}
};
        }
        self.emit_line("Ok(())");
        self.pop_indent();
        self.emit_line("}");
    }

    pub fn gen_validate_all(constraints: Vec<ConstraintDecl>) {
        self.emit_line("/// Run all constraint validators");
        self.emit_line("pub fn validate_all() -> Result<(), Vec<&'static str>> {");
        self.push_indent();
        self.emit_line("let mut errors = Vec::new();");
        self.emit_newline();
        for constraint in constraints {
            let validator_name = (self.snake_case(constraint.name) + "_validator");
            self.emit_line(("if let Err(e) = " + (validator_name + "() {")));
            self.push_indent();
            self.emit_line("errors.push(e);");
            self.pop_indent();
            self.emit_line("}");
        }
        self.emit_newline();
        self.emit_line("if errors.is_empty() {");
        self.push_indent();
        self.emit_line("Ok(())");
        self.pop_indent();
        self.emit_line("} else {");
        self.push_indent();
        self.emit_line("Err(errors)");
        self.pop_indent();
        self.emit_line("}");
        self.pop_indent();
        self.emit_line("}");
    }

    pub fn gen_system(system: SystemDecl) {
        let name = self.pascal_case(system.name);
        if (system.exegesis != "") {
    self.emit_line(("/// " + system.exegesis.replace("
", "
/// ")));
    self.emit_line(("/// Version: " + system.version))
};
        self.emit_line("#[derive(Debug, Clone, PartialEq)]");
        self.emit_line(("pub struct " + (name + " {")));
        self.push_indent();
        for state in system.states {
            let field_name = self.snake_case(state.name);
            let field_type = self.gen_type(state.type_);
            self.emit_line(("pub " + (field_name + (": " + (field_type + ",")))));
        }
        self.pop_indent();
        self.emit_line("}");
        self.emit_newline();
        self.emit_line(("impl " + (name + " {")));
        self.push_indent();
        self.emit_line("pub fn new() -> Self {");
        self.push_indent();
        self.emit_line("Self {");
        self.push_indent();
        for state in system.states {
            let field_name = self.snake_case(state.name);
            match state.default {
    Some(default_val) => {
    self.emit_line((field_name + (": " + (self.gen_expr(default_val) + ","))))
},
    None => {
    self.emit_line((field_name + ": Default::default(),"))
}
};
        }
        self.pop_indent();
        self.emit_line("}");
        self.pop_indent();
        self.emit_line("}");
        for stmt in system.statements {
            match stmt {
    Statement::Function(func) => {
    self.emit_newline();
    self.gen_method(func)
},
    _ => {
}
};
        }
        self.pop_indent();
        self.emit_line("}");
    }

    pub fn gen_evolution(evolution: EvolutionDecl) {
        let name = self.pascal_case(evolution.name);
        let from_version = evolution.parent_version.replace(".", "_");
        let to_version = evolution.version.replace(".", "_");
        self.emit_line(("/// Migration from v" + (evolution.parent_version + (" to v" + evolution.version))));
        if (evolution.rationale != None) {
    self.emit_line(("/// Rationale: " + evolution.rationale.unwrap()))
};
        self.emit_line(("pub fn migrate_" + (self.snake_case(evolution.name) + ("_v" + (from_version + ("_to_v" + (to_version + ("(old: &" + (name + ("V" + (from_version + (") -> " + (name + ("V" + (to_version + " {")))))))))))))));
        self.push_indent();
        self.emit_line("// TODO: Implement migration logic");
        self.emit_line("unimplemented!()");
        self.pop_indent();
        self.emit_line("}");
    }

    pub fn gen_type(ty: TypeExpr) -> String {
        match ty {
    TypeExpr::Named(name) => {
    return self.map_primitive_type(name);
},
    TypeExpr::Generic(name, args) => {
    let mapped_name = self.map_generic_type(name);
    let arg_strs = vec![];
    for arg in args {
        arg_strs.push(self.gen_type(arg));
    }
    return (mapped_name + ("<" + (arg_strs.join(", ") + ">")));
},
    TypeExpr::Function(params, return_type) => {
    let param_strs = vec![];
    for param in params {
        param_strs.push(self.gen_type(param));
    }
    let ret = self.gen_type(return_type);
    return ("fn(" + (param_strs.join(", ") + (") -> " + ret)));
},
    TypeExpr::Tuple(types) => {
    if (types.length() == 0) {
    return "()";
};
    let type_strs = vec![];
    for t in types {
        type_strs.push(self.gen_type(t));
    }
    return ("(" + (type_strs.join(", ") + ")"));
}
};
    }

    pub fn map_primitive_type(name: String) -> String {
        match name {
    "Int8" => {
    return "i8";
},
    "Int16" => {
    return "i16";
},
    "Int32" => {
    return "i32";
},
    "Int64" => {
    return "i64";
},
    "UInt8" => {
    return "u8";
},
    "UInt16" => {
    return "u16";
},
    "UInt32" => {
    return "u32";
},
    "UInt64" => {
    return "u64";
},
    "Float32" => {
    return "f32";
},
    "Float64" => {
    return "f64";
},
    "Bool" => {
    return "bool";
},
    "String" => {
    return "String";
},
    "Void" => {
    return "()";
},
    "Char" => {
    return "char";
},
    "Self" => {
    return "Self";
},
    _ => {
    return self.pascal_case(name);
}
};
    }

    pub fn map_generic_type(name: String) -> String {
        match name {
    "List" => {
    return "Vec";
},
    "Option" => {
    return "Option";
},
    "Result" => {
    return "Result";
},
    "Map" => {
    return "std::collections::HashMap";
},
    "Set" => {
    return "std::collections::HashSet";
},
    "Box" => {
    return "Box";
},
    "Rc" => {
    return "std::rc::Rc";
},
    "Arc" => {
    return "std::sync::Arc";
},
    "RefCell" => {
    return "std::cell::RefCell";
},
    "Mutex" => {
    return "std::sync::Mutex";
},
    _ => {
    return self.pascal_case(name);
}
};
    }

    pub fn gen_type_params(type_params: TypeParams) -> String {
        if (type_params.params.length() == 0) {
    return "";
};
        let param_strs = vec![];
        for param in type_params.params {
            let param_str = param.name;
            if (param.bounds.length() > 0) {
    let bound_strs = vec![];
    for bound in param.bounds {
        bound_strs.push(self.gen_type(bound));
    }
    param_str = (param_str + (": " + bound_strs.join(" + ")));
};
            param_strs.push(param_str);
        }
        return ("<" + (param_strs.join(", ") + ">"));
    }

    pub fn gen_params(params: Vec<Param>) -> String {
        let param_strs = vec![];
        for param in params {
            let param_name = self.snake_case(param.name);
            let param_type = self.gen_type(param.type_);
            param_strs.push((param_name + (": " + param_type)));
        }
        return param_strs.join(", ");
    }

    pub fn gen_block(block: Block) {
        for stmt in block.statements {
            self.gen_stmt(stmt);
        }
        match block.final_expr {
    Some(expr) => {
    self.emit_line(self.gen_expr(expr))
},
    None => {
}
};
    }

    pub fn gen_stmt(stmt: Stmt) {
        match stmt {
    Stmt::Let(name, type_ann, value) => {
    let var_name = self.snake_case(name);
    let type_str = "";
    match type_ann {
    Some(ty) => {
    type_str = (": " + self.gen_type(ty));
},
    None => {
}
};
    self.emit_line(("let " + (var_name + (type_str + (" = " + (self.gen_expr(value) + ";"))))))
},
    Stmt::Var(name, type_ann, value) => {
    let var_name = self.snake_case(name);
    let type_str = "";
    match type_ann {
    Some(ty) => {
    type_str = (": " + self.gen_type(ty));
},
    None => {
}
};
    match value {
    Some(val) => {
    self.emit_line(("let mut " + (var_name + (type_str + (" = " + (self.gen_expr(val) + ";"))))))
},
    None => {
    self.emit_line(("let mut " + (var_name + (type_str + ";"))))
}
}
},
    Stmt::Assign(target, value) => {
    self.emit_line((self.gen_expr(target) + (" = " + (self.gen_expr(value) + ";"))))
},
    Stmt::For(binding, iterable, body) => {
    self.emit_line(("for " + (self.snake_case(binding) + (" in " + (self.gen_expr(iterable) + " {")))));
    self.push_indent();
    for s in body {
        self.gen_stmt(s);
    }
    self.pop_indent();
    self.emit_line("}")
},
    Stmt::While(condition, body) => {
    self.emit_line(("while " + (self.gen_expr(condition) + " {")));
    self.push_indent();
    for s in body {
        self.gen_stmt(s);
    }
    self.pop_indent();
    self.emit_line("}")
},
    Stmt::Loop(body) => {
    self.emit_line("loop {");
    self.push_indent();
    for s in body {
        self.gen_stmt(s);
    }
    self.pop_indent();
    self.emit_line("}")
},
    Stmt::If(condition, then_body, else_body) => {
    self.emit_line(("if " + (self.gen_expr(condition) + " {")));
    self.push_indent();
    for s in then_body {
        self.gen_stmt(s);
    }
    self.pop_indent();
    match else_body {
    Some(else_stmts) => {
    self.emit_line("} else {");
    self.push_indent();
    for s in else_stmts {
        self.gen_stmt(s);
    }
    self.pop_indent();
    self.emit_line("}")
},
    None => {
    self.emit_line("}")
}
}
},
    Stmt.Break => {
    self.emit_line("break;")
},
    Stmt.Continue => {
    self.emit_line("continue;")
},
    Stmt::Return(value) => {
    match value {
    Some(val) => {
    self.emit_line(("return " + (self.gen_expr(val) + ";")))
},
    None => {
    self.emit_line("return;")
}
}
},
    Stmt::Expr(expr) => {
    self.emit_line((self.gen_expr(expr) + ";"))
},
    Stmt::Match(scrutinee, arms) => {
    self.emit_line(("match " + (self.gen_expr(scrutinee) + " {")));
    self.push_indent();
    for arm in arms {
        self.gen_match_arm(arm);
    }
    self.pop_indent();
    self.emit_line("}")
}
};
    }

    pub fn gen_expr(expr: Expr) -> String {
        match expr {
    Expr::Literal(lit) => {
    return self.gen_literal(lit);
},
    Expr::Identifier(name) => {
    return self.snake_case(name);
},
    Expr::Binary(left, op, right) => {
    return self.gen_binary(left, op, right);
},
    Expr::Unary(op, operand) => {
    return self.gen_unary(op, operand);
},
    Expr::Call(callee, args) => {
    let callee_str = self.gen_expr(callee);
    let arg_strs = vec![];
    for arg in args {
        arg_strs.push(self.gen_expr(arg));
    }
    return (callee_str + ("(" + (arg_strs.join(", ") + ")")));
},
    Expr::Member(object, field) => {
    return (self.gen_expr(object) + ("." + self.snake_case(field)));
},
    Expr::Index(object, index) => {
    return (self.gen_expr(object) + ("[" + (self.gen_expr(index) + "]")));
},
    Expr::Lambda(params, return_type, body) => {
    return self.gen_lambda(params, return_type, body);
},
    Expr::If(condition, then_branch, else_branch) => {
    return self.gen_if_expr(condition, then_branch, else_branch);
},
    Expr::Match(scrutinee, arms) => {
    return self.gen_match_expr(scrutinee, arms);
},
    Expr::Block(statements, final_expr) => {
    return self.gen_block_expr(statements, final_expr);
},
    Expr::Quote(inner) => {
    return ("quote!(" + (self.gen_expr(inner) + ")"));
},
    Expr::Unquote(inner) => {
    return ("#" + self.gen_expr(inner));
},
    Expr::QuasiQuote(inner) => {
    return ("quasi_quote!(" + (self.gen_expr(inner) + ")"));
},
    Expr::Eval(inner) => {
    return ("eval(" + (self.gen_expr(inner) + ")"));
},
    Expr::Reflect(type_expr) => {
    return ("std::any::type_name::<" + (self.gen_type(type_expr) + ">()"));
},
    Expr::IdiomBracket(func, args) => {
    return self.gen_idiom_bracket(func, args);
},
    Expr::Forall(forall_expr) => {
    return self.gen_forall(forall_expr);
},
    Expr::Exists(exists_expr) => {
    return self.gen_exists(exists_expr);
},
    Expr::Implies(left, right, span) => {
    return ("implies(" + (self.gen_expr(left) + (", " + (self.gen_expr(right) + ")"))));
},
    Expr::SexBlock(statements, final_expr) => {
    return self.gen_sex_block(statements, final_expr);
},
    Expr::Struct(name, fields) => {
    return self.gen_struct_literal(name, fields);
},
    Expr::Array(elements) => {
    let elem_strs = vec![];
    for elem in elements {
        elem_strs.push(self.gen_expr(elem));
    }
    return ("vec![" + (elem_strs.join(", ") + "]"));
},
    Expr::Tuple(elements) => {
    let elem_strs = vec![];
    for elem in elements {
        elem_strs.push(self.gen_expr(elem));
    }
    return ("(" + (elem_strs.join(", ") + ")"));
},
    Expr.This => {
    return "self";
},
    Expr.None => {
    return "None";
},
    Expr::Some(inner) => {
    return ("Some(" + (self.gen_expr(inner) + ")"));
}
};
    }

    pub fn gen_literal(lit: Literal) -> String {
        match lit {
    Literal::Int(value) => {
    return value.to_string();
},
    Literal::Float(value) => {
    let s = value.to_string();
    if !s.contains(".") {
    return (s + ".0");
};
    return s;
},
    Literal::String(value) => {
    return (""" + (self.escape_string(value) + """));
},
    Literal::Bool(value) => {
    if value {
    return "true";
} else {
    return "false";
}
},
    Literal.Null => {
    return "None";
},
    Literal::Char(value) => {
    return ("'" + (value + "'"));
}
};
    }

    pub fn gen_binary(left: Expr, op: BinaryOp, right: Expr) -> String {
        let left_str = self.gen_expr(left);
        let right_str = self.gen_expr(right);
        match op {
    BinaryOp.Add => {
    return ("(" + (left_str + (" + " + (right_str + ")"))));
},
    BinaryOp.Sub => {
    return ("(" + (left_str + (" - " + (right_str + ")"))));
},
    BinaryOp.Mul => {
    return ("(" + (left_str + (" * " + (right_str + ")"))));
},
    BinaryOp.Div => {
    return ("(" + (left_str + (" / " + (right_str + ")"))));
},
    BinaryOp.Mod => {
    return ("(" + (left_str + (" % " + (right_str + ")"))));
},
    BinaryOp.Pow => {
    return (left_str + (".pow(" + (right_str + ")")));
},
    BinaryOp.Eq => {
    return ("(" + (left_str + (" == " + (right_str + ")"))));
},
    BinaryOp.Ne => {
    return ("(" + (left_str + (" != " + (right_str + ")"))));
},
    BinaryOp.Lt => {
    return ("(" + (left_str + (" < " + (right_str + ")"))));
},
    BinaryOp.Le => {
    return ("(" + (left_str + (" <= " + (right_str + ")"))));
},
    BinaryOp.Gt => {
    return ("(" + (left_str + (" > " + (right_str + ")"))));
},
    BinaryOp.Ge => {
    return ("(" + (left_str + (" >= " + (right_str + ")"))));
},
    BinaryOp.And => {
    return ("(" + (left_str + (" && " + (right_str + ")"))));
},
    BinaryOp.Or => {
    return ("(" + (left_str + (" || " + (right_str + ")"))));
},
    BinaryOp.Pipe => {
    return (right_str + ("(" + (left_str + ")")));
},
    BinaryOp.Compose => {
    return ("|x| " + (right_str + ("(" + (left_str + "(x))"))));
},
    BinaryOp.Apply => {
    return (left_str + ("(" + (right_str + ")")));
},
    BinaryOp.Bind => {
    return (left_str + (" = " + right_str));
},
    BinaryOp.Member => {
    return (left_str + ("." + right_str));
},
    BinaryOp.Map => {
    return (right_str + (".map(" + (left_str + ")")));
},
    BinaryOp.Ap => {
    return (left_str + (".apply(" + (right_str + ")")));
},
    BinaryOp.Implies => {
    return ("(!(" + (left_str + (") || (" + (right_str + "))"))));
}
};
    }

    pub fn gen_unary(op: UnaryOp, operand: Expr) -> String {
        let operand_str = self.gen_expr(operand);
        match op {
    UnaryOp.Neg => {
    return ("(-" + (operand_str + ")"));
},
    UnaryOp.Not => {
    return ("(!" + (operand_str + ")"));
},
    UnaryOp.Quote => {
    return ("quote!(" + (operand_str + ")"));
},
    UnaryOp.Reflect => {
    return ("std::any::type_name_of_val(&" + (operand_str + ")"));
}
};
    }

    pub fn gen_lambda(params: Vec<LambdaParam>, return_type: Option<TypeExpr>, body: Expr) -> String {
        let param_strs = vec![];
        for param in params {
            match param.type_ {
    Some(ty) => {
    param_strs.push((self.snake_case(param.name) + (": " + self.gen_type(ty))))
},
    None => {
    param_strs.push(self.snake_case(param.name))
}
};
        }
        let return_str = "";
        match return_type {
    Some(ty) => {
    return_str = (" -> " + self.gen_type(ty));
},
    None => {
}
};
        return ("|" + (param_strs.join(", ") + ("|" + (return_str + (" " + self.gen_expr(body))))));
    }

    pub fn gen_if_expr(condition: Expr, then_branch: Expr, else_branch: Option<Expr>) -> String {
        let cond_str = self.gen_expr(condition);
        let then_str = self.gen_expr(then_branch);
        match else_branch {
    Some(else_expr) => {
    let else_str = self.gen_expr(else_expr);
    return ("if " + (cond_str + (" { " + (then_str + (" } else { " + (else_str + " }"))))));
},
    None => {
    return ("if " + (cond_str + (" { " + (then_str + " }"))));
}
};
    }

    pub fn gen_match_expr(scrutinee: Expr, arms: Vec<MatchArm>) -> String {
        let scrutinee_str = self.gen_expr(scrutinee);
        let result = ("match " + (scrutinee_str + " {
"));
        for arm in arms {
            let pattern_str = self.gen_pattern(arm.pattern);
            let guard_str = "";
            match arm.guard {
    Some(guard) => {
    guard_str = (" if " + self.gen_expr(guard));
},
    None => {
}
};
            let body_str = self.gen_expr(arm.body);
            result = (result + ("    " + (pattern_str + (guard_str + (" => " + (body_str + ",
"))))));
        }
        result = (result + "}");
        return result;
    }

    pub fn gen_match_arm(arm: MatchArm) {
        let pattern_str = self.gen_pattern(arm.pattern);
        let guard_str = "";
        match arm.guard {
    Some(guard) => {
    guard_str = (" if " + self.gen_expr(guard));
},
    None => {
}
};
        let body_str = self.gen_expr(arm.body);
        self.emit_line((pattern_str + (guard_str + (" => " + (body_str + ",")))));
    }

    pub fn gen_pattern(pattern: Pattern) -> String {
        match pattern {
    Pattern.Wildcard => {
    return "_";
},
    Pattern::Identifier(name) => {
    return self.snake_case(name);
},
    Pattern::Literal(lit) => {
    return self.gen_literal(lit);
},
    Pattern::Constructor(name, fields) => {
    let name_str = self.pascal_case(name);
    if (fields.length() == 0) {
    return name_str;
};
    let field_strs = vec![];
    for field in fields {
        field_strs.push(self.gen_pattern(field));
    }
    return (name_str + ("(" + (field_strs.join(", ") + ")")));
},
    Pattern::Tuple(patterns) => {
    let pattern_strs = vec![];
    for p in patterns {
        pattern_strs.push(self.gen_pattern(p));
    }
    return ("(" + (pattern_strs.join(", ") + ")"));
},
    Pattern::Struct(name, fields) => {
    let name_str = self.pascal_case(name);
    let field_strs = vec![];
    for field in fields {
        field_strs.push((field.name + (": " + self.gen_pattern(field.pattern))));
    }
    return (name_str + (" { " + (field_strs.join(", ") + " }")));
}
};
    }

    pub fn gen_block_expr(statements: Vec<Stmt>, final_expr: Option<Expr>) -> String {
        let result = "{
";
        for stmt in statements {
            result = (result + ("    " + (self.gen_stmt_inline(stmt) + "
")));
        }
        match final_expr {
    Some(expr) => {
    result = (result + ("    " + (self.gen_expr(expr) + "
")));
},
    None => {
}
};
        result = (result + "}");
        return result;
    }

    pub fn gen_stmt_inline(stmt: Stmt) -> String {
        match stmt {
    Stmt::Let(name, type_ann, value) => {
    let var_name = self.snake_case(name);
    let type_str = "";
    match type_ann {
    Some(ty) => {
    type_str = (": " + self.gen_type(ty));
},
    None => {
}
};
    return ("let " + (var_name + (type_str + (" = " + (self.gen_expr(value) + ";")))));
},
    Stmt::Return(value) => {
    match value {
    Some(val) => {
    return ("return " + (self.gen_expr(val) + ";"));
},
    None => {
    return "return;";
}
}
},
    Stmt::Expr(expr) => {
    return (self.gen_expr(expr) + ";");
},
    Stmt.Break => {
    return "break;";
},
    Stmt.Continue => {
    return "continue;";
},
    _ => {
    return "/* complex statement */";
}
};
    }

    pub fn gen_idiom_bracket(func: Expr, args: Vec<Expr>) -> String {
        if (args.length() == 0) {
    return self.gen_expr(func);
};
        let result = (self.gen_expr(args(0)) + (".map(" + (self.gen_expr(func) + ")")));
        let i = 1;
        while (i < args.length()) {
            result = (result + (".apply(" + (self.gen_expr(args(i)) + ")")));
            i = (i + 1);
        }
        return result;
    }

    pub fn gen_forall(forall_expr: ForallExpr) -> String {
        let var_name = self.snake_case(forall_expr.var);
        let type_str = self.gen_type(forall_expr.type_);
        let body_str = self.gen_expr(forall_expr.body);
        return ("forall::<" + (type_str + (">(|" + (var_name + ("| " + (body_str + ")"))))));
    }

    pub fn gen_exists(exists_expr: ExistsExpr) -> String {
        let var_name = self.snake_case(exists_expr.var);
        let type_str = self.gen_type(exists_expr.type_);
        let body_str = self.gen_expr(exists_expr.body);
        return ("exists::<" + (type_str + (">(|" + (var_name + ("| " + (body_str + ")"))))));
    }

    pub fn gen_sex_block(statements: Vec<Stmt>, final_expr: Option<Expr>) -> String {
        return self.gen_block_expr(statements, final_expr);
    }

    pub fn gen_struct_literal(name: String, fields: Vec<FieldInit>) -> String {
        let name_str = self.pascal_case(name);
        let field_strs = vec![];
        for field in fields {
            let field_name = self.snake_case(field.name);
            let value_str = self.gen_expr(field.value);
            if (field.name == field.value.as_identifier()) {
    field_strs.push(field_name)
} else {
    field_strs.push((field_name + (": " + value_str)))
};
        }
        return (name_str + (" { " + (field_strs.join(", ") + " }")));
    }

    pub fn gen_visibility(vis: Visibility) -> String {
        match vis {
    Visibility.Private => {
    return "";
},
    Visibility.Public => {
    return "pub ";
},
    Visibility.PubSpirit => {
    return "pub(crate) ";
},
    Visibility.PubParent => {
    return "pub(super) ";
}
};
    }

    pub fn snake_case(name: String) -> String {
        let result = name.replace(".", "_");
        let output = "";
        let i = 0;
        while (i < result.length()) {
            let c = result.char_at(i);
            if ((c >= 'A') && (c <= 'Z')) {
    if (i > 0) {
    output = (output + "_");
};
    output = (output + c.to_lowercase());
} else {
    output = (output + c);
};
            i = (i + 1);
        }
        return output;
    }

    pub fn pascal_case(name: String) -> String {
        let parts = name.replace(".", "_").split("_");
        let result = "";
        for part in parts {
            if (part.length() > 0) {
    let first = part.char_at(0).to_uppercase();
    let rest = part.substring(1, part.length());
    result = (result + (first + rest));
};
        }
        return result;
    }

    pub fn escape_string(s: String) -> String {
        let result = "";
        let i = 0;
        while (i < s.length()) {
            let c = s.char_at(i);
            match c {
    '\\' => {
    result = (result + "\\");
},
    '\"' => {
    result = (result + "\"");
},
    '\n' => {
    result = (result + "\n");
},
    '\r' => {
    result = (result + "\r");
},
    '\t' => {
    result = (result + "\t");
},
    _ => {
    result = (result + c);
}
};
            i = (i + 1);
        }
        return result;
    }
}


pub fn codegen(file: DolFile) -> String {
    let generator = RustCodegen();
    return generator.gen_file(file);
}


pub fn codegen_decl(decl: Decl) -> String {
    let generator = RustCodegen();
    generator.gen_decl(decl);
    return generator.output;
}


pub fn codegen_type(ty: TypeExpr) -> String {
    let generator = RustCodegen();
    return generator.gen_type(ty);
}


