// Generated by dol-codegen from Metal DOL declarations
// Do not edit manually - regenerate from source .dol files

// Source: dol/lexer.dol
/// Get the character at the current position, if any.
#[derive(Debug, Clone)]
pub struct Lexer {
    pub source: String,
    pub pos: String,
    pub line: String,
    pub column: String,
    pub tokens: String,
}

impl Lexer {
    pub fn new(source: String, pos: String, line: String, column: String, tokens: String) -> Self {
        Self {
            source,
            pos,
            line,
            column,
            tokens,
        }
    }
}


pub fn current(r#self: Lexer) -> Option<Char> {
    if (self.pos >= self.source.length()) {
    return None;
};
    return Some(self.source.char_at(self.pos));
}


pub fn peek(r#self: Lexer, offset: u64) -> Option<Char> {
    let target = (self.pos + offset);
    if (target >= self.source.length()) {
    return None;
};
    return Some(self.source.char_at(target));
}


pub fn advance(r#self: Lexer) -> Option<Char> {
    match self.current() {
    None => None,
    Some(c) => {
    self.pos = (self.pos + 1);
    if (c == '\n') {
    self.line = (self.line + 1);
    self.column = 1;
} else {
    self.column = (self.column + 1);
};
    Some(c)
}
};
}


pub fn make_token(r#self: Lexer, kind: TokenKind, start: u64) -> Token {
    let text = self.source.substring(start, self.pos);
    Token(kind, text, Span(start, self.pos, self.line, (self.column - (self.pos - start) as u32)));
}


pub fn emit(r#self: Lexer, kind: TokenKind, start: u64) {
    let token = self.make_token(kind, start);
    self.tokens.push(token);
}


pub fn skip_whitespace(r#self: Lexer) {
    loop {
        match self.current() {
    None => {
    break;
},
    Some(c) => {
    match c {
    ' ' | '\t' | '\r' | '\n' => {
    self.advance()
},
    _ => {
    break;
}
}
}
};
    }
}


pub fn skip_line_comment(r#self: Lexer) {
    self.advance();
    self.advance();
    loop {
        match self.current() {
    None => {
    break;
},
    Some('\n') => {
    self.advance();
    break;
},
    Some(_) => {
    self.advance()
}
};
    }
}


pub fn is_ident_start(c: Char) -> bool {
    (((c >= 'a') && (c <= 'z')) || (((c >= 'A') && (c <= 'Z')) || (c == '_')));
}


pub fn is_ident_continue(c: Char) -> bool {
    (is_ident_start(c) || ((c >= '0') && (c <= '9')));
}


pub fn scan_identifier(r#self: Lexer) -> Token {
    let start = self.pos;
    loop {
        match self.current() {
    None => {
    break;
},
    Some(c) => {
    if is_ident_continue(c) {
    self.advance()
} else {
    break;
}
}
};
    }
    let text = self.source.substring(start, self.pos);
    let kind = keyword_lookup(text)??;
    TokenKind::Identifier;
    self.make_token(kind, start);
}


pub fn is_digit(c: Char) -> bool {
    ((c >= '0') && (c <= '9'));
}


pub fn scan_number(r#self: Lexer) -> Token {
    let start = self.pos;
    let is_float = false;
    loop {
        match self.current() {
    None => {
    break;
},
    Some(c) => {
    if (is_digit(c) || (c == '_')) {
    self.advance()
} else {
    break;
}
}
};
    }
    match self.current() {
    Some('.') => {
    match self.peek(1) {
    Some(next) => {
    if is_digit(next) {
    is_float = true;
    self.advance();
    loop {
        match self.current() {
    None => {
    break;
},
    Some(c) => {
    if (is_digit(c) || (c == '_')) {
    self.advance()
} else {
    break;
}
}
};
    }
}
},
    None => {
}
}
},
    _ => {
}
};
    match self.current() {
    Some('e') | Some('E') => {
    is_float = true;
    self.advance();
    match self.current() {
    Some('+') | Some('-') => {
    self.advance()
},
    _ => {
}
};
    loop {
        match self.current() {
    None => {
    break;
},
    Some(c) => {
    if (is_digit(c) || (c == '_')) {
    self.advance()
} else {
    break;
}
}
};
    }
},
    _ => {
}
};
    let kind = if is_float {
    TokenKind::FloatLit
} else {
    TokenKind::IntLit
};
    self.make_token(kind, start);
}


pub fn scan_string(r#self: Lexer) -> Token {
    let start = self.pos;
    self.advance();
    loop {
        match self.current() {
    None => {
    break;
},
    Some('\"') => {
    self.advance();
    break;
},
    Some('\\') => {
    self.advance();
    match self.current() {
    Some('n') | Some('t') | Some('r') | Some('\\') | Some('\"') | Some('0') => {
    self.advance()
},
    Some(_) => {
    self.advance()
},
    None => {
    break;
}
}
},
    Some('\n') => {
    self.advance()
},
    Some(_) => {
    self.advance()
}
};
    }
    self.make_token(TokenKind::StringLit, start);
}


pub fn scan_token(r#self: Lexer) -> Option<Token> {
    self.skip_whitespace();
    match self.current() {
    None => None,
    Some(c) => {
    let start = self.pos;
    if (c == '-') {
    match self.peek(1) {
    Some('-') => {
    self.skip_line_comment();
    return self.scan_token();
},
    _ => {
}
}
};
    match c {
    '-' => {
    match self.peek(1) {
    Some('>') => {
    self.advance();
    self.advance();
    return Some(self.make_token(TokenKind::Arrow, start));
},
    _ => {
}
}
},
    '=' => {
    match self.peek(1) {
    Some('>') => {
    self.advance();
    self.advance();
    return Some(self.make_token(TokenKind::FatArrow, start));
},
    Some('=') => {
    self.advance();
    self.advance();
    return Some(self.make_token(TokenKind::Eq, start));
},
    _ => {
}
}
},
    '|' => {
    match self.peek(1) {
    Some('>') => {
    self.advance();
    self.advance();
    return Some(self.make_token(TokenKind::Pipe, start));
},
    Some(']') => {
    self.advance();
    self.advance();
    return Some(self.make_token(TokenKind::RIdiom, start));
},
    Some('|') => {
    self.advance();
    self.advance();
    return Some(self.make_token(TokenKind::Or, start));
},
    _ => {
}
}
},
    '>' => {
    match self.peek(1) {
    Some('>') => {
    self.advance();
    self.advance();
    return Some(self.make_token(TokenKind::Compose, start));
},
    Some('=') => {
    self.advance();
    self.advance();
    return Some(self.make_token(TokenKind::Ge, start));
},
    _ => {
}
}
},
    '<' => {
    match self.peek(1) {
    Some('|') => {
    self.advance();
    self.advance();
    return Some(self.make_token(TokenKind::Map, start));
},
    Some('=') => {
    self.advance();
    self.advance();
    return Some(self.make_token(TokenKind::Le, start));
},
    _ => {
}
}
},
    ':' => {
    match self.peek(1) {
    Some('=') => {
    self.advance();
    self.advance();
    return Some(self.make_token(TokenKind::Bind, start));
},
    _ => {
}
}
},
    '!' => {
    match self.peek(1) {
    Some('=') => {
    self.advance();
    self.advance();
    return Some(self.make_token(TokenKind::Ne, start));
},
    _ => {
}
}
},
    '&' => {
    match self.peek(1) {
    Some('&') => {
    self.advance();
    self.advance();
    return Some(self.make_token(TokenKind::And, start));
},
    _ => {
}
}
},
    '*' => {
    match self.peek(1) {
    Some('*') => {
    self.advance();
    self.advance();
    return Some(self.make_token(TokenKind::StarStar, start));
},
    _ => {
}
}
},
    '[' => {
    match self.peek(1) {
    Some('|') => {
    self.advance();
    self.advance();
    return Some(self.make_token(TokenKind::LIdiom, start));
},
    _ => {
}
}
},
    _ => {
}
};
    match c {
    '{' => {
    self.advance();
    Some(self.make_token(TokenKind::LBrace, start))
},
    '}' => {
    self.advance();
    Some(self.make_token(TokenKind::RBrace, start))
},
    '(' => {
    self.advance();
    Some(self.make_token(TokenKind::LParen, start))
},
    ')' => {
    self.advance();
    Some(self.make_token(TokenKind::RParen, start))
},
    '[' => {
    self.advance();
    Some(self.make_token(TokenKind::LBracket, start))
},
    ']' => {
    self.advance();
    Some(self.make_token(TokenKind::RBracket, start))
},
    ',' => {
    self.advance();
    Some(self.make_token(TokenKind::Comma, start))
},
    ':' => {
    self.advance();
    Some(self.make_token(TokenKind::Colon, start))
},
    ';' => {
    self.advance();
    Some(self.make_token(TokenKind::Semicolon, start))
},
    '.' => {
    self.advance();
    Some(self.make_token(TokenKind::Dot, start))
},
    '@' => {
    self.advance();
    Some(self.make_token(TokenKind::At, start))
},
    '+' => {
    self.advance();
    Some(self.make_token(TokenKind::Plus, start))
},
    '-' => {
    self.advance();
    Some(self.make_token(TokenKind::Minus, start))
},
    '*' => {
    self.advance();
    Some(self.make_token(TokenKind::Star, start))
},
    '/' => {
    self.advance();
    Some(self.make_token(TokenKind::Slash, start))
},
    '%' => {
    self.advance();
    Some(self.make_token(TokenKind::Percent, start))
},
    '^' => {
    self.advance();
    Some(self.make_token(TokenKind::Caret, start))
},
    '=' => {
    self.advance();
    Some(self.make_token(TokenKind::Assign, start))
},
    '<' => {
    self.advance();
    Some(self.make_token(TokenKind::Lt, start))
},
    '>' => {
    self.advance();
    Some(self.make_token(TokenKind::Gt, start))
},
    '!' => {
    self.advance();
    Some(self.make_token(TokenKind::Not, start))
},
    '|' => {
    self.advance();
    Some(self.make_token(TokenKind::Bar, start))
},
    '&' => {
    self.advance();
    Some(self.make_token(TokenKind::Ampersand, start))
},
    '?' => {
    self.advance();
    Some(self.make_token(TokenKind::Question, start))
},
    '#' => {
    self.advance();
    Some(self.make_token(TokenKind::Hash, start))
},
    '\'' => {
    self.advance();
    Some(self.make_token(TokenKind::Quote, start))
},
    '\"' => {
    Some(self.scan_string())
},
    _ => {
    if is_ident_start(c) {
    Some(self.scan_identifier())
} else { if is_digit(c) {
    Some(self.scan_number())
} else {
    self.advance();
    Some(self.make_token(TokenKind::Error, start))
} }
}
}
}
};
}


pub fn lex(source: String) -> Vec<Token> {
    let lexer = Lexer(source);
    loop {
        match lexer.scan_token() {
    None => {
    break;
},
    Some(token) => {
    lexer.tokens.push(token)
}
};
    }
    let eof = Token(TokenKind::Eof, "", Span(lexer.pos, lexer.pos, lexer.line, lexer.column));
    lexer.tokens.push(eof);
    lexer.tokens;
}


/// Tests skipped
#[derive(Debug, Clone)]
pub struct TestSkipped {
}

impl TestSkipped {
    pub fn new() -> Self {
        Self {
        }
    }
}


