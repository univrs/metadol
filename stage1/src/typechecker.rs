// Generated by dol-codegen from Metal DOL declarations
// Do not edit manually - regenerate from source .dol files

// Source: dol/typechecker.dol
/// The main entry point for type checking a DOL file.
/// Creates a fresh TypeChecker and returns all type errors found.
#[derive(Debug, Clone)]
pub struct TypeChecker {
    pub env: String,
    pub errors: String,
    pub var_counter: String,
}

impl TypeChecker {
    pub fn new(env: String, errors: String, var_counter: String) -> Self {
        Self {
            env,
            errors,
            var_counter,
        }
    }

    pub fn fresh_var() -> Type {
        let id = self.var_counter;
        self.var_counter = (self.var_counter + 1);
        return Type::Var(id, ("T" + id.to_string()));
    }

    pub fn check_file(file: DolFile) -> Vec<TypeError> {
        for decl in file.decls {
            self.register_decl(decl);
        }
        for decl in file.decls {
            self.check_decl(decl);
        }
        return self.errors;
    }

    pub fn register_decl(decl: Decl) {
        match decl {
    GeneDecl(gene) => {
    let gene_type = Type::Gene(gene.name, gene.type_params);
    self.env.define(gene.name, gene_type)
},
    TraitDecl(trait_decl) => {
    let trait_type = Type::Trait(trait_decl.name, trait_decl.type_params);
    self.env.define(trait_decl.name, trait_type)
},
    FunctionDecl(func) => {
    let func_type = self.function_signature_type(func);
    self.env.define(func.name, func_type)
},
    SystemDecl(sys) => {
    let sys_type = Type::System(sys.name);
    self.env.define(sys.name, sys_type)
},
    ConstraintDecl(constraint) => {
    let constraint_type = Type::Constraint(constraint.name);
    self.env.define(constraint.name, constraint_type)
},
    _ => {
}
};
    }

    pub fn check_decl(decl: Decl) {
        match decl {
    GeneDecl(gene) => {
    self.check_gene(gene)
},
    TraitDecl(trait_decl) => {
    self.check_trait(trait_decl)
},
    FunctionDecl(func) => {
    self.check_function(func)
},
    SystemDecl(sys) => {
    self.check_system(sys)
},
    ConstraintDecl(constraint) => {
    self.check_constraint(constraint)
},
    UseDecl(_) => {
},
    ModuleDecl(_) => {
}
};
    }

    pub fn check_gene(gene: GeneDecl) {
        let saved_env = self.env.clone();
        for param in gene.type_params {
            self.env.define(param.name, Type::Param(param.name, param.bound));
        }
        for field in gene.fields {
            let field_type = self.resolve_type(field.ty);
            if (field.default != None) {
    let default_type = self.infer_expr(field.default.unwrap());
    self.unify(field_type, default_type, field.span)
};
            self.env.define(field.name, field_type);
        }
        for method in gene.methods {
            self.check_function(method);
        }
        self.env = saved_env;
    }

    pub fn check_trait(trait_decl: TraitDecl) {
        let saved_env = self.env.clone();
        for param in trait_decl.type_params {
            self.env.define(param.name, Type::Param(param.name, param.bound));
        }
        for method in trait_decl.methods {
            self.check_function(method);
        }
        self.env = saved_env;
    }

    pub fn check_function(func: FunctionDecl) {
        let saved_env = self.env.clone();
        for param in func.type_params {
            self.env.define(param.name, Type::Param(param.name, param.bound));
        }
        for param in func.params {
            let param_type = self.resolve_type(param.ty);
            self.env.define(param.name, param_type);
        }
        let return_type = if (func.return_ty != None) {
    self.resolve_type(func.return_ty.unwrap())
} else {
    Type::Unit
};
        if (func.body != None) {
    self.check_block(func.body.unwrap(), return_type)
};
        self.env = saved_env;
    }

    pub fn check_system(sys: SystemDecl) {
        let saved_env = self.env.clone();
        for component in sys.components {
            self.check_decl(component);
        }
        self.env = saved_env;
    }

    pub fn check_constraint(constraint: ConstraintDecl) {
        for pred in constraint.predicates {
            self.check_predicate(pred);
        }
    }

    pub fn check_expr(expr: Expr, expected: Type) -> Type {
        match expr {
    Lambda(params, body, span) => {
    match expected {
    Type::Function(param_types, return_type) => {
    if (params.length() != param_types.length()) {
    self.errors.push(TypeError(("Lambda has " + (params.length().to_string() + (" parameters, expected " + param_types.length().to_string()))), span));
    return expected;
};
    let saved_env = self.env.clone();
    for i in (0 .. params.length()) {
        self.env.define(params(i).name, param_types(i));
    }
    self.check_expr(body, return_type.deref());
    self.env = saved_env;
    return expected;
},
    _ => {
    let inferred = self.infer_expr(expr);
    self.unify(expected, inferred, span);
    return inferred;
}
}
},
    If(cond, then_branch, else_branch, span) => {
    self.check_expr(cond, Type::Bool);
    self.check_block(then_branch, expected);
    if (else_branch != None) {
    self.check_block(else_branch.unwrap(), expected)
};
    return expected;
},
    Match(scrutinee, arms, span) => {
    let scrutinee_type = self.infer_expr(scrutinee);
    for arm in arms {
        self.check_pattern(arm.pattern, scrutinee_type);
        self.check_expr(arm.body, expected);
    }
    return expected;
},
    _ => {
    let inferred = self.infer_expr(expr);
    self.unify(expected, inferred, self.expr_span(expr));
    return inferred;
}
};
    }

    pub fn infer_expr(expr: Expr) -> Type {
        match expr {
    IntLit(_, span) => {
    return Type::Int64;
},
    FloatLit(_, span) => {
    return Type::Float64;
},
    StringLit(_, span) => {
    return Type::String;
},
    BoolLit(_, span) => {
    return Type::Bool;
},
    Ident(name, span) => {
    match self.env.lookup(name) {
    Some(ty) => {
    return ty;
},
    None => {
    self.errors.push(TypeError(("Undefined variable: " + name), span));
    return Type::Error;
}
}
},
    Binary(op, left, right, span) => {
    return self.infer_binary(op, left, right, span);
},
    Unary(op, operand, span) => {
    let operand_type = self.infer_expr(operand.deref());
    match op {
    UnaryOp.Neg => {
    if !self.is_numeric(operand_type) {
    self.errors.push(TypeError("Cannot negate non-numeric type", span))
};
    return operand_type;
},
    UnaryOp.Not => {
    self.unify(operand_type, Type::Bool, span);
    return Type::Bool;
},
    _ => {
    return operand_type;
}
}
},
    Call(callee, args, span) => {
    let callee_type = self.infer_expr(callee.deref());
    match callee_type {
    Type::Function(param_types, return_type) => {
    if (args.length() != param_types.length()) {
    self.errors.push(TypeError(("Expected " + (param_types.length().to_string() + (" arguments, got " + args.length().to_string()))), span))
} else {
    for i in (0 .. args.length()) {
        self.check_expr(args(i), param_types(i));
    }
};
    return return_type.deref();
},
    Type::Var(_) => {
    let arg_types = args.map(|arg| { self.infer_expr(arg) });
    let return_var = self.fresh_var();
    let func_type = Type::Function(arg_types, Box::new(return_var));
    self.unify(callee_type, func_type, span);
    return return_var;
},
    _ => {
    self.errors.push(TypeError("Cannot call non-function type", span));
    return Type::Error;
}
}
},
    Lambda(params, body, span) => {
    let saved_env = self.env.clone();
    let param_types = vec![];
    for param in params {
        let param_type = if (param.ty != None) {
    self.resolve_type(param.ty.unwrap())
} else {
    self.fresh_var()
};
        self.env.define(param.name, param_type);
        param_types.push(param_type);
    }
    let body_type = self.infer_expr(body.deref());
    self.env = saved_env;
    return Type::Function(param_types, Box::new(body_type));
},
    If(cond, then_branch, else_branch, span) => {
    self.check_expr(cond, Type::Bool);
    let then_type = self.infer_block(then_branch);
    if (else_branch != None) {
    let else_type = self.infer_block(else_branch.unwrap());
    self.unify(then_type, else_type, span)
};
    return then_type;
},
    Match(scrutinee, arms, span) => {
    let scrutinee_type = self.infer_expr(scrutinee.deref());
    if (arms.length() == 0) {
    self.errors.push(TypeError("Match expression requires at least one arm", span));
    return Type::Error;
};
    let result_type = None;
    for arm in arms {
        self.check_pattern(arm.pattern, scrutinee_type);
        let arm_type = self.infer_expr(arm.body);
        if (result_type == None) {
    result_type = Some(arm_type);
} else {
    self.unify(result_type.unwrap(), arm_type, arm.span)
};
    }
    return result_type.unwrap_or(Type::Unit);
},
    Block(block, span) => {
    return self.infer_block(block);
},
    FieldAccess(object, field, span) => {
    let object_type = self.infer_expr(object.deref());
    match object_type {
    Type::Gene(name, _) => {
    match self.env.lookup_field(name, field) {
    Some(field_type) => {
    return field_type;
},
    None => {
    self.errors.push(TypeError(("Unknown field: " + (field + (" on type " + name))), span));
    return Type::Error;
}
}
},
    _ => {
    self.errors.push(TypeError("Cannot access field on non-gene type", span));
    return Type::Error;
}
}
},
    Index(array, index, span) => {
    let array_type = self.infer_expr(array.deref());
    let index_type = self.infer_expr(index.deref());
    self.unify(index_type, Type::Int64, span);
    match array_type {
    Type::List(elem_type) => {
    return elem_type.deref();
},
    Type::Array(elem_type, _) => {
    return elem_type.deref();
},
    _ => {
    self.errors.push(TypeError("Cannot index non-array type", span));
    return Type::Error;
}
}
},
    GeneInit(name, fields, span) => {
    match self.env.lookup(name) {
    Some(Type::Gene(gene_name, type_params)) => {
    for field in fields {
        match self.env.lookup_field(gene_name, field.name) {
    Some(expected_type) => {
    self.check_expr(field.value, expected_type)
},
    None => {
    self.errors.push(TypeError(("Unknown field: " + field.name), field.span))
}
};
    }
    return Type::Gene(gene_name, type_params);
},
    _ => {
    self.errors.push(TypeError(("Unknown gene: " + name), span));
    return Type::Error;
}
}
},
    ListLit(elements, span) => {
    if (elements.length() == 0) {
    let elem_var = self.fresh_var();
    return Type::List(Box::new(elem_var));
};
    let elem_type = self.infer_expr(elements(0));
    for i in (1 .. elements.length()) {
        let t = self.infer_expr(elements(i));
        self.unify(elem_type, t, span);
    }
    return Type::List(Box::new(elem_type));
},
    TupleLit(elements, span) => {
    let types = elements.map(|e| { self.infer_expr(e) });
    return Type::Tuple(types);
},
    MethodCall(receiver, method, args, span) => {
    let receiver_type = self.infer_expr(receiver.deref());
    match self.env.lookup_method(receiver_type, method) {
    Some(method_type) => {
    match method_type {
    Type::Function(param_types, return_type) => {
    let expected_args = param_types.slice(1);
    if (args.length() != expected_args.length()) {
    self.errors.push(TypeError(("Wrong number of arguments for method " + method), span))
};
    for i in (0 .. args.length()) {
        if (i < expected_args.length()) {
    self.check_expr(args(i), expected_args(i))
};
    }
    return return_type.deref();
},
    _ => {
    return Type::Error;
}
}
},
    None => {
    self.errors.push(TypeError(("Unknown method: " + method), span));
    return Type::Error;
}
}
},
    Quote(inner, span) => {
    return Type::Quoted(Box::new(self.infer_expr(inner.deref())));
},
    Eval(inner, span) => {
    let inner_type = self.infer_expr(inner.deref());
    match inner_type {
    Type::Quoted(inner_quoted_type) => {
    return inner_quoted_type.deref();
},
    _ => {
    self.errors.push(TypeError("Can only eval quoted expressions", span));
    return Type::Error;
}
}
},
    Reflect(inner, span) => {
    let _ = self.infer_expr(inner.deref());
    return Type::TypeInfo;
},
    Range(start, end, inclusive, span) => {
    let start_type = self.infer_expr(start.deref());
    let end_type = self.infer_expr(end.deref());
    self.unify(start_type, Type::Int64, span);
    self.unify(end_type, Type::Int64, span);
    return Type::Range;
},
    This(span) => {
    match self.env.lookup("this") {
    Some(ty) => {
    return ty;
},
    None => {
    self.errors.push(TypeError("'this' used outside of method context", span));
    return Type::Error;
}
}
},
    Return(value, span) => {
    if (value != None) {
    let _ = self.infer_expr(value.unwrap());
};
    return Type::Never;
},
    Break(span) => {
    return Type::Never;
},
    Continue(span) => {
    return Type::Never;
},
    _ => {
    return Type::Error;
}
};
    }

    pub fn infer_binary(op: BinOp, left: Box<Expr>, right: Box<Expr>, span: Span) -> Type {
        let left_type = self.infer_expr(left.deref());
        let right_type = self.infer_expr(right.deref());
        match op {
    BinOp.Add | BinOp.Sub | BinOp.Mul | BinOp.Div | BinOp.Mod | BinOp.Pow => {
    return self.check_numeric(left_type, right_type, span);
},
    BinOp.Eq | BinOp.Ne => {
    self.check_same(left_type, right_type, span);
    return Type::Bool;
},
    BinOp.Lt | BinOp.Le | BinOp.Gt | BinOp.Ge => {
    if (!self.is_comparable(left_type) || !self.is_comparable(right_type)) {
    self.errors.push(TypeError("Types are not comparable", span))
};
    self.check_same(left_type, right_type, span);
    return Type::Bool;
},
    BinOp.And | BinOp.Or => {
    self.unify(left_type, Type::Bool, span);
    self.unify(right_type, Type::Bool, span);
    return Type::Bool;
},
    BinOp.Pipe => {
    match right_type {
    Type::Function(param_types, return_type) => {
    if (param_types.length() >= 1) {
    self.unify(left_type, param_types(0), span);
    return return_type.deref();
};
    self.errors.push(TypeError("Pipe target must accept at least one argument", span));
    return Type::Error;
},
    _ => {
    self.errors.push(TypeError("Pipe target must be a function", span));
    return Type::Error;
}
}
},
    BinOp.Compose => {
    match (left_type, right_type) {
    (Type::Function(l_params, l_return), Type::Function(r_params, r_return)) => {
    if (r_params.length() >= 1) {
    self.unify(l_return.deref(), r_params(0), span);
    return Type::Function(l_params, r_return);
};
    self.errors.push(TypeError("Cannot compose: second function needs at least one parameter", span));
    return Type::Error;
},
    _ => {
    self.errors.push(TypeError("Compose operator requires two functions", span));
    return Type::Error;
}
}
},
    BinOp.Concat => {
    self.unify(left_type, Type::String, span);
    self.unify(right_type, Type::String, span);
    return Type::String;
},
    _ => {
    self.errors.push(TypeError("Unknown binary operator", span));
    return Type::Error;
}
};
    }

    pub fn check_numeric(left: Type, right: Type, span: Span) -> Type {
        if !self.is_numeric(left) {
    self.errors.push(TypeError("Left operand must be numeric", span));
    return Type::Error;
};
        if !self.is_numeric(right) {
    self.errors.push(TypeError("Right operand must be numeric", span));
    return Type::Error;
};
        match (left, right) {
    (Type.Float64, _) => {
    return Type::Float64;
},
    (_, Type.Float64) => {
    return Type::Float64;
},
    (Type.Float32, _) => {
    return Type::Float32;
},
    (_, Type.Float32) => {
    return Type::Float32;
},
    _ => {
    self.unify(left, right, span);
    return left;
}
};
    }

    pub fn is_numeric(ty: Type) -> bool {
        match ty {
    Type.Int8 => {
    return true;
},
    Type.Int16 => {
    return true;
},
    Type.Int32 => {
    return true;
},
    Type.Int64 => {
    return true;
},
    Type.UInt8 => {
    return true;
},
    Type.UInt16 => {
    return true;
},
    Type.UInt32 => {
    return true;
},
    Type.UInt64 => {
    return true;
},
    Type.Float32 => {
    return true;
},
    Type.Float64 => {
    return true;
},
    Type::Var(_) => {
    return true;
},
    _ => {
    return false;
}
};
    }

    pub fn is_comparable(ty: Type) -> bool {
        match ty {
    Type.Int8 => {
    return true;
},
    Type.Int16 => {
    return true;
},
    Type.Int32 => {
    return true;
},
    Type.Int64 => {
    return true;
},
    Type.UInt8 => {
    return true;
},
    Type.UInt16 => {
    return true;
},
    Type.UInt32 => {
    return true;
},
    Type.UInt64 => {
    return true;
},
    Type.Float32 => {
    return true;
},
    Type.Float64 => {
    return true;
},
    Type.String => {
    return true;
},
    Type.Char => {
    return true;
},
    Type::Var(_) => {
    return true;
},
    _ => {
    return false;
}
};
    }

    pub fn check_same(left: Type, right: Type, span: Span) {
        self.unify(left, right, span);
    }

    pub fn unify(a: Type, b: Type, span: Span) {
        let a_resolved = self.env.resolve(a);
        let b_resolved = self.env.resolve(b);
        match (a_resolved, b_resolved) {
    _ if (a_resolved == b_resolved) => {
    return;
},
    (Type::Var(id_a), _) => {
    if self.occurs_in(id_a, b_resolved) {
    self.errors.push(TypeError("Infinite type detected", span));
    return;
};
    self.env.bind_var(id_a, b_resolved)
},
    (_, Type::Var(id_b)) => {
    if self.occurs_in(id_b, a_resolved) {
    self.errors.push(TypeError("Infinite type detected", span));
    return;
};
    self.env.bind_var(id_b, a_resolved)
},
    (Type::Function(params_a, ret_a), Type::Function(params_b, ret_b)) => {
    if (params_a.length() != params_b.length()) {
    self.errors.push(TypeError("Function parameter count mismatch", span));
    return;
};
    for i in (0 .. params_a.length()) {
        self.unify(params_a(i), params_b(i), span);
    }
    self.unify(ret_a.deref(), ret_b.deref(), span)
},
    (Type::List(elem_a), Type::List(elem_b)) => {
    self.unify(elem_a.deref(), elem_b.deref(), span)
},
    (Type::Option(inner_a), Type::Option(inner_b)) => {
    self.unify(inner_a.deref(), inner_b.deref(), span)
},
    (Type::Result(ok_a, err_a), Type::Result(ok_b, err_b)) => {
    self.unify(ok_a.deref(), ok_b.deref(), span);
    self.unify(err_a.deref(), err_b.deref(), span)
},
    (Type::Tuple(elems_a), Type::Tuple(elems_b)) => {
    if (elems_a.length() != elems_b.length()) {
    self.errors.push(TypeError("Tuple length mismatch", span));
    return;
};
    for i in (0 .. elems_a.length()) {
        self.unify(elems_a(i), elems_b(i), span);
    }
},
    (Type::Gene(name_a, params_a), Type::Gene(name_b, params_b)) => {
    if (name_a != name_b) {
    self.errors.push(TypeError(("Type mismatch: expected " + (name_a + (", got " + name_b))), span));
    return;
};
    if (params_a.length() != params_b.length()) {
    self.errors.push(TypeError("Type parameter count mismatch", span));
    return;
};
    for i in (0 .. params_a.length()) {
        self.unify(params_a(i), params_b(i), span);
    }
},
    (Type::Quoted(inner_a), Type::Quoted(inner_b)) => {
    self.unify(inner_a.deref(), inner_b.deref(), span)
},
    (Type.Error, _) => {
    return;
},
    (_, Type.Error) => {
    return;
},
    (Type.Never, _) => {
    return;
},
    (_, Type.Never) => {
    return;
},
    _ => {
    self.errors.push(TypeError(("Type mismatch: expected " + (a_resolved.to_string() + (", got " + b_resolved.to_string()))), span))
}
};
    }

    pub fn occurs_in(var_id: u64, ty: Type) -> bool {
        match ty {
    Type::Var(id) => {
    return (id == var_id);
},
    Type::Function(params, ret) => {
    for param in params {
        if self.occurs_in(var_id, param) {
    return true;
};
    }
    return self.occurs_in(var_id, ret.deref());
},
    Type::List(elem) => {
    return self.occurs_in(var_id, elem.deref());
},
    Type::Option(inner) => {
    return self.occurs_in(var_id, inner.deref());
},
    Type::Result(ok, err) => {
    return (self.occurs_in(var_id, ok.deref()) || self.occurs_in(var_id, err.deref()));
},
    Type::Tuple(elems) => {
    for elem in elems {
        if self.occurs_in(var_id, elem) {
    return true;
};
    }
    return false;
},
    Type::Gene(_, params) => {
    for param in params {
        if self.occurs_in(var_id, param) {
    return true;
};
    }
    return false;
},
    Type::Quoted(inner) => {
    return self.occurs_in(var_id, inner.deref());
},
    _ => {
    return false;
}
};
    }

    pub fn resolve_type(ty: TypeExpr) -> Type {
        match ty {
    TypeExpr::Named(name, args, span) => {
    match name {
    "Int8" => {
    return Type::Int8;
},
    "Int16" => {
    return Type::Int16;
},
    "Int32" => {
    return Type::Int32;
},
    "Int64" => {
    return Type::Int64;
},
    "UInt8" => {
    return Type::UInt8;
},
    "UInt16" => {
    return Type::UInt16;
},
    "UInt32" => {
    return Type::UInt32;
},
    "UInt64" => {
    return Type::UInt64;
},
    "Float32" => {
    return Type::Float32;
},
    "Float64" => {
    return Type::Float64;
},
    "Bool" => {
    return Type::Bool;
},
    "String" => {
    return Type::String;
},
    "Char" => {
    return Type::Char;
},
    "Unit" => {
    return Type::Unit;
},
    "Never" => {
    return Type::Never;
},
    "List" => {
    if (args.length() != 1) {
    self.errors.push(TypeError("List requires exactly one type argument", span));
    return Type::Error;
};
    return Type::List(Box::new(self.resolve_type(args(0))));
},
    "Option" => {
    if (args.length() != 1) {
    self.errors.push(TypeError("Option requires exactly one type argument", span));
    return Type::Error;
};
    return Type::Option(Box::new(self.resolve_type(args(0))));
},
    "Result" => {
    if (args.length() != 2) {
    self.errors.push(TypeError("Result requires exactly two type arguments", span));
    return Type::Error;
};
    return Type::Result(Box::new(self.resolve_type(args(0))), Box::new(self.resolve_type(args(1))));
},
    "Box" => {
    if (args.length() != 1) {
    self.errors.push(TypeError("Box requires exactly one type argument", span));
    return Type::Error;
};
    return Type::Box(Box::new(self.resolve_type(args(0))));
},
    _ => {
    match self.env.lookup(name) {
    Some(ty) => {
    match ty {
    Type::Gene(gene_name, _) => {
    let resolved_args = args.map(|a| { self.resolve_type(a) });
    return Type::Gene(gene_name, resolved_args);
},
    Type::Param(param_name, _) => {
    return ty;
},
    _ => {
    return ty;
}
}
},
    None => {
    self.errors.push(TypeError(("Unknown type: " + name), span));
    return Type::Error;
}
}
}
}
},
    TypeExpr::Function(params, ret, span) => {
    let param_types = params.map(|p| { self.resolve_type(p) });
    let ret_type = self.resolve_type(ret.deref());
    return Type::Function(param_types, Box::new(ret_type));
},
    TypeExpr::Tuple(elems, span) => {
    let elem_types = elems.map(|e| { self.resolve_type(e) });
    return Type::Tuple(elem_types);
},
    TypeExpr::Array(elem, size, span) => {
    let elem_type = self.resolve_type(elem.deref());
    return Type::Array(Box::new(elem_type), size);
},
    TypeExpr::Inferred(span) => {
    return self.fresh_var();
}
};
    }

    pub fn infer_block(block: Block) -> Type {
        let saved_env = self.env.clone();
        for stmt in block.stmts {
            self.check_stmt(stmt);
        }
        let result_type = if (block.expr != None) {
    self.infer_expr(block.expr.unwrap())
} else {
    Type::Unit
};
        self.env = saved_env;
        return result_type;
    }

    pub fn check_block(block: Block, expected: Type) {
        let saved_env = self.env.clone();
        for stmt in block.stmts {
            self.check_stmt(stmt);
        }
        if (block.expr != None) {
    self.check_expr(block.expr.unwrap(), expected)
} else {
    self.unify(Type::Unit, expected, block.span)
};
        self.env = saved_env;
    }

    pub fn check_stmt(stmt: Stmt) {
        match stmt {
    Stmt::Let(name, ty, init, span) => {
    let var_type = if (ty != None) {
    let declared_type = self.resolve_type(ty.unwrap());
    if (init != None) {
    self.check_expr(init.unwrap(), declared_type)
};
    declared_type
} else { if (init != None) {
    self.infer_expr(init.unwrap())
} else {
    self.errors.push(TypeError("Variable must have either a type annotation or initializer", span));
    Type::Error
} };
    self.env.define(name, var_type)
},
    Stmt::Var(name, ty, init, span) => {
    let var_type = if (ty != None) {
    let declared_type = self.resolve_type(ty.unwrap());
    if (init != None) {
    self.check_expr(init.unwrap(), declared_type)
};
    declared_type
} else { if (init != None) {
    self.infer_expr(init.unwrap())
} else {
    self.errors.push(TypeError("Variable must have either a type annotation or initializer", span));
    Type::Error
} };
    self.env.define(name, var_type)
},
    Stmt::Assign(target, value, span) => {
    let target_type = self.infer_expr(target);
    self.check_expr(value, target_type)
},
    Stmt::Expr(expr, span) => {
    let _ = self.infer_expr(expr);
},
    Stmt::Return(value, span) => {
    if (value != None) {
    let _ = self.infer_expr(value.unwrap());
}
},
    Stmt::If(cond, then_branch, else_branch, span) => {
    self.check_expr(cond, Type::Bool);
    self.check_block(then_branch, Type::Unit);
    if (else_branch != None) {
    self.check_block(else_branch.unwrap(), Type::Unit)
}
},
    Stmt::While(cond, body, span) => {
    self.check_expr(cond, Type::Bool);
    self.check_block(body, Type::Unit)
},
    Stmt::For(var_name, iter, body, span) => {
    let iter_type = self.infer_expr(iter);
    let elem_type = match iter_type {
    Type::List(elem) => {
    elem.deref()
},
    Type.Range => {
    Type::Int64
},
    _ => {
    self.errors.push(TypeError("For loop requires an iterable", span));
    Type::Error
}
};
    let saved_env = self.env.clone();
    self.env.define(var_name, elem_type);
    self.check_block(body, Type::Unit);
    self.env = saved_env;
},
    Stmt::Loop(body, span) => {
    self.check_block(body, Type::Unit)
},
    Stmt::Break(span) => {
},
    Stmt::Continue(span) => {
},
    Stmt::Match(scrutinee, arms, span) => {
    let scrutinee_type = self.infer_expr(scrutinee);
    for arm in arms {
        self.check_pattern(arm.pattern, scrutinee_type);
        self.check_block(arm.body, Type::Unit);
    }
}
};
    }

    pub fn check_pattern(pattern: Pattern, expected: Type) {
        match pattern {
    Pattern::Wildcard(span) => {
},
    Pattern::Ident(name, span) => {
    self.env.define(name, expected)
},
    Pattern::Literal(lit, span) => {
    let lit_type = self.infer_expr(lit);
    self.unify(expected, lit_type, span)
},
    Pattern::Tuple(patterns, span) => {
    match expected {
    Type::Tuple(types) => {
    if (patterns.length() != types.length()) {
    self.errors.push(TypeError("Tuple pattern length mismatch", span));
    return;
};
    for i in (0 .. patterns.length()) {
        self.check_pattern(patterns(i), types(i));
    }
},
    _ => {
    self.errors.push(TypeError("Expected tuple type for tuple pattern", span))
}
}
},
    Pattern::Gene(name, fields, span) => {
    match expected {
    Type::Gene(gene_name, _) => {
    if (name != gene_name) {
    self.errors.push(TypeError("Pattern gene type mismatch", span));
    return;
};
    for field in fields {
        match self.env.lookup_field(gene_name, field.name) {
    Some(field_type) => {
    self.check_pattern(field.pattern, field_type)
},
    None => {
    self.errors.push(TypeError(("Unknown field in pattern: " + field.name), field.span))
}
};
    }
},
    _ => {
    self.errors.push(TypeError("Expected gene type for gene pattern", span))
}
}
},
    Pattern::Enum(variant, inner, span) => {
    match expected {
    Type::Option(inner_type) => {
    match variant {
    "Some" => {
    if (inner != None) {
    self.check_pattern(inner.unwrap(), inner_type.deref())
}
},
    "None" => {
},
    _ => {
    self.errors.push(TypeError(("Unknown Option variant: " + variant), span))
}
}
},
    Type::Result(ok_type, err_type) => {
    match variant {
    "Ok" => {
    if (inner != None) {
    self.check_pattern(inner.unwrap(), ok_type.deref())
}
},
    "Err" => {
    if (inner != None) {
    self.check_pattern(inner.unwrap(), err_type.deref())
}
},
    _ => {
    self.errors.push(TypeError(("Unknown Result variant: " + variant), span))
}
}
},
    _ => {
    self.errors.push(TypeError("Enum pattern requires enum type", span))
}
}
},
    Pattern::Or(patterns, span) => {
    for p in patterns {
        self.check_pattern(p, expected);
    }
},
    Pattern::Guard(inner, guard, span) => {
    self.check_pattern(inner.deref(), expected);
    self.check_expr(guard, Type::Bool)
}
};
    }

    pub fn check_predicate(pred: Predicate) {
        match pred {
    Predicate::Has(subject, property, ty, span) => {
    if (ty != None) {
    let _ = self.resolve_type(ty.unwrap());
}
},
    Predicate::Is(subject, trait_name, span) => {
    match self.env.lookup(trait_name) {
    Some(Type::Trait(_, _)) => {
},
    None => {
    self.errors.push(TypeError(("Unknown trait: " + trait_name), span))
},
    _ => {
    self.errors.push(TypeError((trait_name + " is not a trait"), span))
}
}
},
    Predicate::Requires(expr, span) => {
    self.check_expr(expr, Type::Bool)
},
    Predicate::Ensures(expr, span) => {
    self.check_expr(expr, Type::Bool)
},
    Predicate::Invariant(expr, span) => {
    self.check_expr(expr, Type::Bool)
},
    Predicate::Law(name, expr, span) => {
    self.check_expr(expr, Type::Bool)
}
};
    }

    pub fn expr_span(expr: Expr) -> Span {
        match expr {
    IntLit(_, span) => {
    return span;
},
    FloatLit(_, span) => {
    return span;
},
    StringLit(_, span) => {
    return span;
},
    BoolLit(_, span) => {
    return span;
},
    Ident(_, span) => {
    return span;
},
    Binary(_, _, _, span) => {
    return span;
},
    Unary(_, _, span) => {
    return span;
},
    Call(_, _, span) => {
    return span;
},
    Lambda(_, _, span) => {
    return span;
},
    If(_, _, _, span) => {
    return span;
},
    Match(_, _, span) => {
    return span;
},
    Block(_, span) => {
    return span;
},
    FieldAccess(_, _, span) => {
    return span;
},
    Index(_, _, span) => {
    return span;
},
    GeneInit(_, _, span) => {
    return span;
},
    ListLit(_, span) => {
    return span;
},
    TupleLit(_, span) => {
    return span;
},
    MethodCall(_, _, _, span) => {
    return span;
},
    Quote(_, span) => {
    return span;
},
    Eval(_, span) => {
    return span;
},
    Reflect(_, span) => {
    return span;
},
    Range(_, _, _, span) => {
    return span;
},
    This(span) => {
    return span;
},
    Return(_, span) => {
    return span;
},
    Break(span) => {
    return span;
},
    Continue(span) => {
    return span;
},
    _ => {
    return Span(0, 0, 0, 0);
}
};
    }

    pub fn function_signature_type(func: FunctionDecl) -> Type {
        let param_types = func.params.map(|p| { self.resolve_type(p.ty) });
        let return_type = if (func.return_ty != None) {
    self.resolve_type(func.return_ty.unwrap())
} else {
    Type::Unit
};
        return Type::Function(param_types, Box::new(return_type));
    }
}


pub fn typecheck(file: DolFile) -> Vec<TypeError> {
    let checker = TypeChecker(TypeEnv::new(), vec![], 0);
    return checker.check_file(file);
}


