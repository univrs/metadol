// Generated by dol-codegen from Metal DOL declarations
// Do not edit manually - regenerate from source .dol files

// Source: dol/types.dol
/// Utility functions for type classification and comparison.
#[derive(Debug, Clone)]
pub struct Type {
    pub r#type: String,
}

impl Type {
    pub fn new(r#type: String) -> Self {
        Self {
            r#type,
        }
    }
}


pub fn is_primitive(ty: Type) -> bool {
    match ty {
    Int8 => {
    return true;
},
    Int16 => {
    return true;
},
    Int32 => {
    return true;
},
    Int64 => {
    return true;
},
    UInt8 => {
    return true;
},
    UInt16 => {
    return true;
},
    UInt32 => {
    return true;
},
    UInt64 => {
    return true;
},
    Float32 => {
    return true;
},
    Float64 => {
    return true;
},
    Bool => {
    return true;
},
    String => {
    return true;
},
    Void => {
    return true;
},
    _ => {
    return false;
}
};
}


pub fn is_numeric(ty: Type) -> bool {
    match ty {
    Int8 => {
    return true;
},
    Int16 => {
    return true;
},
    Int32 => {
    return true;
},
    Int64 => {
    return true;
},
    UInt8 => {
    return true;
},
    UInt16 => {
    return true;
},
    UInt32 => {
    return true;
},
    UInt64 => {
    return true;
},
    Float32 => {
    return true;
},
    Float64 => {
    return true;
},
    _ => {
    return false;
}
};
}


pub fn is_integer(ty: Type) -> bool {
    match ty {
    Int8 => {
    return true;
},
    Int16 => {
    return true;
},
    Int32 => {
    return true;
},
    Int64 => {
    return true;
},
    UInt8 => {
    return true;
},
    UInt16 => {
    return true;
},
    UInt32 => {
    return true;
},
    UInt64 => {
    return true;
},
    _ => {
    return false;
}
};
}


pub fn is_float(ty: Type) -> bool {
    match ty {
    Float32 => {
    return true;
},
    Float64 => {
    return true;
},
    _ => {
    return false;
}
};
}


pub fn has_inference_vars(ty: Type) -> bool {
    match ty {
    Var => {
    return true;
},
    Unknown => {
    return true;
},
    Function(params, ret) => {
    for param in params {
        if has_inference_vars(param) {
    return true;
};
    }
    return has_inference_vars(*ret);
},
    Tuple(elements) => {
    for elem in elements {
        if has_inference_vars(elem) {
    return true;
};
    }
    return false;
},
    Generic(name, args) => {
    for arg in args {
        if has_inference_vars(arg) {
    return true;
};
    }
    return false;
},
    _ => {
    return false;
}
};
}


#[derive(Debug, Clone)]
pub struct TypeEnv {
    pub bindings: String,
    pub parent: String,
}

impl TypeEnv {
    pub fn new(bindings: String, parent: String) -> Self {
        Self {
            bindings,
            parent,
        }
    }

    pub fn child() -> TypeEnv {
        return TypeEnv(Map::new(), Some(Box::new(self)));
    }

    pub fn bind(name: String, ty: Type) {
        self.bindings.insert(name, ty);
    }

    pub fn lookup(name: String) -> Option<Type> {
        match self.bindings.get(name) {
    Some(ty) => {
    return Some(ty);
},
    None => {
    match self.parent {
    Some(parent_env) => {
    return parent_env.lookup(name);
},
    None => {
    return None;
}
}
}
};
    }

    pub fn is_bound_locally(name: String) -> bool {
        return self.bindings.contains_key(name);
    }

    pub fn is_bound(name: String) -> bool {
        match self.lookup(name) {
    Some(_) => {
    return true;
},
    None => {
    return false;
}
};
    }
}


pub fn new_env() -> TypeEnv {
    return TypeEnv(Map::new(), None);
}


pub fn prelude_env() -> TypeEnv {
    let env = new_env();
    env.bind("Int8", Type::Int8);
    env.bind("Int16", Type::Int16);
    env.bind("Int32", Type::Int32);
    env.bind("Int64", Type::Int64);
    env.bind("UInt8", Type::UInt8);
    env.bind("UInt16", Type::UInt16);
    env.bind("UInt32", Type::UInt32);
    env.bind("UInt64", Type::UInt64);
    env.bind("Float32", Type::Float32);
    env.bind("Float64", Type::Float64);
    env.bind("Bool", Type::Bool);
    env.bind("String", Type::String);
    env.bind("Void", Type::Void);
    env.bind("Int", Type::Int32);
    env.bind("UInt", Type::UInt32);
    env.bind("Float", Type::Float64);
    return env;
}


#[derive(Debug, Clone)]
pub struct TypeError {
    pub message: String,
    pub span: String,
}

impl TypeError {
    pub fn new(message: String, span: String) -> Self {
        Self {
            message,
            span,
        }
    }

    pub fn new(message: String, span: Span) -> TypeError {
        return TypeError(message, span);
    }

    pub fn format() -> String {
        return ("TypeError at line " + (self.span.line.to_string() + (", column " + (self.span.column.to_string() + (": " + self.message)))));
    }
}


pub fn mismatch_error(expected: Type, found: Type, span: Span) -> TypeError {
    return TypeError(("Type mismatch: expected " + (type_to_string(expected) + (", found " + type_to_string(found)))), span);
}


pub fn undefined_error(name: String, span: Span) -> TypeError {
    return TypeError(("Undefined type: " + name), span);
}


pub fn arity_error(expected: u32, found: u32, span: Span) -> TypeError {
    return TypeError(("Wrong number of type arguments: expected " + (expected.to_string() + (", found " + found.to_string()))), span);
}


pub fn type_to_string(ty: Type) -> String {
    match ty {
    Int8 => {
    return "Int8";
},
    Int16 => {
    return "Int16";
},
    Int32 => {
    return "Int32";
},
    Int64 => {
    return "Int64";
},
    UInt8 => {
    return "UInt8";
},
    UInt16 => {
    return "UInt16";
},
    UInt32 => {
    return "UInt32";
},
    UInt64 => {
    return "UInt64";
},
    Float32 => {
    return "Float32";
},
    Float64 => {
    return "Float64";
},
    Bool => {
    return "Bool";
},
    String => {
    return "String";
},
    Void => {
    return "Void";
},
    Function(params, ret) => {
    let s = "(";
    for i in (0 .. params.len()) {
        if (i > 0) {
    s = (s + ", ");
};
        s = (s + type_to_string(params(i)));
    }
    s = (s + (") -> " + type_to_string(*ret)));
    return s;
},
    Tuple(elements) => {
    let s = "(";
    for i in (0 .. elements.len()) {
        if (i > 0) {
    s = (s + ", ");
};
        s = (s + type_to_string(elements(i)));
    }
    s = (s + ")");
    return s;
},
    Generic(name, args) => {
    let s = (name + "<");
    for i in (0 .. args.len()) {
        if (i > 0) {
    s = (s + ", ");
};
        s = (s + type_to_string(args(i)));
    }
    s = (s + ">");
    return s;
},
    Named(name) => {
    return name;
},
    Var(id) => {
    return ("?T" + id.to_string());
},
    Unknown => {
    return "?";
},
    Error => {
    return "<error>";
}
};
}


