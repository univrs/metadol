// ═══════════════════════════════════════════════════════════════
// Ecosystem - Population Dynamics and Trophic Levels
// ═══════════════════════════════════════════════════════════════

module biology.ecosystem @ 1.0.0

use biology.types.{ Energy, Nutrient, Generation }

/// Species role in ecosystem
pub gene TrophicRole {
  type: enum {
    Producer,                    // Autotrophs (plants, algae)
    PrimaryConsumer,             // Herbivores
    SecondaryConsumer,           // Carnivores eating herbivores
    TertiaryConsumer,            // Apex predators
    Decomposer                   // Fungi, bacteria
  }

  fun trophic_level() -> UInt8 {
    match this {
      Producer { return 1 }
      PrimaryConsumer { return 2 }
      SecondaryConsumer { return 3 }
      TertiaryConsumer { return 4 }
      Decomposer { return 0 }  // Special: recycles
    }
  }

  exegesis {
    Trophic role determines position in food web
    and energy transfer efficiency.
  }
}

/// Species in an ecosystem
pub gene Species {
  has id: UInt64
  has name: String
  has role: TrophicRole
  has population: UInt64
  has birth_rate: Float64
  has death_rate: Float64
  has carrying_capacity: UInt64

  constraint positive_rates {
    this.birth_rate >= 0.0 && this.death_rate >= 0.0
  }

  constraint population_non_negative {
    this.population >= 0
  }

  /// Logistic growth rate
  fun growth_rate() -> Float64 {
    r = this.birth_rate - this.death_rate
    k = this.carrying_capacity as Float64
    n = this.population as Float64
    return r * n * (1.0 - n / k)
  }

  exegesis {
    A species in the ecosystem with population dynamics.
    Growth follows logistic model with carrying capacity.
  }
}

/// Interaction between species
pub gene Interaction {
  has predator: UInt64  // species id
  has prey: UInt64      // species id
  has attack_rate: Float64
  has handling_time: Float64
  has conversion_efficiency: Float64

  constraint efficiency_bounds {
    this.conversion_efficiency > 0.0 &&
    this.conversion_efficiency <= 1.0
  }

  /// Holling Type II functional response
  fun predation_rate(prey_density: Float64) -> Float64 {
    return (this.attack_rate * prey_density) /
           (1.0 + this.attack_rate * this.handling_time * prey_density)
  }

  exegesis {
    Predator-prey interaction with Holling Type II
    functional response (includes handling time saturation).
  }
}

/// Full ecosystem state
pub system Ecosystem {
  uses Transport<Energy>
  uses Transport<Nutrient>

  state species: Map<UInt64, Species>
  state interactions: List<Interaction>
  state total_energy: Energy
  state nutrient_pool: Nutrient
  state generation: Generation

  // ─────────────────────────────────────────────────────────────
  // Ecological Constraints (Laws of Nature)
  // ─────────────────────────────────────────────────────────────

  constraint trophic_efficiency {
    // Energy transfer between trophic levels <= 10%
    for level in 1..4 {
      energy_at_level = this.energy_at_trophic_level(level)
      energy_at_next = this.energy_at_trophic_level(level + 1)

      energy_at_next <= energy_at_level * 0.15  // Allow up to 15%
    }

    exegesis {
      Lindeman's 10% law: only ~10% of energy
      transfers between trophic levels.
    }
  }

  constraint carrying_capacity_limit {
    // Total population limited by resources
    for sp in this.species.values() {
      sp.population <= sp.carrying_capacity * 1.1  // Allow 10% overshoot
    }

    exegesis {
      Carrying capacity limits population.
      Overshoot leads to population crash.
    }
  }

  constraint predator_prey_balance {
    // Lotka-Volterra inspired: predators need prey
    for interaction in this.interactions {
      predator = this.species.get(interaction.predator)
      prey = this.species.get(interaction.prey)

      // Predators decline if prey is scarce
      predator.population > 0 implies prey.population > 0
    }

    exegesis {
      Predators cannot persist without prey.
      Models predator-prey dependency.
    }
  }

  constraint decomposer_recycling {
    // Decomposers recycle nutrients back to producers
    decomposer_count = this.species.values()
      .filter(|s| s.role == TrophicRole.Decomposer)
      .map(|s| s.population)
      .sum()

    decomposer_count > 0 implies
      this.nutrient_pool.total_mass() > 0

    exegesis {
      Decomposers are essential for nutrient cycling.
      Without them, nutrients become locked in dead matter.
    }
  }

  // ─────────────────────────────────────────────────────────────
  // Ecosystem Functions
  // ─────────────────────────────────────────────────────────────

  /// Advance ecosystem by one time step (Lotka-Volterra)
  fun tick() -> Self {
    new_species = Map.new()

    for (id, sp) in this.species {
      // Calculate population change
      growth = sp.growth_rate()

      // Add predation effects
      predation_loss = 0.0
      predation_gain = 0.0

      for interaction in this.interactions {
        if interaction.prey == id {
          predator = this.species.get(interaction.predator)
          predation_loss += interaction.predation_rate(sp.population as Float64)
                            * predator.population as Float64
        }
        if interaction.predator == id {
          prey = this.species.get(interaction.prey)
          consumed = interaction.predation_rate(prey.population as Float64)
                     * sp.population as Float64
          predation_gain += consumed * interaction.conversion_efficiency
        }
      }

      // Update population
      delta = growth - predation_loss + predation_gain
      new_pop = max(0, (sp.population as Float64 + delta) as UInt64)

      new_species.insert(id, Species { ...sp, population: new_pop })
    }

    return Ecosystem {
      ...this,
      species: new_species,
      generation: this.generation.next()
    }
  }

  /// Calculate energy at a trophic level
  fun energy_at_trophic_level(level: UInt8) -> Float64 {
    return this.species.values()
      .filter(|s| s.role.trophic_level() == level)
      .map(|s| s.population as Float64 * 1.0)  // Energy per individual
      .sum()
  }

  /// Check if ecosystem is stable (attractor reached)
  fun is_stable(tolerance: Float64) -> Bool {
    // Run one tick and compare
    next = this.tick()

    for (id, sp) in this.species {
      next_sp = next.species.get(id)
      change = ((next_sp.population as Float64) - (sp.population as Float64)).abs()
      if change / (sp.population as Float64 + 1.0) > tolerance {
        return false
      }
    }

    return true
  }

  /// Add a keystone species (stabilizes ecosystem)
  fun add_keystone(species: Species) -> Self {
    // Keystone species have outsized effects
    return Ecosystem {
      ...this,
      species: this.species.insert(species.id, species)
    }
  }

  exegesis {
    Ecosystem models population dynamics using:
    - Lotka-Volterra predator-prey equations
    - Logistic growth with carrying capacity
    - Holling Type II functional response
    - Trophic energy transfer (10% rule)

    This is the foundation for modeling any system of
    interacting populations: biological, economic, social.
  }
}
