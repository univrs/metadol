module tests.nested_sex @ 1.0.0

// Global mutable state
sex var COUNTER: Int64 = 0
sex var LOG: List<String> = []
sex var CACHE: Map<String, Int64> = Map.new()

// Simple sex function
sex fun increment() -> Int64 {
    COUNTER += 1
    return COUNTER
}

// Sex function with sex block
sex fun logged_increment(label: String) -> Int64 {
    sex {
        LOG.push(label + ": incrementing")
    }

    result = COUNTER + 1
    COUNTER = result

    sex {
        LOG.push(label + ": now " + result.to_string())
    }

    return result
}

// Pure function with sex block
fun compute_with_logging(x: Int64) -> Int64 {
    result = x * 2 + 1

    sex {
        LOG.push("computed: " + result.to_string())
    }

    return result
}

// Nested sex blocks (should work but warn)
sex fun deeply_nested() -> Int64 {
    sex {
        COUNTER += 1
        sex {
            LOG.push("nested sex block")
        }
    }
    return COUNTER
}

// Sex with control flow
sex fun conditional_effects(cond: Bool) -> Int64 {
    if cond {
        sex {
            COUNTER += 10
        }
    } else {
        sex {
            COUNTER -= 10
        }
    }
    return COUNTER
}

// Sex with loops
sex fun loop_effects(n: Int64) -> Int64 {
    for i in 0..n {
        sex {
            COUNTER += 1
            LOG.push("iteration " + i.to_string())
        }
    }
    return COUNTER
}

// Extern declarations
sex extern "C" fun printf(fmt: Ptr<Int8>, ...) -> Int32
sex extern "C" fun malloc(size: UInt64) -> Ptr<Void>
sex extern "C" fun free(ptr: Ptr<Void>)

exegesis {
    Tests for various sex block patterns and nesting.
}
