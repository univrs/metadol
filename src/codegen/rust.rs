//! Rust code generation from Metal DOL declarations.
//!
//! Generates Rust structs, traits, and types from DOL declarations.
//!
//! # Type Mapping
//!
//! | DOL Type | Rust Type |
//! |----------|-----------|
//! | `Int8` | `i8` |
//! | `Int16` | `i16` |
//! | `Int32` | `i32` |
//! | `Int64` | `i64` |
//! | `UInt8` | `u8` |
//! | `UInt16` | `u16` |
//! | `UInt32` | `u32` |
//! | `UInt64` | `u64` |
//! | `Float32` | `f32` |
//! | `Float64` | `f64` |
//! | `String` | `String` |
//! | `Bool` | `bool` |
//! | `Option<T>` | `Option<T>` |
//! | `Result<T, E>` | `Result<T, E>` |
//! | `List<T>` | `Vec<T>` |
//! | `Map<K, V>` | `std::collections::HashMap<K, V>` |

use crate::ast::{
    Constraint, Declaration, EnumVariant, Evolution, Expr, ExternDecl, FunctionDecl, FunctionParam,
    Gene, Literal, Mutability, Statement, Stmt, System, Trait, TypeExpr, VarDecl,
};
use crate::typechecker::Type;

use super::{
    to_pascal_case, to_rust_ident, to_snake_case, Codegen, CodegenOptions, TypeMapper, Visibility,
};

/// Rust code generator.
///
/// Transforms DOL declarations into Rust source code.
#[derive(Debug, Clone, Default)]
pub struct RustCodegen {
    options: CodegenOptions,
}

impl RustCodegen {
    /// Create a new Rust code generator with default options.
    pub fn new() -> Self {
        Self::default()
    }

    /// Create a new Rust code generator with custom options.
    pub fn with_options(options: CodegenOptions) -> Self {
        Self { options }
    }

    /// Generate Rust code from a declaration.
    pub fn generate(decl: &Declaration) -> String {
        Self::new().generate_declaration(decl)
    }

    /// Generate Rust code from multiple declarations.
    /// This handles self-functions by grouping them into impl blocks.
    pub fn generate_all(decls: &[Declaration]) -> String {
        let generator = Self::new();
        generator.gen_file(decls)
    }

    /// Generate a complete Rust file from multiple declarations.
    ///
    /// This creates a complete .rs file with:
    /// - Header comment with generation notice
    /// - Required imports based on used types
    /// - All declarations in order
    /// - Functions with self: Type parameters are grouped into impl blocks
    pub fn gen_file(&self, decls: &[Declaration]) -> String {
        let mut output = String::new();

        // Header comment
        output.push_str("// Generated by DOL compiler\n");
        output.push_str("// Do not edit manually\n\n");

        // Determine required imports
        let mut imports = std::collections::HashSet::new();
        for decl in decls {
            self.collect_imports(decl, &mut imports);
        }

        // Add imports
        if !imports.is_empty() {
            let mut sorted_imports: Vec<_> = imports.into_iter().collect();
            sorted_imports.sort();
            for import in sorted_imports {
                output.push_str(&import);
                output.push('\n');
            }
            output.push('\n');
        }

        // Collect self-functions and group by type
        let mut self_functions: std::collections::HashMap<String, Vec<&FunctionDecl>> =
            std::collections::HashMap::new();
        let mut regular_functions: Vec<&FunctionDecl> = Vec::new();

        for decl in decls {
            if let Declaration::Function(func) = decl {
                if let Some(self_type) = Self::get_self_type(func) {
                    self_functions.entry(self_type).or_default().push(func);
                } else {
                    regular_functions.push(func);
                }
            }
        }

        // Generate non-function declarations (genes, traits, etc.)
        for decl in decls {
            if !matches!(decl, Declaration::Function(_)) {
                output.push_str(&self.generate_declaration(decl));
                output.push_str("\n\n");
            }
        }

        // Generate regular functions (without self parameter)
        for func in regular_functions {
            output.push_str(&self.generate_toplevel_function(func));
            output.push_str("\n\n");
        }

        // Generate impl blocks for self-functions
        for (type_name, funcs) in self_functions {
            output.push_str(&format!("impl {} {{\n", type_name));
            for func in funcs {
                output.push_str(&self.generate_method_from_function(func));
                output.push('\n');
            }
            output.push_str("}\n\n");
        }

        output
    }

    /// Check if a function has a self parameter and return the self type name.
    fn get_self_type(func: &FunctionDecl) -> Option<String> {
        if let Some(first_param) = func.params.first() {
            if first_param.name == "self" || first_param.name == "self_" {
                if let TypeExpr::Named(type_name) = &first_param.type_ann {
                    return Some(to_pascal_case(type_name));
                }
            }
        }
        None
    }

    /// Generate a method from a function that has a self parameter.
    fn generate_method_from_function(&self, func: &FunctionDecl) -> String {
        let visibility = self.visibility_str();
        let mut output = String::new();

        // Add exegesis as doc comment
        if !func.exegesis.is_empty() {
            for line in func.exegesis.lines() {
                output.push_str(&format!("    /// {}\n", line.trim()));
            }
        }

        // Function signature - convert first param to &mut self
        output.push_str(&format!(
            "    {visibility}fn {}(&mut self",
            to_rust_ident(&func.name)
        ));

        // Generate remaining parameters (skip the first self param)
        for param in func.params.iter().skip(1) {
            let param_type = Self::map_type_expr(&param.type_ann);
            output.push_str(&format!(", {}: {}", to_rust_ident(&param.name), param_type));
        }
        output.push(')');

        // Return type
        if let Some(ret_ty) = &func.return_type {
            output.push_str(" -> ");
            output.push_str(&Self::map_type_expr(ret_ty));
        }

        output.push_str(" {\n");

        // Generate function body - replace self_ or self with self
        for stmt in &func.body {
            let stmt_code = self.gen_stmt(stmt, 2);
            // Replace self_ with self in the generated code
            let fixed_code = stmt_code
                .replace("self_.", "self.")
                .replace("self_", "self");
            output.push_str(&format!("{}\n", fixed_code));
        }

        output.push_str("    }\n");
        output
    }

    /// Generate import statements based on types used.
    pub fn gen_imports(&self, decls: &[Declaration]) -> String {
        let mut imports = std::collections::HashSet::new();
        for decl in decls {
            self.collect_imports(decl, &mut imports);
        }

        let mut sorted: Vec<_> = imports.into_iter().collect();
        sorted.sort();
        sorted.join("\n")
    }

    /// Collect required imports based on types used in declaration.
    fn collect_imports(&self, decl: &Declaration, imports: &mut std::collections::HashSet<String>) {
        // Check for HashMap usage
        if self.uses_hashmap(decl) {
            imports.insert("use std::collections::HashMap;".to_string());
        }
        // Add more import detection as needed
    }

    /// Check if declaration uses HashMap type.
    fn uses_hashmap(&self, decl: &Declaration) -> bool {
        let source = self.generate_declaration(decl);
        source.contains("std::collections::HashMap")
    }

    /// Generate code for a single declaration.
    fn generate_declaration(&self, decl: &Declaration) -> String {
        match decl {
            Declaration::Gene(gene) => self.generate_gene(gene),
            Declaration::Trait(trait_decl) => self.generate_trait(trait_decl),
            Declaration::Constraint(constraint) => self.generate_constraint(constraint),
            Declaration::System(system) => self.generate_system(system),
            Declaration::Evolution(evolution) => self.generate_evolution(evolution),
            Declaration::Function(func) => self.generate_toplevel_function(func),
            Declaration::Const(var) => self.generate_const(var),
        }
    }

    /// Generate a Rust constant declaration.
    fn generate_const(&self, var: &crate::ast::VarDecl) -> String {
        let visibility = self.visibility_str();
        let name = var.name.to_uppercase().replace('.', "_");
        let type_str = var
            .type_ann
            .as_ref()
            .map(|t| self.gen_type(t))
            .unwrap_or_else(|| "i64".to_string());
        let value = var
            .value
            .as_ref()
            .map(|e| self.gen_expr(e))
            .unwrap_or_else(|| "0".to_string());
        format!("{}const {}: {} = {};", visibility, name, type_str, value)
    }

    /// Generate a top-level Rust function from a function declaration.
    fn generate_toplevel_function(&self, func: &crate::ast::FunctionDecl) -> String {
        let visibility = self.visibility_str();
        let mut output = String::new();

        // Add exegesis as doc comment
        if !func.exegesis.is_empty() {
            for line in func.exegesis.lines() {
                output.push_str(&format!("/// {}\n", line.trim()));
            }
        }

        // Function signature
        output.push_str(&format!("{visibility}fn {}(", to_rust_ident(&func.name)));

        // Generate parameters
        let params_str: Vec<String> = func
            .params
            .iter()
            .map(|param| {
                let param_type = Self::map_type_expr(&param.type_ann);
                format!("{}: {}", to_rust_ident(&param.name), param_type)
            })
            .collect();
        output.push_str(&params_str.join(", "));
        output.push(')');

        // Return type
        if let Some(ret_ty) = &func.return_type {
            output.push_str(" -> ");
            output.push_str(&Self::map_type_expr(ret_ty));
        }

        output.push_str(" {\n");

        // Generate function body
        for stmt in &func.body {
            output.push_str(&self.gen_stmt(stmt, 1));
        }

        output.push_str("}\n");
        output
    }

    /// Generate a Rust struct from a gene declaration.
    fn generate_gene(&self, gene: &Gene) -> String {
        // Check if this gene has an inline enum 'type' field (DOL idiom for enums)
        // If so, generate as a flat enum with the gene's name
        if let Some((variants, extra_fields)) = Self::is_enum_gene(gene) {
            return self.gen_enum_from_gene(gene, variants, &extra_fields);
        }

        let struct_name = to_pascal_case(&gene.name);
        let visibility = self.visibility_str();

        let mut output = String::new();

        // Extract inline enums and generate them first
        let (inline_enums, fields) =
            self.extract_fields_with_inline_enums(&gene.statements, &struct_name);
        for enum_output in inline_enums {
            output.push_str(&enum_output);
            output.push_str("\n\n");
        }

        // Collect function declarations
        let functions = self.extract_functions(&gene.statements);

        // Doc comment from exegesis (always include by default)
        output.push_str(&self.format_doc_comment(&gene.exegesis));

        // Derive macros
        let derives = self.derive_clause();
        if !derives.is_empty() {
            output.push_str(&format!("#[derive({})]\n", derives));
        }

        // Struct definition
        output.push_str(&format!("{visibility}struct {struct_name} {{\n"));

        for (field_name, field_type, _, _) in &fields {
            let rust_field = to_rust_ident(field_name);
            output.push_str(&format!("    {visibility}{rust_field}: {field_type},\n"));
        }

        output.push_str("}\n\n");

        // Generate impl block with constructor, validators, and methods
        output.push_str(&self.gen_gene_impl(&struct_name, &fields, &functions));

        output
    }

    /// Generate a Rust trait from a trait declaration.
    fn generate_trait(&self, trait_decl: &Trait) -> String {
        let trait_name = to_pascal_case(&trait_decl.name);
        let visibility = self.visibility_str();

        // Collect supertraits from "uses" statements
        let supertraits = self.extract_supertraits(&trait_decl.statements);

        // Collect methods from "is" statements (state transitions become getters)
        let methods = self.extract_methods(&trait_decl.statements);

        let mut output = String::new();

        // Doc comment
        output.push_str(&self.format_doc_comment(&trait_decl.exegesis));

        // Trait definition with supertraits
        let supertrait_clause = if supertraits.is_empty() {
            String::new()
        } else {
            format!(": {}", supertraits.join(" + "))
        };

        output.push_str(&format!(
            "{visibility}trait {trait_name}{supertrait_clause} {{\n"
        ));

        for (method_name, return_type) in &methods {
            let rust_method = to_rust_ident(method_name);
            output.push_str(&format!(
                "    /// Get the {} state.\n",
                method_name.replace('_', " ")
            ));
            output.push_str(&format!(
                "    fn {rust_method}(&self) -> {return_type};\n\n"
            ));
        }

        // Remove trailing newline if we have methods
        if !methods.is_empty() {
            output.pop();
        }

        output.push_str("}\n");

        output
    }

    /// Generate Rust assertions/invariants from a constraint declaration.
    fn generate_constraint(&self, constraint: &Constraint) -> String {
        let fn_name = to_rust_ident(&constraint.name);
        let visibility = self.visibility_str();

        let mut output = String::new();

        // Doc comment
        output.push_str(&self.format_doc_comment(&constraint.exegesis));

        output.push_str(&format!(
            "/// Validates the {} constraint.\n",
            constraint.name
        ));
        output.push_str(&format!(
            "{visibility}fn validate_{fn_name}<T>(value: &T) -> bool {{\n"
        ));

        // Generate constraint checks from statements
        for stmt in &constraint.statements {
            match stmt {
                Statement::Matches {
                    subject, target, ..
                } => {
                    output.push_str(&format!("    // {subject} matches {target}\n"));
                }
                Statement::Never {
                    subject, action, ..
                } => {
                    output.push_str(&format!("    // {subject} never {action}\n"));
                }
                _ => {}
            }
        }

        output.push_str("    // Implement validation logic based on the constraint rules above\n");
        output.push_str("    true\n");
        output.push_str("}\n");

        output
    }

    /// Generate a Rust module from a system declaration.
    fn generate_system(&self, system: &System) -> String {
        let mod_name = to_snake_case(&system.name);
        let visibility = self.visibility_str();

        let mut output = String::new();

        // Doc comment
        output.push_str(&self.format_doc_comment(&system.exegesis));
        output.push_str(&format!("/// System version: {}\n", system.version));

        // Module with requirements as comments
        output.push_str(&format!("{visibility}mod {mod_name} {{\n"));

        if !system.requirements.is_empty() {
            output.push_str("    //! # Requirements\n    //!\n");
            for req in &system.requirements {
                output.push_str(&format!(
                    "    //! - `{}` {} {}\n",
                    req.name, req.constraint, req.version
                ));
            }
            output.push('\n');
        }

        output.push_str("    // Add system components and implementation here\n");
        output.push_str("}\n");

        output
    }

    /// Generate documentation for an evolution declaration.
    fn generate_evolution(&self, evolution: &Evolution) -> String {
        let mut output = String::new();

        // Evolution is primarily documentation
        output.push_str(&format!(
            "// Evolution: {} @ {} (from {})\n",
            evolution.name, evolution.version, evolution.parent_version
        ));

        if let Some(rationale) = &evolution.rationale {
            output.push_str(&format!("// Rationale: {}\n", rationale));
        }

        output.push_str("//\n");
        output.push_str(&self.format_doc_comment(&evolution.exegesis));

        if !evolution.additions.is_empty() {
            output.push_str("// Additions:\n");
            for stmt in &evolution.additions {
                output.push_str(&format!("//   - {:?}\n", stmt));
            }
        }

        if !evolution.deprecations.is_empty() {
            output.push_str("// Deprecations:\n");
            for stmt in &evolution.deprecations {
                output.push_str(&format!("//   - {:?}\n", stmt));
            }
        }

        if !evolution.removals.is_empty() {
            output.push_str("// Removals:\n");
            for item in &evolution.removals {
                output.push_str(&format!("//   - {}\n", item));
            }
        }

        output
    }

    /// Generate impl block for a gene struct.
    fn gen_gene_impl(
        &self,
        struct_name: &str,
        fields: &[(String, String, Option<Expr>, Option<Expr>)],
        functions: &[&FunctionDecl],
    ) -> String {
        let visibility = self.visibility_str();
        let mut output = String::new();

        output.push_str(&format!("impl {struct_name} {{\n"));

        // Generate constructor
        output.push_str(&format!("    {visibility}fn new("));
        let params: Vec<String> = fields
            .iter()
            .map(|(name, ty, _, _)| format!("{}: {}", to_rust_ident(name), ty))
            .collect();
        output.push_str(&params.join(", "));
        output.push_str(") -> Self {\n");
        output.push_str("        Self {\n");
        for (name, _, _, _) in fields {
            let field = to_rust_ident(name);
            output.push_str(&format!("            {field},\n"));
        }
        output.push_str("        }\n");
        output.push_str("    }\n");

        // Generate validators for fields with constraints
        for (name, _, _, constraint) in fields {
            if constraint.is_some() {
                let field = to_rust_ident(name);
                output.push_str(&format!(
                    "\n    {visibility}fn validate_{field}(&self) -> bool {{\n"
                ));
                output.push_str("        // TODO: Implement constraint validation\n");
                output.push_str("        true\n");
                output.push_str("    }\n");
            }
        }

        // Generate validate_all if there are any constraints
        let has_constraints = fields.iter().any(|(_, _, _, c)| c.is_some());
        if has_constraints {
            output.push_str(&format!(
                "\n    {visibility}fn validate_all(&self) -> bool {{\n"
            ));
            for (name, _, _, constraint) in fields {
                if constraint.is_some() {
                    let field = to_rust_ident(name);
                    output.push_str(&format!(
                        "        if !self.validate_{field}() {{ return false; }}\n"
                    ));
                }
            }
            output.push_str("        true\n");
            output.push_str("    }\n");
        }

        // Collect field names for self. prefix resolution
        let field_names: Vec<&str> = fields.iter().map(|(name, _, _, _)| name.as_str()).collect();

        // Generate methods from function declarations
        for func in functions {
            output.push('\n');
            output.push_str(&self.gen_method_with_fields(func, &field_names));
        }

        output.push_str("}\n");
        output
    }

    /// Generate a Rust method from a function declaration.
    fn gen_method(&self, func: &FunctionDecl) -> String {
        // Delegate to gen_method_with_fields with empty field list
        self.gen_method_with_fields(func, &[])
    }

    /// Generate a Rust method with field name tracking for self. prefix.
    fn gen_method_with_fields(&self, func: &FunctionDecl, field_names: &[&str]) -> String {
        let visibility = self.visibility_str();
        let mut output = String::new();

        // Method signature
        output.push_str(&format!(
            "    {visibility}fn {}(",
            to_rust_ident(&func.name)
        ));

        // Generate parameters - check if first param is 'this' for self reference
        let mut params_str = Vec::new();
        let mut skip_first = false;

        if let Some(first_param) = func.params.first() {
            if first_param.name == "this" || first_param.name == "self" {
                // First parameter is self reference
                // Check if the type indicates mutability (e.g., MutRef<Self>)
                let self_str = match &first_param.type_ann {
                    TypeExpr::Generic { name, .. } if name == "MutRef" => "&mut self",
                    _ => "&self",
                };
                params_str.push(self_str.to_string());
                skip_first = true;
            }
        }

        // If no explicit self parameter but this is a method in an impl block,
        // add &self by default (DOL methods are read-only unless explicitly mutating)
        if !skip_first {
            // Methods in impl blocks need a self receiver
            params_str.push("&self".to_string());
        }

        // Add remaining parameters
        for (i, param) in func.params.iter().enumerate() {
            if skip_first && i == 0 {
                continue;
            }
            let param_type = Self::map_type_expr(&param.type_ann);
            params_str.push(format!("{}: {}", to_rust_ident(&param.name), param_type));
        }

        output.push_str(&params_str.join(", "));
        output.push(')');

        // Return type
        if let Some(ret_ty) = &func.return_type {
            output.push_str(" -> ");
            output.push_str(&Self::map_type_expr(ret_ty));
        }

        output.push_str(" {\n");

        // Generate method body with field name resolution
        for stmt in &func.body {
            let mut stmt_code = self.gen_stmt(stmt, 2);

            // Add self. prefix for field names that appear as bare identifiers
            // We do this by replacing field names that are not already prefixed
            for field_name in field_names {
                // Match patterns where field appears as a complete identifier
                // (followed by non-identifier characters to avoid matching inside other words)
                // Pattern pairs: (match, replacement)
                // All patterns require word boundary after field name
                let non_ident_chars = [
                    ' ', ')', '/', '*', '+', '-', ',', ';', '\n', '\t', '.', ':', '<', '>', '=',
                    '!', '&', '|', '[', ']', '{', '}',
                ];

                for suffix in non_ident_chars.iter() {
                    // After open paren: (field_name...
                    let from = format!("({}{}", field_name, suffix);
                    let to = format!("(self.{}{}", field_name, suffix);
                    stmt_code = stmt_code.replace(&from, &to);

                    // After space: " field_name..." but NOT inside keywords
                    // Check that next char is not alphabetic (would mean it's part of larger word)
                    let from = format!(" {}{}", field_name, suffix);
                    let to = format!(" self.{}{}", field_name, suffix);
                    stmt_code = stmt_code.replace(&from, &to);
                }

                // Handle "return field_name;"
                let from = format!("return {};", field_name);
                let to = format!("return self.{};", field_name);
                stmt_code = stmt_code.replace(&from, &to);

                // Handle "return (field_name"
                let from = format!("return ({}", field_name);
                let to = format!("return (self.{}", field_name);
                if !stmt_code.contains(&format!("return (self.{}", field_name)) {
                    stmt_code = stmt_code.replace(&from, &to);
                }
            }

            output.push_str(&stmt_code);
        }

        output.push_str("    }\n");
        output
    }

    // === Helper Methods ===

    /// Extract fields from statements (for structs).
    /// Returns (field_name, rust_type, optional_default, optional_constraint)
    #[allow(dead_code)]
    fn extract_fields(
        &self,
        statements: &[Statement],
    ) -> Vec<(String, String, Option<Expr>, Option<Expr>)> {
        statements
            .iter()
            .filter_map(|stmt| match stmt {
                Statement::Has { property, .. } => {
                    // Legacy: Default to String type for properties without type annotations
                    Some((property.clone(), "String".to_string(), None, None))
                }
                Statement::HasField(field) => {
                    // New: Extract typed field with defaults and constraints
                    let rust_type = Self::map_type_expr(&field.type_);
                    Some((
                        field.name.clone(),
                        rust_type,
                        field.default.clone(),
                        field.constraint.clone(),
                    ))
                }
                _ => None,
            })
            .collect()
    }

    /// Extract fields from statements, generating separate enum declarations for inline enums.
    /// Returns (list of generated enum code, list of fields with resolved types)
    #[allow(clippy::type_complexity)]
    fn extract_fields_with_inline_enums(
        &self,
        statements: &[Statement],
        parent_name: &str,
    ) -> (
        Vec<String>,
        Vec<(String, String, Option<Expr>, Option<Expr>)>,
    ) {
        let mut inline_enums = Vec::new();
        let mut fields = Vec::new();
        let visibility = self.visibility_str();

        for stmt in statements {
            match stmt {
                Statement::Has { property, .. } => {
                    // Legacy: Default to String type for properties without type annotations
                    fields.push((property.clone(), "String".to_string(), None, None));
                }
                Statement::HasField(field) => {
                    // Check if the field type is an inline enum
                    if let TypeExpr::Enum { variants } = &field.type_ {
                        // Generate a name for the extracted enum
                        let enum_name = format!("{}{}", parent_name, to_pascal_case(&field.name));

                        // Generate the enum declaration
                        let mut enum_output = String::new();
                        let derives = self.derive_clause();
                        if !derives.is_empty() {
                            enum_output.push_str(&format!("#[derive({})]\n", derives));
                        }
                        enum_output.push_str(&format!("{visibility}enum {enum_name} {{\n"));
                        for variant in variants {
                            let variant_name = to_pascal_case(&variant.name);
                            if variant.fields.is_empty() && variant.tuple_types.is_empty() {
                                if let Some(discrim) = variant.discriminant {
                                    enum_output
                                        .push_str(&format!("    {variant_name} = {discrim},\n"));
                                } else {
                                    enum_output.push_str(&format!("    {variant_name},\n"));
                                }
                            } else if !variant.tuple_types.is_empty() {
                                // Tuple variant
                                let types: Vec<_> = variant
                                    .tuple_types
                                    .iter()
                                    .map(Self::map_type_expr)
                                    .collect();
                                enum_output.push_str(&format!(
                                    "    {variant_name}({}),\n",
                                    types.join(", ")
                                ));
                            } else {
                                // Struct variant
                                enum_output.push_str(&format!("    {variant_name} {{\n"));
                                for (fname, ftype) in &variant.fields {
                                    let rust_field = to_rust_ident(fname);
                                    let rust_type = Self::map_type_expr(ftype);
                                    enum_output
                                        .push_str(&format!("        {rust_field}: {rust_type},\n"));
                                }
                                enum_output.push_str("    },\n");
                            }
                        }
                        enum_output.push_str("}\n");
                        inline_enums.push(enum_output);

                        // Use the enum name as the field type
                        fields.push((
                            field.name.clone(),
                            enum_name,
                            field.default.clone(),
                            field.constraint.clone(),
                        ));
                    } else {
                        // Regular typed field
                        let rust_type = Self::map_type_expr(&field.type_);
                        fields.push((
                            field.name.clone(),
                            rust_type,
                            field.default.clone(),
                            field.constraint.clone(),
                        ));
                    }
                }
                _ => {}
            }
        }

        (inline_enums, fields)
    }

    /// Extract function declarations from statements.
    fn extract_functions<'a>(&self, statements: &'a [Statement]) -> Vec<&'a FunctionDecl> {
        statements
            .iter()
            .filter_map(|stmt| {
                if let Statement::Function(func) = stmt {
                    Some(func.as_ref())
                } else {
                    None
                }
            })
            .collect()
    }

    /// Extract supertraits from uses statements.
    fn extract_supertraits(&self, statements: &[Statement]) -> Vec<String> {
        statements
            .iter()
            .filter_map(|stmt| {
                if let Statement::Uses { reference, .. } = stmt {
                    Some(to_pascal_case(reference))
                } else {
                    None
                }
            })
            .collect()
    }

    /// Extract methods from is statements.
    fn extract_methods(&self, statements: &[Statement]) -> Vec<(String, String)> {
        statements
            .iter()
            .filter_map(|stmt| {
                if let Statement::Is { state, .. } = stmt {
                    // State becomes a getter method returning bool or state type
                    Some((format!("is_{}", to_snake_case(state)), "bool".to_string()))
                } else {
                    None
                }
            })
            .collect()
    }

    /// Get visibility string.
    fn visibility_str(&self) -> &'static str {
        match self.options.visibility {
            Visibility::Private => "",
            Visibility::Public => "pub ",
            Visibility::Crate => "pub(crate) ",
        }
    }

    /// Format exegesis as a doc comment.
    fn format_doc_comment(&self, exegesis: &str) -> String {
        let trimmed = exegesis.trim();
        if trimmed.is_empty() {
            return String::new();
        }

        trimmed
            .lines()
            .map(|line| format!("/// {}\n", line.trim()))
            .collect()
    }

    /// Generate derive clause.
    /// Note: We don't include Eq because some types contain f64 which doesn't implement Eq.
    fn derive_clause(&self) -> String {
        let mut derives = vec!["Debug", "Clone", "PartialEq"];

        if !self.options.derive_macros.is_empty() {
            derives.extend(self.options.derive_macros.iter().map(|s| s.as_str()));
        }

        derives.join(", ")
    }

    // === SEX (Side Effect eXecution) Code Generation ===

    /// Generate Rust visibility modifier from DOL Visibility.
    pub fn gen_visibility(&self, vis: crate::ast::Visibility) -> &'static str {
        match vis {
            crate::ast::Visibility::Public => "pub ",
            crate::ast::Visibility::PubSpirit => "pub(crate) ",
            crate::ast::Visibility::PubParent => "pub(super) ",
            crate::ast::Visibility::Private => "",
        }
    }

    /// Generate Rust type from DOL TypeExpr.
    pub fn gen_type(&self, ty: &TypeExpr) -> String {
        Self::map_type_expr(ty)
    }

    /// Generate Rust code for a function parameter.
    pub fn gen_param(&self, param: &FunctionParam) -> String {
        format!("{}: {}", param.name, self.gen_type(&param.type_ann))
    }

    /// Generate Rust code for a sex function.
    pub fn gen_sex_function(&self, vis: crate::ast::Visibility, func: &FunctionDecl) -> String {
        let mut output = String::new();

        // Doc comment noting side effects
        output.push_str("    /// Side-effectful function\n");

        // Function signature
        output.push_str("    ");
        output.push_str(self.gen_visibility(vis));
        output.push_str("fn ");
        output.push_str(&func.name);
        output.push('(');

        let params: Vec<String> = func.params.iter().map(|p| self.gen_param(p)).collect();
        output.push_str(&params.join(", "));
        output.push(')');

        if let Some(ref ret) = func.return_type {
            output.push_str(" -> ");
            output.push_str(&self.gen_type(ret));
        }

        output.push_str(" {\n");

        for stmt in &func.body {
            output.push_str(&self.gen_stmt(stmt, 2));
        }

        output.push_str("    }\n");

        output
    }

    /// Generate Rust code for a sex block.
    pub fn gen_sex_block(&self, statements: &[Stmt], final_expr: Option<&Expr>) -> String {
        let mut output = String::new();

        output.push_str("    /* sex block */ {\n");

        for stmt in statements {
            output.push_str(&self.gen_stmt(stmt, 2));
        }
        if let Some(expr) = final_expr {
            output.push_str("        ");
            output.push_str(&self.gen_expr(expr));
            output.push('\n');
        }

        output.push_str("    }\n");

        output
    }

    /// Generate Rust code for a global mutable variable.
    pub fn gen_global_var(&self, var: &VarDecl) -> String {
        let mut output = String::new();

        if var.mutability == Mutability::Mutable {
            // Mutable globals become static mut (unsafe in Rust)
            output.push_str("static mut ");
        } else {
            output.push_str("static ");
        }

        output.push_str(&var.name.to_uppercase());
        output.push_str(": ");

        if let Some(ref type_ann) = var.type_ann {
            output.push_str(&self.gen_type(type_ann));
        } else {
            output.push('_');
        }

        if let Some(ref value) = var.value {
            output.push_str(" = ");
            output.push_str(&self.gen_expr(value));
        }

        output.push_str(";\n");
        output
    }

    /// Generate Rust code for a constant.
    pub fn gen_constant(&self, var: &VarDecl) -> String {
        let mut output = String::new();

        output.push_str("const ");
        output.push_str(&var.name.to_uppercase());
        output.push_str(": ");

        if let Some(ref type_ann) = var.type_ann {
            output.push_str(&self.gen_type(type_ann));
        }

        output.push_str(" = ");
        if let Some(ref value) = var.value {
            output.push_str(&self.gen_expr(value));
        }

        output.push_str(";\n");
        output
    }

    /// Generate Rust code for an extern declaration.
    pub fn gen_extern(&self, decl: &ExternDecl) -> String {
        let mut output = String::new();

        let abi = decl.abi.as_deref().unwrap_or("C");
        output.push_str(&format!("extern \"{}\" {{\n", abi));

        output.push_str("    fn ");
        output.push_str(&decl.name);
        output.push('(');

        let params: Vec<String> = decl.params.iter().map(|p| self.gen_param(p)).collect();
        output.push_str(&params.join(", "));
        output.push(')');

        if let Some(ref ret) = decl.return_type {
            output.push_str(" -> ");
            output.push_str(&self.gen_type(ret));
        }

        output.push_str(";\n");

        output.push_str("}\n");

        output
    }

    /// Generate Rust code for an extern block.
    pub fn gen_extern_block(&self, abi: Option<&str>, functions: &[ExternDecl]) -> String {
        let mut output = String::new();

        let abi_str = abi.unwrap_or("C");
        output.push_str(&format!("extern \"{}\" {{\n", abi_str));

        for func in functions {
            output.push_str("    fn ");
            output.push_str(&func.name);
            output.push('(');

            let params: Vec<String> = func.params.iter().map(|p| self.gen_param(p)).collect();
            output.push_str(&params.join(", "));
            output.push(')');

            if let Some(ref ret) = func.return_type {
                output.push_str(" -> ");
                output.push_str(&self.gen_type(ret));
            }

            output.push_str(";\n");
        }

        output.push_str("}\n");

        output
    }

    /// Generate wrapper for mutable global access.
    pub fn gen_global_access(&self, name: &str) -> String {
        format!("unsafe {{ {} }}", name.to_uppercase())
    }

    /// Generate wrapper for mutable global mutation.
    pub fn gen_global_mutation(&self, name: &str, value: &str) -> String {
        format!("unsafe {{ {} = {}; }}", name.to_uppercase(), value)
    }

    /// Generate Rust code for a statement with indentation.
    fn gen_stmt(&self, stmt: &Stmt, indent_level: usize) -> String {
        let indent = "    ".repeat(indent_level);
        let mut output = String::new();

        match stmt {
            Stmt::Let {
                name,
                type_ann,
                value,
            } => {
                output.push_str(&indent);
                // DOL variables are mutable by default, so use 'let mut'
                // Exception: can't use 'mut' with wildcard '_'
                if name == "_" {
                    output.push_str("let ");
                } else {
                    output.push_str("let mut ");
                }
                output.push_str(name);
                if let Some(ty) = type_ann {
                    output.push_str(": ");
                    output.push_str(&self.gen_type(ty));
                }
                output.push_str(" = ");
                output.push_str(&self.gen_expr(value));
                output.push_str(";\n");
            }
            Stmt::Assign { target, value } => {
                output.push_str(&indent);
                output.push_str(&self.gen_expr(target));
                output.push_str(" = ");
                output.push_str(&self.gen_expr(value));
                output.push_str(";\n");
            }
            Stmt::Return(Some(expr)) => {
                output.push_str(&indent);
                output.push_str("return ");
                output.push_str(&self.gen_expr(expr));
                output.push_str(";\n");
            }
            Stmt::Return(None) => {
                output.push_str(&indent);
                output.push_str("return;\n");
            }
            Stmt::Expr(expr) => {
                output.push_str(&indent);
                output.push_str(&self.gen_expr(expr));
                output.push_str(";\n");
            }
            Stmt::Break => {
                output.push_str(&indent);
                output.push_str("break;\n");
            }
            Stmt::Continue => {
                output.push_str(&indent);
                output.push_str("continue;\n");
            }
            Stmt::For {
                binding,
                iterable,
                body,
            } => {
                output.push_str(&indent);
                output.push_str("for ");
                output.push_str(binding);
                output.push_str(" in ");
                output.push_str(&self.gen_expr(iterable));
                output.push_str(" {\n");
                for s in body {
                    output.push_str(&self.gen_stmt(s, indent_level + 1));
                }
                output.push_str(&indent);
                output.push_str("}\n");
            }
            Stmt::While { condition, body } => {
                output.push_str(&indent);
                output.push_str("while ");
                output.push_str(&self.gen_expr(condition));
                output.push_str(" {\n");
                for s in body {
                    output.push_str(&self.gen_stmt(s, indent_level + 1));
                }
                output.push_str(&indent);
                output.push_str("}\n");
            }
            Stmt::Loop { body } => {
                output.push_str(&indent);
                output.push_str("loop {\n");
                for s in body {
                    output.push_str(&self.gen_stmt(s, indent_level + 1));
                }
                output.push_str(&indent);
                output.push_str("}\n");
            }
        }

        output
    }

    /// Generate Rust code for an expression.
    pub fn gen_expr(&self, expr: &Expr) -> String {
        match expr {
            Expr::Literal(lit) => self.gen_literal(lit),
            Expr::Identifier(name) => {
                // Handle qualified identifiers (DOL lexer collects dots as part of identifiers)
                // e.g., "this.field" becomes "self.field", "Type.Variant" becomes "Type::Variant"
                if name.contains('.') {
                    let parts: Vec<&str> = name.split('.').collect();
                    let mut result = String::new();
                    for (i, part) in parts.iter().enumerate() {
                        if i > 0 {
                            // Use :: if previous part starts with uppercase (type), else use .
                            if result.chars().next().is_some_and(|c| c.is_uppercase())
                                && !result.contains('.')
                            {
                                // Check if the first part (type) should map to inline enum
                                // e.g., Expr.Ident -> ExprType::Ident
                                if let Some(inline_enum) = self.get_inline_enum_type(&result) {
                                    result = inline_enum;
                                }
                                result.push_str("::");
                            } else {
                                result.push('.');
                            }
                        }
                        // Map 'this' to 'self' - don't escape 'self' as it's valid in method context
                        // Also apply method name mappings for DOL -> Rust
                        if *part == "this" {
                            result.push_str("self");
                        } else {
                            let mapped = self.map_method_name(part);
                            result.push_str(&super::escape_rust_keyword(mapped));
                        }
                    }
                    result
                } else if name.contains("::") {
                    // Handle path expressions like Map::new, List::new
                    let parts: Vec<&str> = name.split("::").collect();
                    let first_part = match parts[0] {
                        "Map" => "HashMap",
                        "List" => "Vec",
                        other => other,
                    };
                    let rest: Vec<&str> = parts[1..].to_vec();
                    if rest.is_empty() {
                        first_part.to_string()
                    } else {
                        format!("{}::{}", first_part, rest.join("::"))
                    }
                } else if name == "this" {
                    "self".to_string()
                } else {
                    // Map DOL type names to Rust equivalents
                    let mapped_name = match name.as_str() {
                        "Map" => "HashMap",
                        "List" => "Vec",
                        _ => name.as_str(),
                    };
                    // Escape Rust keywords in single identifiers
                    super::escape_rust_keyword(mapped_name)
                }
            }
            Expr::Binary { left, op, right } => {
                match op {
                    // Pipe operator: x |> f becomes f(x)
                    crate::ast::BinaryOp::Pipe => {
                        let arg = self.gen_expr(left);
                        let func = self.gen_expr(right);
                        // Wrap lambda in parens if needed
                        let func_str = if func.starts_with('|') {
                            format!("({})", func)
                        } else {
                            func
                        };
                        format!("{}({})", func_str, arg)
                    }
                    // Compose operator: f >> g becomes |__x| g(f(__x))
                    crate::ast::BinaryOp::Compose => {
                        let f = self.gen_expr(left);
                        let g = self.gen_expr(right);
                        // Wrap lambda in parens if needed
                        let f_str = if f.starts_with('|') {
                            format!("({})", f)
                        } else {
                            f
                        };
                        format!("|__x| {}({}(__x))", g, f_str)
                    }
                    // Apply operator: f @ x becomes f(x)
                    crate::ast::BinaryOp::Apply => {
                        let func = self.gen_expr(left);
                        let arg = self.gen_expr(right);
                        format!("{}({})", func, arg)
                    }
                    // Implies operator: a => b becomes (!a || b)
                    crate::ast::BinaryOp::Implies => {
                        let a = self.gen_expr(left);
                        let b = self.gen_expr(right);
                        format!("(!{} || {})", a, b)
                    }
                    // Monadic bind: m := f (depends on monad implementation)
                    crate::ast::BinaryOp::Bind => {
                        let m = self.gen_expr(left);
                        let f = self.gen_expr(right);
                        format!("{}.and_then({})", m, f)
                    }
                    // Functor map: f <$> m becomes m.map(f)
                    crate::ast::BinaryOp::Map => {
                        let f = self.gen_expr(left);
                        let m = self.gen_expr(right);
                        format!("{}.map({})", m, f)
                    }
                    // Applicative apply: mf <*> mx (depends on applicative implementation)
                    crate::ast::BinaryOp::Ap => {
                        let mf = self.gen_expr(left);
                        let mx = self.gen_expr(right);
                        format!("/* applicative apply */ {}.ap({})", mf, mx)
                    }
                    // Exponentiation: x ^ y becomes x.pow(y) for integers
                    crate::ast::BinaryOp::Pow => {
                        let base = self.gen_expr(left);
                        let exp = self.gen_expr(right);
                        format!("{}.pow({} as u32)", base, exp)
                    }
                    // Standard infix operators
                    _ => {
                        // Handle string concatenation specially
                        if matches!(op, crate::ast::BinaryOp::Add) && self.is_string_expr(expr) {
                            return self.gen_string_concat(expr);
                        }

                        let left_str = self.gen_expr(left);
                        let right_str = self.gen_expr(right);
                        let op_str = match op {
                            crate::ast::BinaryOp::Add => "+",
                            crate::ast::BinaryOp::Sub => "-",
                            crate::ast::BinaryOp::Mul => "*",
                            crate::ast::BinaryOp::Div => "/",
                            crate::ast::BinaryOp::Mod => "%",
                            crate::ast::BinaryOp::Eq => "==",
                            crate::ast::BinaryOp::Ne => "!=",
                            crate::ast::BinaryOp::Lt => "<",
                            crate::ast::BinaryOp::Le => "<=",
                            crate::ast::BinaryOp::Gt => ">",
                            crate::ast::BinaryOp::Ge => ">=",
                            crate::ast::BinaryOp::And => "&&",
                            crate::ast::BinaryOp::Or => "||",
                            crate::ast::BinaryOp::Member => ".",
                            crate::ast::BinaryOp::Range => "..",
                            _ => "/* unsupported op */",
                        };
                        format!("({} {} {})", left_str, op_str, right_str)
                    }
                }
            }
            Expr::Unary { op, operand } => {
                let operand_str = self.gen_expr(operand);
                let op_str = match op {
                    crate::ast::UnaryOp::Neg => "-",
                    crate::ast::UnaryOp::Not => "!",
                    crate::ast::UnaryOp::Deref => "*",
                    _ => "/* unsupported op */",
                };
                format!("{}{}", op_str, operand_str)
            }
            Expr::Call { callee, args } => {
                let mut callee_str = self.gen_expr(callee);

                // Check if this is a .join() call - separator should be &str, not String
                let is_join_call = callee_str.ends_with(".join");
                let args_str: Vec<String> = args
                    .iter()
                    .map(|a| {
                        if is_join_call {
                            // For .join() separator, use &str (no .to_string())
                            self.gen_expr_as_str(a)
                        } else {
                            self.gen_expr(a)
                        }
                    })
                    .collect();

                // Check if this is a method call that needs .iter() in Rust
                // DOL allows .map(), .filter(), .for_each() directly on collections
                // but Rust requires .iter().map(), .into_iter().map(), etc.
                // Also track methods that produce iterators and need .collect()
                let iterator_producing_methods = [".map", ".filter", ".filter_map"];
                let iterator_consuming_methods =
                    [".for_each", ".find", ".any", ".all", ".fold", ".reduce"];
                let mut needs_collect = false;
                for method in iterator_producing_methods {
                    if callee_str.ends_with(method) {
                        // Insert .into_iter() before the method call
                        let method_name = method.trim_start_matches('.');
                        let insert_pos = callee_str.len() - method_name.len() - 1; // -1 for the dot
                        callee_str.insert_str(insert_pos, ".into_iter()");
                        needs_collect = true;
                        break;
                    }
                }
                if !needs_collect {
                    for method in iterator_consuming_methods {
                        if callee_str.ends_with(method) {
                            // Insert .into_iter() before the method call
                            let method_name = method.trim_start_matches('.');
                            let insert_pos = callee_str.len() - method_name.len() - 1;
                            callee_str.insert_str(insert_pos, ".into_iter()");
                            break;
                        }
                    }
                }

                // Some DOL functions map to Rust macros
                let base_result = match callee_str.as_str() {
                    "println" => format!("println!(\"{{}}\", {})", args_str.join(", ")),
                    "eprintln" => format!("eprintln!(\"{{}}\", {})", args_str.join(", ")),
                    "print" => format!("print!(\"{{}}\", {})", args_str.join(", ")),
                    "eprint" => format!("eprint!(\"{{}}\", {})", args_str.join(", ")),
                    "panic" => format!("panic!(\"{{}}\", {})", args_str.join(", ")),
                    "format" => format!("format!(\"{{}}\", {})", args_str.join(", ")),
                    "vec" => format!("vec![{}]", args_str.join(", ")),
                    _ => {
                        // Check if callee is a type name (starts with uppercase)
                        // If so, convert Type(args) to Type::new(args)
                        // Exception: Don't convert enum variants (Some, Ok, Err, None)
                        // or paths that already contain ::
                        // Also exception: Flat enum genes (Expr, Stmt, Decl, etc.) don't have ::new
                        let first_char = callee_str.chars().next();
                        let is_enum_variant = matches!(
                            callee_str.as_str(),
                            "Some" | "None" | "Ok" | "Err" | "Left" | "Right"
                        );
                        // Flat enum genes - these are generated as enums without ::new constructor
                        // For flat enum genes, the pattern Expr(variant, span) should become
                        // variant with span integrated
                        let is_flat_enum_gene = matches!(
                            callee_str.as_str(),
                            "Expr" | "Stmt" | "Decl" | "TypeExpr" | "Pattern" | "TokenKind"
                        );
                        if is_flat_enum_gene && args_str.len() == 2 {
                            // Pattern: Expr(Expr::Variant { fields }, span)
                            // Transform to: Expr::Variant { fields, span }
                            let variant_arg = &args_str[0];
                            let span_arg = &args_str[1];
                            // Check if first arg is a variant constructor
                            if variant_arg.starts_with(&format!("{}::", callee_str)) {
                                // Extract the variant construction and add span
                                if variant_arg.ends_with('}') {
                                    // Struct variant like Expr::Ident { name }
                                    // Insert span before the closing brace
                                    let without_brace =
                                        variant_arg.trim_end_matches('}').trim_end();
                                    format!("{}, span: {} }}", without_brace, span_arg)
                                } else if variant_arg.ends_with(')') {
                                    // Tuple variant like Expr::Binary(op, left, right)
                                    // Convert to Expr::Binary(BinaryExpr { op, left, right, span })
                                    self.convert_tuple_variant_with_span(
                                        &callee_str,
                                        variant_arg,
                                        span_arg,
                                    )
                                } else {
                                    // Simple variant like Expr::Ident
                                    format!("{} {{ span: {} }}", variant_arg, span_arg)
                                }
                            } else {
                                // First arg is not a variant, fall back to function call
                                format!("{}({})", callee_str, args_str.join(", "))
                            }
                        } else if first_char.is_some_and(|c| c.is_uppercase())
                            && !callee_str.contains("::")
                            && !is_enum_variant
                            && !is_flat_enum_gene
                        {
                            format!("{}::new({})", callee_str, args_str.join(", "))
                        } else if self.is_array_indexing(callee, args) {
                            // DOL parser treats a[i] as Call { callee: a, args: [i] }
                            // Detect this and generate proper indexing syntax
                            format!("{}[{}]", callee_str, args_str.join(", "))
                        } else if callee_str.contains("::") {
                            // Check if this is an inline enum variant construction
                            // e.g., ExprType::Ident(name) should be ExprType::Ident { name }
                            let parts: Vec<&str> = callee_str.split("::").collect();
                            if parts.len() == 2 {
                                let enum_name = parts[0];
                                let variant_name = parts[1];
                                if let Some(fields) =
                                    self.get_struct_literal_fields(enum_name, variant_name)
                                {
                                    // Generate struct literal syntax with actual DOL field names
                                    if fields.len() == args_str.len() {
                                        let field_inits: Vec<String> = fields
                                            .iter()
                                            .zip(args_str.iter())
                                            .map(|(f, v)| format!("{}: {}", f, v))
                                            .collect();
                                        format!("{} {{ {} }}", callee_str, field_inits.join(", "))
                                    } else {
                                        // Field count mismatch, fall back to tuple syntax
                                        format!("{}({})", callee_str, args_str.join(", "))
                                    }
                                } else {
                                    format!("{}({})", callee_str, args_str.join(", "))
                                }
                            } else {
                                format!("{}({})", callee_str, args_str.join(", "))
                            }
                        } else {
                            format!("{}({})", callee_str, args_str.join(", "))
                        }
                    }
                };
                // Add .collect() for iterator methods that return iterators
                if needs_collect {
                    format!("{}.collect::<Vec<_>>()", base_result)
                } else {
                    base_result
                }
            }
            Expr::Member { object, field } => {
                let obj_str = self.gen_expr(object);
                // Map DOL method names to Rust equivalents
                let mapped_field = self.map_method_name(field);
                // Escape Rust keywords in field names
                let escaped_field = super::escape_rust_keyword(mapped_field);
                // Use :: for type constructors (uppercase identifiers accessing variants)
                // e.g., Type.Var -> Type::Var, but self.field -> self.field
                if obj_str.chars().next().is_some_and(|c| c.is_uppercase()) {
                    // Check if this is accessing a variant of an inline enum
                    // e.g., Expr.Ident should become ExprType::Ident (not Expr::Ident)
                    if let Some(inline_enum_name) = self.get_inline_enum_type(&obj_str) {
                        format!("{}::{}", inline_enum_name, escaped_field)
                    } else {
                        format!("{}::{}", obj_str, escaped_field)
                    }
                } else {
                    format!("{}.{}", obj_str, escaped_field)
                }
            }
            Expr::If {
                condition,
                then_branch,
                else_branch,
            } => {
                let mut output = String::new();
                output.push_str("if ");
                output.push_str(&self.gen_expr(condition));
                // If then_branch is already a block, it has its own braces
                let then_str = self.gen_expr(then_branch);
                if then_str.starts_with('{') {
                    output.push(' ');
                    // Ensure block returns () when there's no else by adding semicolon after last expr
                    if else_branch.is_none() {
                        // Insert semicolon before the closing brace to make last expression a statement
                        if let Some(last_brace_pos) = then_str.rfind('\n') {
                            let (before, after) = then_str.split_at(last_brace_pos);
                            // Check if line before closing brace doesn't end with semicolon
                            let trimmed = before.trim_end();
                            if !trimmed.ends_with(';')
                                && !trimmed.ends_with('}')
                                && !trimmed.is_empty()
                            {
                                output.push_str(trimmed);
                                output.push(';');
                                output.push_str(after);
                            } else {
                                output.push_str(&then_str);
                            }
                        } else {
                            output.push_str(&then_str);
                        }
                    } else {
                        output.push_str(&then_str);
                    }
                } else {
                    output.push_str(" { ");
                    output.push_str(&then_str);
                    // Add semicolon to suppress value when no else
                    if else_branch.is_none() {
                        output.push(';');
                    }
                    output.push_str(" }");
                }
                if let Some(else_br) = else_branch {
                    let else_str = self.gen_expr(else_br);
                    if else_str.starts_with('{') {
                        output.push_str(" else ");
                        output.push_str(&else_str);
                    } else {
                        output.push_str(" else { ");
                        output.push_str(&else_str);
                        output.push_str(" }");
                    }
                }
                output
            }
            Expr::Block {
                statements,
                final_expr,
            } => {
                let mut output = String::new();
                output.push_str("{\n");
                for stmt in statements {
                    output.push_str(&self.gen_stmt(stmt, 1));
                }
                if let Some(expr) = final_expr {
                    output.push_str("    ");
                    output.push_str(&self.gen_expr(expr));
                    // Add semicolon for if without else to avoid type mismatch
                    if matches!(
                        expr.as_ref(),
                        Expr::If {
                            else_branch: None,
                            ..
                        }
                    ) {
                        output.push(';');
                    }
                    output.push('\n');
                }
                output.push('}');
                output
            }
            Expr::SexBlock {
                statements,
                final_expr,
            } => {
                let mut output = String::new();
                output.push_str("/* sex */ {\n");
                for stmt in statements {
                    output.push_str(&self.gen_stmt(stmt, 1));
                }
                if let Some(expr) = final_expr {
                    output.push_str("    ");
                    output.push_str(&self.gen_expr(expr));
                    // Add semicolon for if without else to avoid type mismatch
                    if matches!(
                        expr.as_ref(),
                        Expr::If {
                            else_branch: None,
                            ..
                        }
                    ) {
                        output.push(';');
                    }
                    output.push('\n');
                }
                output.push('}');
                output
            }
            Expr::Lambda {
                params,
                return_type,
                body,
            } => {
                let mut output = String::new();
                output.push('|');

                // Generate parameters with optional type annotations
                let params_str: Vec<String> = params
                    .iter()
                    .map(|(name, type_ann)| {
                        if let Some(ty) = type_ann {
                            format!("{}: {}", name, Self::map_type_expr(ty))
                        } else {
                            name.clone()
                        }
                    })
                    .collect();
                output.push_str(&params_str.join(", "));
                output.push('|');

                // Add return type if specified
                if let Some(ret_ty) = return_type {
                    output.push_str(" -> ");
                    output.push_str(&Self::map_type_expr(ret_ty));
                }

                // Generate body
                output.push_str(" { ");
                output.push_str(&self.gen_expr(body));
                output.push_str(" }");

                output
            }
            Expr::Match { scrutinee, arms } => self.gen_match(scrutinee, arms),
            // Meta-programming expressions
            Expr::Quote(inner) => self.gen_quote(inner),
            Expr::Eval(inner) => self.gen_eval(inner),
            Expr::Reflect(ty) => self.gen_reflect(ty),
            Expr::QuasiQuote(inner) => self.gen_quasi_quote(inner),
            Expr::Unquote(inner) => self.gen_unquote(inner),
            Expr::IdiomBracket { func, args } => self.gen_idiom_bracket(func, args),
            // Logical expressions
            Expr::Forall(_) | Expr::Exists(_) | Expr::Implies { .. } => {
                "/* logical expression not yet supported */".to_string()
            }
            // List literal
            Expr::List(elements) => {
                let elems: Vec<String> = elements.iter().map(|e| self.gen_expr(e)).collect();
                format!("vec![{}]", elems.join(", "))
            }
            // Tuple literal
            Expr::Tuple(elements) => {
                let elems: Vec<String> = elements.iter().map(|e| self.gen_expr(e)).collect();
                format!("({})", elems.join(", "))
            }
            // Type cast
            Expr::Cast { expr, target_type } => {
                format!(
                    "{} as {}",
                    self.gen_expr(expr),
                    Self::map_type_expr(target_type)
                )
            }
            // Struct literal - generate struct instantiation
            Expr::StructLiteral { type_name, fields } => {
                let field_strs: Vec<String> = fields
                    .iter()
                    .map(|(name, expr)| format!("{}: {}", name, self.gen_expr(expr)))
                    .collect();
                format!("{} {{ {} }}", type_name, field_strs.join(", "))
            }
            // Try operator
            Expr::Try(inner) => {
                format!("{}?", self.gen_expr(inner))
            }
        }
    }

    /// Generate Rust code for a literal.
    fn gen_literal(&self, lit: &Literal) -> String {
        match lit {
            Literal::Int(n) => format!("{}_i64", n),
            Literal::Float(f) => {
                if f.fract() == 0.0 {
                    format!("{:.1}_f64", f)
                } else {
                    format!("{}_f64", f)
                }
            }
            Literal::Bool(b) => b.to_string(),
            Literal::String(s) => format!("\"{}\".to_string()", s.escape_default()),
            Literal::Char(c) => format!("'{}'", c.escape_default()),
            Literal::Null => "None".to_string(),
        }
    }

    /// Generate Rust code for a literal in a pattern context.
    /// Unlike gen_literal, this doesn't add .to_string() to string literals
    /// because Rust patterns require static string literals.
    fn gen_literal_pattern(&self, lit: &Literal) -> String {
        self.gen_literal_as_str(lit)
    }

    /// Generate Rust code for a literal as &str (no .to_string() for strings).
    /// Used in pattern contexts and as arguments to methods like .join().
    fn gen_literal_as_str(&self, lit: &Literal) -> String {
        match lit {
            Literal::Int(n) => format!("{}_i64", n),
            Literal::Float(f) => {
                if f.fract() == 0.0 {
                    format!("{:.1}_f64", f)
                } else {
                    format!("{}_f64", f)
                }
            }
            Literal::Bool(b) => b.to_string(),
            // &str, not String
            Literal::String(s) => format!("\"{}\"", s.escape_default()),
            Literal::Char(c) => format!("'{}'", c.escape_default()),
            Literal::Null => "None".to_string(),
        }
    }

    /// Generate Rust code for an expression in a context where &str is expected.
    /// For literals, this avoids adding .to_string().
    fn gen_expr_as_str(&self, expr: &Expr) -> String {
        match expr {
            Expr::Literal(lit) => self.gen_literal_as_str(lit),
            _ => self.gen_expr(expr),
        }
    }

    #[allow(dead_code)]
    fn gen_literal_pattern_old(&self, lit: &Literal) -> String {
        match lit {
            Literal::Int(n) => format!("{}_i64", n),
            Literal::Float(f) => {
                if f.fract() == 0.0 {
                    format!("{:.1}_f64", f)
                } else {
                    format!("{}_f64", f)
                }
            }
            Literal::Bool(b) => b.to_string(),
            // Patterns require &str, not String
            Literal::String(s) => format!("\"{}\"", s.escape_default()),
            Literal::Char(c) => format!("'{}'", c.escape_default()),
            Literal::Null => "None".to_string(),
        }
    }

    /// Check if an expression involves string values (for detecting string concatenation).
    fn is_string_expr(&self, expr: &Expr) -> bool {
        Self::is_string_expr_static(expr)
    }

    /// Static version for recursive calls without &self.
    fn is_string_expr_static(expr: &Expr) -> bool {
        match expr {
            Expr::Literal(Literal::String(_)) => true,
            Expr::Binary { left, op, right } => {
                if matches!(op, crate::ast::BinaryOp::Add) {
                    Self::is_string_expr_static(left) || Self::is_string_expr_static(right)
                } else {
                    false
                }
            }
            // Method calls that return strings (common patterns)
            Expr::Call { callee, .. } => {
                if let Expr::Member { field, .. } = callee.as_ref() {
                    matches!(field.as_str(), "to_string" | "format" | "join")
                } else {
                    false
                }
            }
            _ => false,
        }
    }

    /// Generate Rust code for string concatenation using format! macro.
    /// Collects all parts of the string addition chain into a single format! call.
    fn gen_string_concat(&self, expr: &Expr) -> String {
        let mut parts = Vec::new();
        self.collect_string_parts(expr, &mut parts);

        if parts.len() == 1 {
            parts.pop().unwrap()
        } else {
            // Generate format!("{}{}{}", part1, part2, part3)
            let placeholders = "{}".repeat(parts.len());
            format!("format!(\"{}\", {})", placeholders, parts.join(", "))
        }
    }

    /// Recursively collect parts of a string concatenation.
    fn collect_string_parts(&self, expr: &Expr, parts: &mut Vec<String>) {
        match expr {
            Expr::Binary {
                left,
                op: crate::ast::BinaryOp::Add,
                right,
            } => {
                self.collect_string_parts(left, parts);
                self.collect_string_parts(right, parts);
            }
            Expr::Literal(Literal::String(s)) => {
                // For string literals, we just include the content (unquoted)
                // because format! will handle them
                parts.push(format!("\"{}\"", s.escape_default()));
            }
            _ => {
                // For other expressions, generate them normally
                parts.push(self.gen_expr(expr));
            }
        }
    }

    /// Generate Rust code for a pattern in a match expression.
    ///
    /// # Arguments
    ///
    /// * `pattern` - The pattern to generate code for
    ///
    /// # Returns
    ///
    /// Rust code representing the pattern
    ///
    /// # Example Output
    ///
    /// ```ignore
    /// // Pattern::Wildcard => "_"
    /// // Pattern::Identifier("x") => "x"
    /// // Pattern::Literal(Literal::Int(42)) => "42_i64"
    /// // Pattern::Constructor { name: "Some", fields: [Pattern::Identifier("x")] } => "Some(x)"
    /// // Pattern::Tuple([Pattern::Identifier("x"), Pattern::Identifier("y")]) => "(x, y)"
    /// ```
    #[allow(dead_code)]
    fn gen_pattern(&self, pattern: &crate::ast::Pattern) -> String {
        // Delegate to the hint-aware version with no hint
        self.gen_pattern_with_hint(pattern, None)
    }

    /// Detect if a Call expression is actually array indexing.
    /// DOL parser treats `a[i]` as `Call { callee: a, args: [i] }`.
    /// We use a conservative heuristic:
    /// - Callee must be a known collection-like variable name
    /// - Exactly one argument
    fn is_array_indexing(&self, callee: &Expr, args: &[Expr]) -> bool {
        // Must have exactly one argument
        if args.len() != 1 {
            return false;
        }

        match callee {
            Expr::Identifier(name) => {
                // Only treat as indexing for known collection variable patterns
                let collection_names = [
                    "path",
                    "paths",
                    "args",
                    "params",
                    "parameters",
                    "chars",
                    "bytes",
                    "tokens",
                    "items",
                    "elements",
                    "parts",
                    "components",
                    "segments",
                    "fields",
                    "arr",
                    "array",
                    "list",
                    "vec",
                    "values",
                    "keys",
                    "numbers",
                    "strings",
                    "types",
                    "exprs",
                    "expressions",
                    "decls",
                    "declarations",
                    "stmts",
                    "statements",
                    "patterns",
                    "variants",
                    "members",
                    "entries",
                    "lines",
                    "words",
                    "results",
                    "errors",
                ];
                collection_names.contains(&name.as_str())
            }
            _ => false,
        }
    }

    /// Get the inline enum type name for a gene with an inline enum field.
    ///
    /// NOTE: With the flat enum approach, genes with inline enum 'type' fields are now
    /// generated as flat enums using the gene name directly (e.g., Expr::Ident instead
    /// of ExprType::Ident). So this function returns None for all cases.
    ///
    /// Previously: Expr.Ident -> ExprType::Ident
    /// Now: Expr.Ident -> Expr::Ident (flat enum)
    fn get_inline_enum_type(&self, _gene_name: &str) -> Option<String> {
        // With flat enums, the gene name becomes the enum name directly
        // No separate *Type enum is generated, so we return None for all
        None
    }

    /// Get the field names for a flat enum variant as used in DOL pattern matching.
    /// Returns Some(fields) if the variant has known pattern fields.
    ///
    /// IMPORTANT: This returns the fields that DOL patterns actually use, not all fields.
    /// DOL patterns only bind "important" fields and `span`, skipping optional fields
    /// like `suffix`, `is_raw`, etc. The field names here must match what DOL source
    /// code uses in pattern matching.
    fn get_variant_fields(
        &self,
        enum_name: &str,
        variant_name: &str,
    ) -> Option<&'static [&'static str]> {
        match (enum_name, variant_name) {
            // Expr variants - only include fields that DOL patterns actually use
            // Most patterns use the main value field(s) + span
            ("Expr", "Ident") => Some(&["name", "span"]),
            ("Expr", "IntLit") => Some(&["value", "span"]), // DOL skips suffix
            ("Expr", "UIntLit") => Some(&["value", "span"]), // DOL skips suffix
            ("Expr", "FloatLit") => Some(&["value", "span"]), // DOL skips suffix
            ("Expr", "StringLit") => Some(&["value", "span"]), // DOL skips is_raw
            ("Expr", "CharLit") => Some(&["value", "span"]),
            ("Expr", "BoolLit") => Some(&["value", "span"]),
            ("Expr", "Path") => Some(&["segments", "span"]),
            ("Expr", "Binary") => Some(&["op", "left", "right", "span"]),
            ("Expr", "Unary") => Some(&["op", "operand", "span"]),
            ("Expr", "Call") => Some(&["callee", "args", "span"]),
            ("Expr", "MethodCall") => Some(&["receiver", "method", "args", "span"]), // skips type_args
            ("Expr", "FieldAccess") => Some(&["object", "field", "span"]),
            ("Expr", "Index") => Some(&["object", "index", "span"]),
            ("Expr", "If") => Some(&["cond", "then_block", "else_branch", "span"]),
            ("Expr", "Match") => Some(&["scrutinee", "arms", "span"]),
            ("Expr", "Block") => Some(&["block", "span"]),
            ("Expr", "Lambda") => Some(&["params", "body", "span"]),
            ("Expr", "Struct") => Some(&["name", "fields", "span"]),
            ("Expr", "Array") | ("Expr", "List") => Some(&["elements", "span"]),
            ("Expr", "Tuple") => Some(&["elements", "span"]),
            ("Expr", "TupleLit") => Some(&["elements", "span"]),
            ("Expr", "Range") => Some(&["start", "end", "span"]), // skips inclusive
            ("Expr", "Return") => Some(&["value", "span"]),
            ("Expr", "Break") => Some(&["value", "span"]),
            ("Expr", "Throw") => Some(&["value", "span"]),
            ("Expr", "Try") => Some(&["expr", "span"]),
            ("Expr", "Await") => Some(&["expr", "span"]),
            ("Expr", "Quote") => Some(&["inner", "span"]),
            ("Expr", "Eval") => Some(&["inner", "span"]),
            ("Expr", "QuasiQuote") => Some(&["inner", "span"]),
            ("Expr", "Unquote") => Some(&["inner", "span"]),
            ("Expr", "Reflect") => Some(&["ty", "span"]),
            ("Expr", "IdiomBracket") => Some(&["exprs", "span"]),
            ("Expr", "This") => Some(&[]), // unit variant
            // Stmt variants (flat enum) - include span in pattern fields
            ("Stmt", "Let") => Some(&["pattern", "ty", "value", "span"]),
            ("Stmt", "Var") => Some(&["name", "ty", "value", "span"]),
            ("Stmt", "Const") => Some(&["name", "ty", "value", "span"]),
            ("Stmt", "Assign") => Some(&["target", "value", "span"]), // skips op
            ("Stmt", "Expr") => Some(&["expr", "span"]),
            ("Stmt", "Return") => Some(&["value", "span"]),
            ("Stmt", "If") => Some(&["cond", "then_block", "else_block", "span"]),
            ("Stmt", "While") => Some(&["cond", "body", "span"]),
            ("Stmt", "For") => Some(&["pattern", "iter", "body", "span"]),
            ("Stmt", "Match") => Some(&["scrutinee", "arms"]),
            ("Stmt", "Block") => Some(&["block"]),
            ("Stmt", "Loop") => Some(&["label", "body"]),
            ("Stmt", "Break") => Some(&["label", "value"]),
            ("Stmt", "Continue") => Some(&["label"]),
            ("Stmt", "Item") => Some(&["decl"]),
            // Decl variants (flat enum)
            ("Decl", "Gene") => Some(&["decl"]),
            ("Decl", "Trait") => Some(&["decl"]),
            ("Decl", "Function") => Some(&["decl"]),
            ("Decl", "Use") => Some(&["path", "items"]),
            ("Decl", "Module") => Some(&["name", "version"]),
            ("Decl", "System") => Some(&["decl"]),
            ("Decl", "Constraint") => Some(&["decl"]),
            ("Decl", "Evolves") => Some(&["decl"]),
            // TypeExpr variants (flat enum)
            ("TypeExpr", "Named") => Some(&["path"]),
            ("TypeExpr", "Generic") => Some(&["name", "args"]),
            ("TypeExpr", "Optional") => Some(&["inner"]),
            ("TypeExpr", "Array") => Some(&["element", "size"]),
            ("TypeExpr", "Tuple") => Some(&["elements"]),
            ("TypeExpr", "Function") => Some(&["params", "ret"]),
            ("TypeExpr", "Reference") => Some(&["inner", "is_mut"]),
            ("TypeExpr", "Pointer") => Some(&["inner", "is_mut"]),
            // Pattern variants (flat enum)
            ("Pattern", "Binding") => Some(&["name", "is_mut", "binding"]),
            ("Pattern", "Ident") => Some(&["name", "is_mut", "binding"]),
            ("Pattern", "Wildcard") => Some(&[]), // unit variant
            ("Pattern", "Literal") => Some(&["value"]),
            ("Pattern", "Tuple") => Some(&["elements"]),
            ("Pattern", "Struct") => Some(&["name", "fields", "rest"]),
            ("Pattern", "Enum") => Some(&["path", "variant", "fields"]),
            ("Pattern", "Or") => Some(&["patterns"]),
            ("Pattern", "Guard") => Some(&["pattern", "guard"]),
            ("Pattern", "Path") => Some(&["segments"]),
            ("Pattern", "Range") => Some(&["start", "end", "inclusive"]),
            // Type variants (from types.dol) - for pattern matching
            ("Type", "Function") => Some(&["params", "ret"]),
            ("Type", "Tuple") => Some(&["elements"]),
            ("Type", "Generic") => Some(&["name", "args"]),
            ("Type", "Named") => Some(&["name"]),
            ("Type", "Var") => Some(&["id"]),
            _ => None,
        }
    }

    /// Get the wrapper type name for tuple variants.
    /// Returns Some(wrapper_type_name) if the variant is a tuple variant with a wrapper struct.
    /// Returns None if the variant is a struct variant or unit variant.
    fn get_tuple_variant_wrapper(
        &self,
        enum_name: &str,
        variant_name: &str,
    ) -> Option<&'static str> {
        match (enum_name, variant_name) {
            // Stmt tuple variants with wrapper types
            ("Stmt", "Let") => Some("LetStmt"),
            ("Stmt", "Var") => Some("VarStmt"),
            ("Stmt", "Const") => Some("ConstStmt"),
            ("Stmt", "Assign") => Some("AssignStmt"),
            ("Stmt", "Expr") => Some("ExprStmt"),
            ("Stmt", "Return") => Some("ReturnStmt"),
            ("Stmt", "Break") => Some("BreakStmt"),
            ("Stmt", "Continue") => Some("ContinueStmt"),
            ("Stmt", "For") => Some("ForStmt"),
            ("Stmt", "While") => Some("WhileStmt"),
            ("Stmt", "Loop") => Some("LoopStmt"),
            ("Stmt", "Match") => Some("MatchStmt"),
            // Expr tuple variants with wrapper types
            ("Expr", "This") => Some("ThisExpr"),
            ("Expr", "Binary") => Some("BinaryExpr"),
            ("Expr", "Unary") => Some("UnaryExpr"),
            ("Expr", "Call") => Some("CallExpr"),
            ("Expr", "MethodCall") => Some("MethodCallExpr"),
            ("Expr", "FieldAccess") => Some("FieldExpr"),
            ("Expr", "Index") => Some("IndexExpr"),
            ("Expr", "Struct") => Some("StructExpr"),
            ("Expr", "ArrayLit") => Some("ArrayExpr"),
            ("Expr", "Lambda") => Some("LambdaExpr"),
            ("Expr", "If") => Some("IfExpr"),
            ("Expr", "Match") => Some("MatchExpr"),
            ("Expr", "Quote") => Some("QuoteExpr"),
            _ => None,
        }
    }

    /// Convert a tuple variant call with span to proper Rust construction.
    /// E.g., `Expr::Binary(op, left, right)` + `span` -> `Expr::Binary(BinaryExpr { op, left, right, span })`
    fn convert_tuple_variant_with_span(
        &self,
        enum_name: &str,
        variant_call: &str,
        span_arg: &str,
    ) -> String {
        // Parse variant_call like "Expr::Binary(op, Box::new(left), Box::new(right))"
        // Extract variant name and arguments
        if let Some(paren_pos) = variant_call.find('(') {
            let prefix = &variant_call[..paren_pos]; // "Expr::Binary"
            let args_part = &variant_call[paren_pos..]; // "(op, Box::new(left), Box::new(right))"

            // Extract variant name from prefix
            if let Some(variant_name) = prefix.rsplit("::").next() {
                // Get wrapper type name
                if let Some(wrapper_type) = self.get_tuple_variant_wrapper(enum_name, variant_name)
                {
                    // Get field names for the wrapper type
                    if let Some(fields) = self.get_wrapper_type_fields(wrapper_type) {
                        // Extract content between matching parens
                        let args_inner = self.extract_between_matching_parens(args_part);
                        let arg_values = self.split_args_respecting_parens(&args_inner);

                        // Build struct literal with fields
                        let mut field_assignments: Vec<String> = fields
                            .iter()
                            .zip(arg_values.iter())
                            .map(|(field, value)| format!("{}: {}", field, value.trim()))
                            .collect();

                        // Add span field
                        field_assignments.push(format!("span: {}", span_arg));

                        return format!(
                            "{}::{}({} {{ {} }})",
                            enum_name,
                            variant_name,
                            wrapper_type,
                            field_assignments.join(", ")
                        );
                    }
                }
            }
        }
        // Fallback: return as-is with comment
        format!("/* tuple variant fallback */ {}", variant_call)
    }

    /// Extract content between the first matching pair of parentheses
    fn extract_between_matching_parens(&self, s: &str) -> String {
        let mut depth = 0;
        let mut start = None;
        let mut end = None;

        for (i, c) in s.char_indices() {
            match c {
                '(' => {
                    if depth == 0 {
                        start = Some(i + 1);
                    }
                    depth += 1;
                }
                ')' => {
                    depth -= 1;
                    if depth == 0 {
                        end = Some(i);
                        break;
                    }
                }
                _ => {}
            }
        }

        match (start, end) {
            (Some(start_idx), Some(end_idx)) => s[start_idx..end_idx].to_string(),
            _ => s.to_string(),
        }
    }

    /// Get field names for wrapper types
    /// Order matches the order used in DOL source constructor calls
    fn get_wrapper_type_fields(&self, wrapper_type: &str) -> Option<&'static [&'static str]> {
        match wrapper_type {
            "BinaryExpr" => Some(&["op", "left", "right"]),
            "UnaryExpr" => Some(&["op", "operand"]),
            "CallExpr" => Some(&["callee", "args"]),
            "MethodCallExpr" => Some(&["receiver", "method", "args"]),
            "FieldExpr" => Some(&["object", "field"]),
            "IndexExpr" => Some(&["object", "index"]),
            "StructExpr" => Some(&["name", "fields"]),
            "ArrayExpr" => Some(&["elements"]),
            "LambdaExpr" => Some(&["params", "body", "return_type"]),
            "IfExpr" => Some(&["cond", "then_block", "else_branch"]),
            "MatchExpr" => Some(&["scrutinee", "arms"]),
            "QuoteExpr" => Some(&["inner"]),
            "ThisExpr" => Some(&[]),
            "LetStmt" => Some(&["pattern", "ty", "value", "is_mut"]),
            "VarStmt" => Some(&["name", "ty", "value", "is_mut"]),
            "ConstStmt" => Some(&["name", "ty", "value"]),
            "AssignStmt" => Some(&["target", "value"]),
            "ExprStmt" => Some(&["expr"]),
            "ReturnStmt" => Some(&["value"]),
            "BreakStmt" => Some(&["label", "value"]),
            "ContinueStmt" => Some(&["label"]),
            "ForStmt" => Some(&["pattern", "iter", "body"]),
            "WhileStmt" => Some(&["cond", "body"]),
            "LoopStmt" => Some(&["label", "body"]),
            "MatchStmt" => Some(&["scrutinee", "arms"]),
            _ => None,
        }
    }

    /// Split comma-separated arguments while respecting nested parentheses and braces
    fn split_args_respecting_parens(&self, args: &str) -> Vec<String> {
        let mut result = Vec::new();
        let mut current = String::new();
        let mut paren_depth = 0;
        let mut brace_depth = 0;
        let mut bracket_depth = 0;

        for c in args.chars() {
            match c {
                '(' => {
                    paren_depth += 1;
                    current.push(c);
                }
                ')' => {
                    paren_depth -= 1;
                    current.push(c);
                }
                '{' => {
                    brace_depth += 1;
                    current.push(c);
                }
                '}' => {
                    brace_depth -= 1;
                    current.push(c);
                }
                '[' => {
                    bracket_depth += 1;
                    current.push(c);
                }
                ']' => {
                    bracket_depth -= 1;
                    current.push(c);
                }
                ',' if paren_depth == 0 && brace_depth == 0 && bracket_depth == 0 => {
                    result.push(current.clone());
                    current.clear();
                }
                _ => current.push(c),
            }
        }
        if !current.is_empty() {
            result.push(current);
        }
        result
    }

    /// Get the field names for struct literal construction (actual DOL variant fields).
    /// Unlike `get_variant_fields` which is for pattern matching, this returns the
    /// actual field names that DOL struct literals use, including optional fields.
    fn get_struct_literal_fields(
        &self,
        enum_name: &str,
        variant_name: &str,
    ) -> Option<&'static [&'static str]> {
        match (enum_name, variant_name) {
            // Expr variants - actual DOL AST fields (not pattern-simplified)
            ("Expr", "Ident") => Some(&["name"]),
            ("Expr", "IntLit") => Some(&["value", "suffix"]),
            ("Expr", "UIntLit") => Some(&["value", "suffix"]),
            ("Expr", "FloatLit") => Some(&["value", "suffix"]),
            ("Expr", "StringLit") => Some(&["value", "is_raw"]),
            ("Expr", "CharLit") => Some(&["value"]),
            ("Expr", "BoolLit") => Some(&["value"]),
            ("Expr", "Path") => Some(&["segments"]),
            // Expr variants - these use wrapper types in DOL parser
            // Skip struct literal conversion; let them fall through to tuple syntax
            // which will be handled by tuple-to-struct conversion later
            // ("Expr", "*") entries removed to allow tuple syntax
            // Stmt variants - also use wrapper types in DOL parser
            // ("Stmt", "*") entries removed to allow tuple syntax
            // Decl variants - actual fields
            ("Decl", "Gene") => Some(&["decl"]),
            ("Decl", "Trait") => Some(&["decl"]),
            ("Decl", "Function") => Some(&["decl"]),
            ("Decl", "Use") => Some(&["path", "items"]),
            ("Decl", "Module") => Some(&["name", "version"]),
            ("Decl", "System") => Some(&["decl"]),
            ("Decl", "Constraint") => Some(&["decl"]),
            ("Decl", "Evolves") => Some(&["decl"]),
            // TypeExpr variants - actual fields
            ("TypeExpr", "Named") => Some(&["path"]),
            ("TypeExpr", "Generic") => Some(&["name", "args"]),
            ("TypeExpr", "Optional") => Some(&["inner"]),
            ("TypeExpr", "Array") => Some(&["element", "size"]),
            ("TypeExpr", "Tuple") => Some(&["elements"]),
            ("TypeExpr", "Function") => Some(&["params", "ret"]),
            ("TypeExpr", "Reference") => Some(&["inner", "is_mut"]),
            ("TypeExpr", "Pointer") => Some(&["inner", "is_mut"]),
            ("TypeExpr", "Enum") => Some(&["variants"]),
            ("TypeExpr", "Infer") => Some(&[]),
            // Pattern variants - actual fields
            ("Pattern", "Binding") => Some(&["name", "is_mut", "binding"]),
            ("Pattern", "Wildcard") => Some(&["span"]),
            ("Pattern", "Literal") => Some(&["value"]),
            ("Pattern", "Tuple") => Some(&["name", "elements"]),
            ("Pattern", "Struct") => Some(&["name", "fields", "rest"]),
            ("Pattern", "Enum") => Some(&["path", "variant", "fields"]),
            ("Pattern", "Or") => Some(&["patterns"]),
            ("Pattern", "Guard") => Some(&["pattern", "guard"]),
            ("Pattern", "Path") => Some(&["segments"]),
            ("Pattern", "Range") => Some(&["start", "end", "inclusive"]),
            // Type variants (from types.dol) - for struct literal construction
            ("Type", "Function") => Some(&["params", "ret"]),
            ("Type", "Tuple") => Some(&["elements"]),
            ("Type", "Generic") => Some(&["name", "args"]),
            ("Type", "Named") => Some(&["name"]),
            ("Type", "Var") => Some(&["id"]),
            // Bootstrap types - GeneMember variants
            ("GeneMember", "Field") => Some(&["decl"]),
            ("GeneMember", "Method") => Some(&["decl"]),
            ("GeneMember", "TypeAlias") => Some(&["decl"]),
            // Bootstrap types - TraitMember variants
            ("TraitMember", "Required") => Some(&["decl"]),
            ("TraitMember", "Provided") => Some(&["decl"]),
            ("TraitMember", "Associated") => Some(&["decl"]),
            // Bootstrap types - SystemStmt variants
            ("SystemStmt", "Requires") => Some(&["stmt"]),
            ("SystemStmt", "Uses") => Some(&["name"]),
            ("SystemStmt", "Manages") => Some(&["name"]),
            // Bootstrap types - MigrationKind variants
            ("MigrationKind", "Added") => Some(&[]),
            ("MigrationKind", "Removed") => Some(&[]),
            ("MigrationKind", "Renamed") => Some(&["new_name"]),
            ("MigrationKind", "Changed") => Some(&["description"]),
            // Bootstrap types - ArmBody variants
            ("ArmBody", "Block") => Some(&["block"]),
            ("ArmBody", "Expr") => Some(&["expr"]),
            // Bootstrap types - LiteralPattern variants
            ("LiteralPattern", "Int") => Some(&["value"]),
            ("LiteralPattern", "Float") => Some(&["value"]),
            ("LiteralPattern", "String") => Some(&["value"]),
            ("LiteralPattern", "Bool") => Some(&["value"]),
            // Bootstrap types - LambdaBody variants
            ("LambdaBody", "Block") => Some(&["block"]),
            ("LambdaBody", "Expr") => Some(&["expr"]),
            // Bootstrap types - ExprType variants (no fields for unit variants)
            ("ExprType", "Binary") => Some(&[]),
            ("ExprType", "Unary") => Some(&[]),
            ("ExprType", "Quote") => Some(&[]),
            ("ExprType", "Idiom") => Some(&[]),
            ("ExprType", "Array") => Some(&[]),
            ("ExprType", "This") => Some(&[]),
            ("ExprType", "Ident") => Some(&[]),
            ("ExprType", "Call") => Some(&[]),
            ("ExprType", "MethodCall") => Some(&[]),
            ("ExprType", "Field") => Some(&[]),
            ("ExprType", "Index") => Some(&[]),
            ("ExprType", "Struct") => Some(&[]),
            ("ExprType", "Lambda") => Some(&[]),
            ("ExprType", "If") => Some(&[]),
            ("ExprType", "Match") => Some(&[]),
            ("ExprType", "Literal") => Some(&[]),
            _ => None,
        }
    }

    /// Map DOL method/field names to Rust equivalents.
    fn map_method_name<'a>(&self, name: &'a str) -> &'a str {
        match name {
            // Collection methods
            "length" => "len",
            "is_empty" => "is_empty",
            "append" => "push",
            "push_back" => "push",
            "pop_back" => "pop",
            "first" => "first",
            "last" => "last",
            "contains_key" => "contains_key",

            // String methods
            "to_string" => "to_string",
            "to_lowercase" => "to_lowercase",
            "to_uppercase" => "to_uppercase",
            "trim" => "trim",
            "starts_with" => "starts_with",
            "ends_with" => "ends_with",
            "contains" => "contains",
            "split" => "split",
            "join" => "join",
            "replace" => "replace",

            // Option/Result methods
            "unwrap_or" => "unwrap_or",
            "unwrap_or_default" => "unwrap_or_default",
            "get_or_default" => "unwrap_or_default",
            "is_some" => "is_some",
            "is_none" => "is_none",
            "is_ok" => "is_ok",
            "is_err" => "is_err",

            // Type environment methods
            "define" => "bind", // TypeEnv.define -> TypeEnv.bind

            // Clone/copy
            "clone" => "clone",
            "deref" => "as_ref",

            // Parsing (simplified - actual usage may need more context)
            "parse_int" => "parse",
            "parse_float" => "parse",

            _ => name,
        }
    }

    /// Generate Rust code for a match expression.
    ///
    /// # Arguments
    ///
    /// * `scrutinee` - The expression being matched
    /// * `arms` - The match arms (patterns, guards, and bodies)
    ///
    /// # Returns
    ///
    /// Rust code for the complete match expression
    ///
    /// # Example Output
    ///
    /// ```ignore
    /// match value {
    ///     Some(x) => x,
    ///     None => 0_i64
    /// }
    /// ```
    fn gen_match(&self, scrutinee: &Expr, arms: &[crate::ast::MatchArm]) -> String {
        // Try to infer the enum type from the scrutinee for pattern qualification
        let enum_type_hint = self.infer_enum_type_from_scrutinee(scrutinee);

        // Check if any arm has a string literal pattern - if so, we need .as_str()
        let has_string_patterns = self.has_string_literal_patterns(arms);

        // For flat enum genes, strip the .type/.kind field access from scrutinee
        // e.g., `match ty.type { ... }` becomes `match ty { ... }` for flat enums
        let scrutinee_code = if let Expr::Member { object, field } = scrutinee {
            let field_name = field.trim_start_matches("r#");
            let object_expr: &Expr = object;
            if (field_name == "type" || field_name == "kind")
                && self.is_flat_enum_scrutinee(object_expr)
            {
                // Just use the object, not the field access
                self.gen_expr(object_expr)
            } else {
                self.gen_expr(scrutinee)
            }
        } else if let Expr::Identifier(name) = scrutinee {
            // DOL parser may parse "ty.type" as a single identifier with a dot
            // Check if it ends with .type or .kind and strip for flat enums
            if let Some((var_name, field_name)) = name.rsplit_once('.') {
                let field_name = field_name.trim_start_matches("r#");
                if (field_name == "type" || field_name == "kind")
                    && self.is_flat_enum_var_name(var_name)
                {
                    // Just use the variable name, not the .type field access
                    var_name.to_string()
                } else {
                    self.gen_expr(scrutinee)
                }
            } else {
                self.gen_expr(scrutinee)
            }
        } else {
            self.gen_expr(scrutinee)
        };

        let arms_code: Vec<String> = arms
            .iter()
            .map(|arm| {
                let pattern = self.gen_pattern_with_hint(&arm.pattern, enum_type_hint.as_deref());
                let guard = arm
                    .guard
                    .as_ref()
                    .map(|g| format!(" if {}", self.gen_expr(g)))
                    .unwrap_or_default();
                let body = self.gen_expr(&arm.body);
                format!("{}{} => {}", pattern, guard, body)
            })
            .collect();
        // Add .as_str() for String scrutinees when matching against string patterns
        let final_scrutinee = if has_string_patterns {
            format!("{}.as_str()", scrutinee_code)
        } else {
            scrutinee_code
        };

        format!(
            "match {} {{\n    {}\n}}",
            final_scrutinee,
            arms_code.join(",\n    ")
        )
    }

    /// Check if any match arm has a string literal pattern
    fn has_string_literal_patterns(&self, arms: &[crate::ast::MatchArm]) -> bool {
        arms.iter()
            .any(|arm| self.is_string_literal_pattern(&arm.pattern))
    }

    /// Check if a pattern is a string literal
    fn is_string_literal_pattern(&self, pattern: &crate::ast::Pattern) -> bool {
        matches!(pattern, crate::ast::Pattern::Literal(Literal::String(_)))
    }

    /// Try to infer the enum type from a scrutinee expression.
    /// This helps qualify unqualified enum variant patterns.
    fn infer_enum_type_from_scrutinee(&self, expr: &Expr) -> Option<String> {
        match expr {
            // If scrutinee is x.type or x.r#type, derive enum type from parent struct
            Expr::Member { object, field } => {
                let field_name = field.trim_start_matches("r#");
                // For field access on known types, infer the field's enum type
                if field_name == "type" || field_name == "kind" {
                    // Try to infer parent type from the object expression
                    if let Some(parent_type) = self.infer_parent_type(object) {
                        // For flat enum genes, the gene name IS the enum name
                        // (no separate *Type enum is generated)
                        let flat_enum_genes = [
                            "Expr",
                            "Stmt",
                            "Decl",
                            "TypeExpr",
                            "Pattern",
                            "TokenKind",
                            "Type",
                        ];
                        if flat_enum_genes.contains(&parent_type.as_str()) {
                            return Some(parent_type);
                        }
                        // For non-flat enums, the inline enum name is ParentFieldName
                        return Some(format!("{}{}", parent_type, to_pascal_case(field_name)));
                    }
                }
                None
            }
            // If scrutinee is a simple identifier, try common type mappings
            Expr::Identifier(name) => {
                // Handle qualified identifiers like "ty.type"
                if name.contains('.') {
                    let parts: Vec<&str> = name.split('.').collect();
                    if parts.len() >= 2 {
                        let field_name = parts.last().unwrap().trim_start_matches("r#");
                        if field_name == "type" || field_name == "kind" {
                            // Infer from the variable name pattern
                            let var_name = parts[parts.len() - 2];
                            if let Some(parent_type) = self.var_name_to_type(var_name) {
                                // For flat enum genes, the gene name IS the enum name
                                let flat_enum_genes = [
                                    "Expr",
                                    "Stmt",
                                    "Decl",
                                    "TypeExpr",
                                    "Pattern",
                                    "TokenKind",
                                    "Type",
                                ];
                                if flat_enum_genes.contains(&parent_type.as_str()) {
                                    return Some(parent_type);
                                }
                                // For non-flat enums, the inline enum name is ParentFieldName
                                return Some(format!(
                                    "{}{}",
                                    parent_type,
                                    to_pascal_case(field_name)
                                ));
                            }
                        }
                    }
                }
                // Common parameter patterns that indicate enum types
                match name.as_str() {
                    "ty" | "ty_" | "type_" => Some("Type".to_string()),
                    "token" | "tok" => Some("TokenKind".to_string()),
                    "op" => Some("BinOp".to_string()),
                    "stmt" | "statement" => Some("Stmt".to_string()),
                    "expr" | "expression" => Some("Expr".to_string()),
                    "decl" | "declaration" => Some("Decl".to_string()),
                    "pattern" | "pat" => Some("Pattern".to_string()),
                    _ => None,
                }
            }
            _ => None,
        }
    }

    /// Try to infer the parent type from an expression (for member access).
    fn infer_parent_type(&self, expr: &Expr) -> Option<String> {
        match expr {
            Expr::Identifier(name) => self.var_name_to_type(name),
            _ => None,
        }
    }

    /// Check if an expression represents a flat enum type (for stripping .type/.kind access).
    fn is_flat_enum_scrutinee(&self, expr: &Expr) -> bool {
        if let Some(parent_type) = self.infer_parent_type(expr) {
            let flat_enum_genes = [
                "Expr",
                "Stmt",
                "Decl",
                "TypeExpr",
                "Pattern",
                "TokenKind",
                "Type",
            ];
            return flat_enum_genes.contains(&parent_type.as_str());
        }
        false
    }

    /// Check if a variable name refers to a flat enum type.
    fn is_flat_enum_var_name(&self, var_name: &str) -> bool {
        if let Some(parent_type) = self.var_name_to_type(var_name) {
            let flat_enum_genes = [
                "Expr",
                "Stmt",
                "Decl",
                "TypeExpr",
                "Pattern",
                "TokenKind",
                "Type",
            ];
            return flat_enum_genes.contains(&parent_type.as_str());
        }
        false
    }

    /// Map common variable names to their type names.
    fn var_name_to_type(&self, name: &str) -> Option<String> {
        match name {
            "ty" | "ty_" | "type_" | "type_expr" | "type_annotation" => {
                Some("TypeExpr".to_string())
            }
            "expr" | "e" | "expression" => Some("Expr".to_string()),
            "stmt" | "statement" | "s" => Some("Stmt".to_string()),
            "decl" | "declaration" | "d" => Some("Decl".to_string()),
            "token" | "tok" | "t" => Some("Token".to_string()),
            "pattern" | "pat" | "p" => Some("Pattern".to_string()),
            _ => None,
        }
    }

    /// Generate a pattern with an optional enum type hint for qualification.
    fn gen_pattern_with_hint(
        &self,
        pattern: &crate::ast::Pattern,
        enum_type_hint: Option<&str>,
    ) -> String {
        match pattern {
            crate::ast::Pattern::Wildcard => "_".to_string(),
            crate::ast::Pattern::Identifier(name) => {
                // Convert DOL's Type.Variant to Rust's Type::Variant for qualified patterns
                let (qualified, variant_only) = if name.contains('.') {
                    let parts: Vec<&str> = name.split('.').collect();
                    let variant = parts.last().unwrap_or(&name.as_str()).to_string();
                    (name.replace('.', "::"), variant)
                } else if self.should_qualify_pattern(name, enum_type_hint) {
                    // Qualify unqualified enum variant patterns
                    if let Some(hint) = enum_type_hint {
                        (format!("{}::{}", hint, name), name.clone())
                    } else {
                        // Try to infer from known variant names
                        let q = self.qualify_known_variant(name);
                        (q, name.clone())
                    }
                } else {
                    (name.clone(), name.clone())
                };
                // Check if this is a struct variant that needs { .. }
                // All flat enum variants in DOL become struct variants with span field
                let needs_struct_match =
                    self.is_struct_variant_pattern(&qualified, &variant_only, enum_type_hint);
                if needs_struct_match {
                    format!("{} {{ .. }}", qualified)
                } else {
                    qualified
                }
            }
            crate::ast::Pattern::Literal(lit) => self.gen_literal_pattern(lit),
            crate::ast::Pattern::Constructor { name, fields } => {
                // Convert DOL's Type.Variant to Rust's Type::Variant
                // With flat enums, use gene name directly (e.g., Decl.Gene -> Decl::Gene)
                let (enum_name, variant_name) = if name.contains('.') {
                    let parts: Vec<&str> = name.split('.').collect();
                    if parts.len() == 2 {
                        (parts[0].to_string(), parts[1].to_string())
                    } else {
                        (String::new(), name.replace('.', "::"))
                    }
                } else if self.should_qualify_pattern(name, enum_type_hint) {
                    if let Some(hint) = enum_type_hint {
                        (hint.to_string(), name.clone())
                    } else {
                        let qualified = self.qualify_known_variant(name);
                        if qualified.contains("::") {
                            let parts: Vec<&str> = qualified.split("::").collect();
                            (parts[0].to_string(), parts[1].to_string())
                        } else {
                            (String::new(), qualified)
                        }
                    }
                } else {
                    (String::new(), name.clone())
                };

                // Build the full qualified name
                let rust_name = if enum_name.is_empty() {
                    variant_name.clone()
                } else {
                    format!("{}::{}", enum_name, variant_name)
                };

                if fields.is_empty() {
                    // Check if this is a tuple variant with a wrapper type
                    if let Some(wrapper_type) =
                        self.get_tuple_variant_wrapper(&enum_name, &variant_name)
                    {
                        // Tuple variant with no field bindings - use wildcard
                        format!("{}({} {{ .. }})", rust_name, wrapper_type)
                    } else if let Some(field_names) =
                        self.get_variant_fields(&enum_name, &variant_name)
                    {
                        if field_names.is_empty() {
                            // Unit-like variant in Rust
                            rust_name
                        } else {
                            // Struct variant with fields - need { .. } to match
                            format!("{} {{ .. }}", rust_name)
                        }
                    } else {
                        // Check if it's a known struct variant
                        let enum_hint = if enum_name.is_empty() {
                            None
                        } else {
                            Some(enum_name.as_str())
                        };
                        if self.is_struct_variant_pattern(&rust_name, &variant_name, enum_hint) {
                            format!("{} {{ .. }}", rust_name)
                        } else {
                            rust_name
                        }
                    }
                } else {
                    // Check if this is a tuple variant with a wrapper type
                    if let Some(wrapper_type) =
                        self.get_tuple_variant_wrapper(&enum_name, &variant_name)
                    {
                        // Generate tuple variant pattern: Enum::Variant(WrapperType { fields, .. })
                        if let Some(field_names) =
                            self.get_variant_fields(&enum_name, &variant_name)
                        {
                            let field_bindings: Vec<String> = fields
                                .iter()
                                .zip(field_names.iter())
                                .map(|(p, field_name)| {
                                    // Handle DOL's "field: _" pattern which parses as Constructor { name: "field", fields: [Wildcard] }
                                    if let crate::ast::Pattern::Constructor {
                                        name: pat_name,
                                        fields: inner_fields,
                                    } = p
                                    {
                                        if inner_fields.len() == 1
                                            && matches!(
                                                inner_fields[0],
                                                crate::ast::Pattern::Wildcard
                                            )
                                            && pat_name == *field_name
                                        {
                                            // This is "field: _" - just bind the field to wildcard
                                            return format!("{}: _", field_name);
                                        }
                                    }
                                    let pattern = self.gen_pattern_with_hint(p, None);
                                    if pattern == "_" {
                                        format!("{}: _", field_name)
                                    } else {
                                        format!("{}: {}", field_name, pattern)
                                    }
                                })
                                .collect();
                            // Avoid ", .." when field_bindings is empty
                            if field_bindings.is_empty() {
                                format!("{}({} {{ .. }})", rust_name, wrapper_type)
                            } else {
                                format!(
                                    "{}({} {{ {}, .. }})",
                                    rust_name,
                                    wrapper_type,
                                    field_bindings.join(", ")
                                )
                            }
                        } else {
                            // No known fields, just use wildcard inner pattern
                            format!("{}({})", rust_name, wrapper_type)
                        }
                    } else if let Some(field_names) =
                        self.get_variant_fields(&enum_name, &variant_name)
                    {
                        // Struct variant with known fields
                        let field_bindings: Vec<String> = fields
                            .iter()
                            .zip(field_names.iter())
                            .map(|(p, field_name)| {
                                // Handle DOL's "field: _" pattern which parses as Constructor { name: "field", fields: [Wildcard] }
                                if let crate::ast::Pattern::Constructor {
                                    name: pat_name,
                                    fields: inner_fields,
                                } = p
                                {
                                    if inner_fields.len() == 1
                                        && matches!(inner_fields[0], crate::ast::Pattern::Wildcard)
                                        && pat_name == *field_name
                                    {
                                        // This is "field: _" - just bind the field to wildcard
                                        return format!("{}: _", field_name);
                                    }
                                }
                                let pattern = self.gen_pattern_with_hint(p, None);
                                // Use field: pattern syntax for all cases
                                format!("{}: {}", field_name, pattern)
                            })
                            .collect();
                        // Add `..` to ignore extra fields like `span`
                        // Avoid ", .." when field_bindings is empty
                        if field_bindings.is_empty() {
                            format!("{} {{ .. }}", rust_name)
                        } else {
                            format!("{} {{ {}, .. }}", rust_name, field_bindings.join(", "))
                        }
                    } else {
                        // Fall back to tuple-style pattern for unknown variants
                        let fields_str: Vec<String> = fields
                            .iter()
                            .map(|p| self.gen_pattern_with_hint(p, None))
                            .collect();
                        format!("{}({})", rust_name, fields_str.join(", "))
                    }
                }
            }
            crate::ast::Pattern::Tuple(patterns) => {
                let patterns_str: Vec<String> = patterns
                    .iter()
                    .map(|p| self.gen_pattern_with_hint(p, None))
                    .collect();
                format!("({})", patterns_str.join(", "))
            }
            crate::ast::Pattern::Or(patterns) => {
                let patterns_str: Vec<String> = patterns
                    .iter()
                    .map(|p| self.gen_pattern_with_hint(p, enum_type_hint))
                    .collect();
                patterns_str.join(" | ")
            }
        }
    }

    /// Check if a pattern name should be qualified as an enum variant.
    fn should_qualify_pattern(&self, name: &str, _enum_type_hint: Option<&str>) -> bool {
        // If it starts with uppercase and is not a qualified name, it's likely an enum variant
        name.chars()
            .next()
            .is_some_and(|c| c.is_uppercase() && c.is_ascii())
    }

    /// Check if a pattern needs { .. } to match a struct variant.
    fn is_struct_variant_pattern(
        &self,
        qualified: &str,
        variant_name: &str,
        enum_type_hint: Option<&str>,
    ) -> bool {
        // First check if this is a tuple variant - those don't need { .. }
        let enum_name = if let Some(hint) = enum_type_hint {
            hint.to_string()
        } else if qualified.contains("::") {
            qualified.split("::").next().unwrap_or("").to_string()
        } else {
            String::new()
        };
        if self
            .get_tuple_variant_wrapper(&enum_name, variant_name)
            .is_some()
        {
            return false;
        }

        // TypeExpr primitive types (all have span field)
        let typeexpr_primitives = [
            "Int8", "Int16", "Int32", "Int64", "UInt8", "UInt16", "UInt32", "UInt64", "Float32",
            "Float64", "Bool", "String", "Char", "Void", "Never", "Infer",
        ];
        if typeexpr_primitives.contains(&variant_name)
            && (enum_type_hint == Some("TypeExpr") || qualified.starts_with("TypeExpr::"))
        {
            return true;
        }

        // Stmt remaining struct variants (Labeled, Item, Empty - not the tuple variants)
        if qualified.starts_with("Stmt::") || enum_type_hint == Some("Stmt") {
            let stmt_struct_variants = ["Labeled", "Item", "Empty"];
            if stmt_struct_variants.contains(&variant_name) {
                return true;
            }
        }

        // Expr remaining struct variants (literals, paths, etc. - not the tuple variants)
        // Tuple variants are already handled above, so check for struct-only variants
        if qualified.starts_with("Expr::") || enum_type_hint == Some("Expr") {
            // Most literal variants and some other variants are still struct variants
            let expr_struct_variants = [
                "IntLit",
                "UIntLit",
                "FloatLit",
                "StringLit",
                "CharLit",
                "BoolLit",
                "NullLit",
                "Ident",
                "Path",
                "Range",
                "TupleLit",
                "ArrayRepeat",
                "BlockLambda",
                "Block",
                "Cast",
                "Ascription",
                "SizeOf",
                "Eval",
                "QuasiQuote",
                "Unquote",
                "Reflect",
                "IdiomBracket",
                "MacroCall",
                "Error",
            ];
            if expr_struct_variants.contains(&variant_name) {
                return true;
            }
        }

        // Pattern variants
        if (qualified.starts_with("Pattern::") || enum_type_hint == Some("Pattern"))
            && variant_name == "Wildcard"
        {
            return true;
        }

        // Visibility variants
        if qualified.starts_with("Visibility::") || enum_type_hint == Some("Visibility") {
            let visibility_variants = ["Private", "Public", "Protected", "Internal"];
            if visibility_variants.contains(&variant_name) {
                return true;
            }
        }

        // Type variants that have fields
        if qualified.starts_with("Type::") || enum_type_hint == Some("Type") {
            let type_struct_variants = [
                "Int8", "Int16", "Int32", "Int64", "UInt8", "UInt16", "UInt32", "UInt64",
                "Float32", "Float64", "Bool", "String", "Char", "Unit", "Void", "Never", "Unknown",
                "Error", "Var",
            ];
            if type_struct_variants.contains(&variant_name) {
                return true;
            }
        }

        false
    }

    /// Try to qualify a known enum variant name based on common patterns.
    fn qualify_known_variant(&self, name: &str) -> String {
        // Known Type variants (exclude Var which is also in TokenKind)
        let type_variants = [
            "Int8", "Int16", "Int32", "Int64", "UInt8", "UInt16", "UInt32", "UInt64", "Float32",
            "Float64", "Bool", "String", "Void", "Char", "Unit", "Never", "Unknown", "Error",
            "Function", "Tuple", "Generic", "Named",
        ];
        if type_variants.contains(&name) {
            return format!("Type::{}", name);
        }

        // Known TypeExprType variants (from inline enum in ast.dol)
        let _type_expr_type_variants = [
            "Int8", "Int16", "Int32", "Int64", "UInt8", "UInt16", "UInt32", "UInt64", "Float32",
            "Float64", "Bool", "String", "Char", "Void", "Named", "Generic", "Function", "Tuple",
            "Option", "Result", "List", "Map", "Set", "Box", "Array", "Infer", "Never",
        ];
        // TypeExprType takes precedence in certain contexts
        // For now, default to Type:: since that's more common in the DOL source

        // Known TokenKind variants
        let token_variants = [
            "Plus",
            "Minus",
            "Star",
            "Slash",
            "Percent",
            "And",
            "Or",
            "Not",
            "Eq",
            "Ne",
            "Lt",
            "Le",
            "Gt",
            "Ge",
            "Assign",
            "Arrow",
            "FatArrow",
            "Dot",
            "Comma",
            "Colon",
            "Semi",
            "LParen",
            "RParen",
            "LBrace",
            "RBrace",
            "LBracket",
            "RBracket",
            "Eof",
            "Newline",
            "Ident",
            "IntLit",
            "FloatLit",
            "StringLit",
            "CharLit",
            // Additional tokens
            "Pipe",
            "BackPipe",
            "Compose",
            "Bind",
            "Apply",
            "StarStar",
            "At",
            "Question",
            "Bang",
            "Quote",
            "Hash",
            "Dollar",
            "Ampersand",
            "Caret",
            "Tilde",
            "Underscore",
            "ColonColon",
            "DotDot",
            "DotDotEq",
            "PlusEq",
            "MinusEq",
            "StarEq",
            "SlashEq",
            "PercentEq",
            "AndAnd",
            "OrOr",
            "Shl",
            "Shr",
            "ShlEq",
            "ShrEq",
            "EqEq",
            "NotEq",
            "LtEq",
            "GtEq",
            "AndEq",
            "OrEq",
            "CaretEq",
            // Keyword tokens (must be before DeclType check since keywords are more common)
            "Module",
            "Use",
            "Pub",
            "Gene",
            "Trait",
            "System",
            "Constraint",
            "Evolves",
            "Fun",
            "Exegesis",
            "Let",
            "Const",
            "If",
            "Else",
            "Match",
            "For",
            "While",
            "Loop",
            "Return",
            "Break",
            "Continue",
            "True",
            "False",
            "Null",
            "This",
            "Self_",
            "As",
            "Is",
            "Has",
            "Where",
            "Law",
            "Sex",
            "Extern",
            "Impl",
            "Struct",
            "Enum",
            "Type",
            "Fn",
            "Var",
            "Static",
            "Mut",
            "Ref",
            "Semicolon",
            "LSquare",
            "RSquare",
            "LCurly",
            "RCurly",
            "LeftParen",
            "RightParen",
            "LeftBrace",
            "RightBrace",
            "LeftBracket",
            "RightBracket",
        ];
        if token_variants.contains(&name) {
            return format!("TokenKind::{}", name);
        }

        // Known ExprType variants (from DOL ast.dol inline enum)
        // These are the variants of the inline enum in the Expr gene
        let expr_type_variants = [
            "IntLit",
            "UIntLit",
            "FloatLit",
            "StringLit",
            "CharLit",
            "BoolLit",
            "NullLit",
            "Ident",
            "Path",
            "Binary",
            "Unary",
            "Call",
            "MethodCall",
            "Field",
            "Index",
            "If",
            "Match",
            "Block",
            "Lambda",
            "Closure",
            "Struct",
            "List",
            "Tuple",
            "Range",
            "Return",
            "Break",
            "Continue",
            "Throw",
            "Try",
            "Await",
            "Yield",
            "Quote",
            "Unquote",
            "Macro",
        ];
        if expr_type_variants.contains(&name) {
            return format!("ExprType::{}", name);
        }

        // Legacy Expr variants (from Rust AST representation)
        let expr_variants = ["Literal", "Identifier", "Member", "Array"];
        if expr_variants.contains(&name) {
            return format!("Expr::{}", name);
        }

        // Known StmtType variants (from DOL ast.dol inline enum)
        let stmt_type_variants = [
            "Let", "Const", "Assign", "Expr", "Return", "If", "While", "For", "Loop", "Break",
            "Continue", "Block", "Match", "Throw", "Try",
        ];
        if stmt_type_variants.contains(&name) {
            return format!("StmtType::{}", name);
        }

        // Known DeclType variants (from DOL ast.dol inline enum)
        let decl_type_variants = [
            "Gene",
            "Trait",
            "Impl",
            "Function",
            "Const",
            "Static",
            "Use",
            "Module",
            "Enum",
            "Struct",
            "TypeAlias",
            "Extern",
            "Constraint",
            "System",
            "Evolution",
        ];
        if decl_type_variants.contains(&name) {
            return format!("DeclType::{}", name);
        }

        // Known PatternType variants (from DOL ast.dol inline enum)
        let pattern_type_variants = [
            "Wildcard", "Binding", "Literal", "Tuple", "Struct", "Enum", "Or", "Guard", "Rest",
            "Path", "Range",
        ];
        if pattern_type_variants.contains(&name) {
            return format!("PatternType::{}", name);
        }

        // Known BinOp variants
        let binop_variants = [
            "Add", "Sub", "Mul", "Div", "Mod", "And", "Or", "Eq", "Ne", "Lt", "Le", "Gt", "Ge",
            "BitAnd", "BitOr", "BitXor", "Shl", "Shr",
        ];
        if binop_variants.contains(&name) {
            return format!("BinOp::{}", name);
        }

        // Known Option/Result variants
        if name == "Some" || name == "None" {
            return name.to_string(); // These are already in scope in Rust
        }
        if name == "Ok" || name == "Err" {
            return name.to_string(); // These are already in scope in Rust
        }

        // Default: don't qualify (might be a local binding)
        name.to_string()
    }

    // === Meta-Programming Code Generation ===

    /// Generate Rust code for a quote expression.
    ///
    /// Converts an expression to a QuotedExpr literal that can be manipulated at runtime.
    ///
    /// # Arguments
    ///
    /// * `expr` - The expression to quote
    ///
    /// # Returns
    ///
    /// Rust code that creates a QuotedExpr from the expression
    ///
    /// # Example
    ///
    /// ```ignore
    /// // '(1 + 2) => QuotedExpr::from_expr(&Expr::Binary { ... })
    /// ```
    fn gen_quote(&self, expr: &Expr) -> String {
        // Convert expression to QuotedExpr literal
        format!("QuotedExpr::from_expr(&{})", self.gen_expr(expr))
    }

    /// Generate Rust code for an eval expression.
    ///
    /// Evaluates a quoted expression at runtime.
    ///
    /// # Arguments
    ///
    /// * `expr` - The expression containing the quoted code to evaluate
    ///
    /// # Returns
    ///
    /// Rust code that evaluates the expression
    ///
    /// # Example
    ///
    /// ```ignore
    /// // eval(quoted_expr) => eval(quoted_expr)
    /// ```
    fn gen_eval(&self, expr: &Expr) -> String {
        format!("eval({})", self.gen_expr(expr))
    }

    /// Generate Rust code for type reflection.
    ///
    /// Generates code that retrieves type information at runtime.
    ///
    /// # Arguments
    ///
    /// * `ty` - The type to reflect on
    ///
    /// # Returns
    ///
    /// Rust code that gets type information
    ///
    /// # Example
    ///
    /// ```ignore
    /// // ?Int32 => TypeInfo::get::<i32>()
    /// ```
    fn gen_reflect(&self, ty: &TypeExpr) -> String {
        format!("TypeInfo::get::<{}>()", self.gen_type(ty))
    }

    /// Generate Rust code for a quasi-quote expression.
    ///
    /// Similar to quote but allows unquote/splice operations inside.
    ///
    /// # Arguments
    ///
    /// * `expr` - The expression to quasi-quote
    ///
    /// # Returns
    ///
    /// Rust code for the quasi-quoted expression
    ///
    /// # Example
    ///
    /// ```ignore
    /// // `(1 + ,x) => allows unquoting x inside the quote
    /// ```
    fn gen_quasi_quote(&self, expr: &Expr) -> String {
        // Similar to quote but supports unquotes
        format!("QuotedExpr::from_expr(&{})", self.gen_expr(expr))
    }

    /// Generate Rust code for an unquote/splice expression.
    ///
    /// Splices an evaluated expression into a quasi-quoted context.
    ///
    /// # Arguments
    ///
    /// * `expr` - The expression to unquote
    ///
    /// # Returns
    ///
    /// Rust code for the unquoted expression
    ///
    /// # Example
    ///
    /// ```ignore
    /// // ,x inside a quasi-quote evaluates x and splices it in
    /// ```
    fn gen_unquote(&self, expr: &Expr) -> String {
        // Unquote evaluates and splices the expression
        self.gen_expr(expr)
    }

    /// Generate Rust code for idiom bracket expressions.
    ///
    /// Idiom brackets provide applicative functor style: [| f a b |] desugars to f <$> a <*> b
    ///
    /// # Arguments
    ///
    /// * `func` - The function to apply
    /// * `args` - The arguments to lift and apply
    ///
    /// # Returns
    ///
    /// Rust code for the applicative style expression
    ///
    /// # Example
    ///
    /// ```ignore
    /// // [| f a b |] => a.map(f).ap(b)
    /// // [| f |] => f (no lifting needed)
    /// ```
    fn gen_idiom_bracket(&self, func: &Expr, args: &[Expr]) -> String {
        if args.is_empty() {
            // No arguments, just return the function
            self.gen_expr(func)
        } else {
            // [| f a b c |] desugars to f <$> a <*> b <*> c
            // In Rust: a.map(f).ap(b).ap(c)
            let mut result = format!("{}.map({})", self.gen_expr(&args[0]), self.gen_expr(func));
            for arg in args.iter().skip(1) {
                result = format!("{}.ap({})", result, self.gen_expr(arg));
            }
            result
        }
    }

    /// Generate TypeInfo registration code for a gene.
    ///
    /// This generates code that registers runtime type information
    /// for reflection and introspection.
    ///
    /// # Arguments
    ///
    /// * `gene` - The gene declaration to generate TypeInfo for
    ///
    /// # Returns
    ///
    /// Rust code that creates and registers a TypeInfo instance
    ///
    /// # Example Output
    ///
    /// ```ignore
    /// TypeInfo::record("User")
    ///     .with_field(FieldInfo::new("id", "Int64"))
    ///     .with_field(FieldInfo::new("name", "String"))
    ///     .with_doc("A user entity")
    /// ```
    pub fn gen_type_info(&self, gene: &Gene) -> String {
        let type_name = to_pascal_case(&gene.name);
        let mut output = String::new();

        // Start TypeInfo::record call
        output.push_str(&format!("    TypeInfo::record(\"{}\")\n", type_name));

        // Add fields from "has" statements
        for stmt in &gene.statements {
            if let Statement::Has { property, .. } = stmt {
                let field_name = to_snake_case(property);
                // Default to String type - in a full implementation we'd infer types
                output.push_str(&format!(
                    "        .with_field(FieldInfo::new(\"{}\", \"String\"))\n",
                    field_name
                ));
            }
        }

        // Add documentation from exegesis
        if !gene.exegesis.trim().is_empty() {
            let escaped_doc = gene.exegesis.replace('\"', "\\\"").replace('\n', " ");
            output.push_str(&format!("        .with_doc(\"{}\")", escaped_doc));
        }

        output
    }

    /// Generate TypeInfo registration for all declarations in a module.
    ///
    /// This generates a function that populates a TypeRegistry with
    /// type information for all genes and types in the module.
    ///
    /// # Arguments
    ///
    /// * `decls` - The declarations to generate registration code for
    ///
    /// # Returns
    ///
    /// Rust code that defines a registration function
    pub fn gen_type_registry(&self, decls: &[Declaration]) -> String {
        let mut output = String::new();

        output.push_str("/// Register all type information in the type registry.\n");
        output.push_str("pub fn register_types(registry: &mut TypeRegistry) {\n");

        for decl in decls {
            if let Declaration::Gene(gene) = decl {
                output.push_str(&format!(
                    "    registry.register(\n{}\n    );\n\n",
                    self.gen_type_info(gene)
                ));
            }
        }

        output.push_str("}\n");
        output
    }

    /// Check if a gene has an inline enum 'type' field (the DOL idiom for enums)
    /// Returns Some((variants, extra_fields)) if this gene should be generated as a flat enum
    #[allow(clippy::type_complexity)]
    fn is_enum_gene(gene: &Gene) -> Option<(&Vec<EnumVariant>, Vec<(&str, String)>)> {
        let fields: Vec<_> = gene
            .statements
            .iter()
            .filter_map(|stmt| {
                if let Statement::HasField(field) = stmt {
                    Some(field.as_ref())
                } else {
                    None
                }
            })
            .collect();

        // Look for a 'type' field with enum type
        let mut enum_variants = None;
        let mut extra_fields = Vec::new();

        for field in &fields {
            if field.name == "type" {
                if let TypeExpr::Enum { variants } = &field.type_ {
                    enum_variants = Some(variants);
                }
            } else {
                // Collect other fields (like 'span') to add to each variant
                extra_fields.push((field.name.as_str(), Self::map_type_expr(&field.type_)));
            }
        }

        enum_variants.map(|variants| (variants, extra_fields))
    }

    /// Generate a Rust enum from a gene with inline enum type
    /// extra_fields are fields like 'span' that should be added to each variant
    fn gen_enum_from_gene(
        &self,
        gene: &Gene,
        variants: &[EnumVariant],
        extra_fields: &[(&str, String)],
    ) -> String {
        let enum_name = to_pascal_case(&gene.name);
        let visibility = self.visibility_str();

        let mut output = String::new();

        // Doc comment from exegesis
        output.push_str(&self.format_doc_comment(&gene.exegesis));

        // Derive macros
        let derives = self.derive_clause();
        if !derives.is_empty() {
            output.push_str(&format!("#[derive({})]\n", derives));
        }

        // Enum definition - gene name becomes enum name directly
        output.push_str(&format!("{visibility}enum {enum_name} {{\n"));

        for variant in variants {
            let rust_variant = to_pascal_case(&variant.name);
            let has_struct_fields = !variant.fields.is_empty() || !extra_fields.is_empty();
            let has_tuple_types = !variant.tuple_types.is_empty();

            if has_tuple_types {
                // Tuple variant like Let(LetStmt) or Binary(BinaryExpr)
                let types: Vec<String> = variant
                    .tuple_types
                    .iter()
                    .map(Self::map_type_expr)
                    .collect();
                output.push_str(&format!("    {rust_variant}({}),\n", types.join(", ")));
            } else if !has_struct_fields {
                // Simple variant without fields
                output.push_str(&format!("    {rust_variant},\n"));
            } else {
                // Struct variant with fields
                output.push_str(&format!("    {rust_variant} {{\n"));
                // Add variant-specific fields first
                for (field_name, field_type) in &variant.fields {
                    let rust_field = to_rust_ident(field_name);
                    let rust_type = Self::map_type_expr(field_type);
                    output.push_str(&format!("        {rust_field}: {rust_type},\n"));
                }
                // Add extra fields (like span) to each variant
                for (field_name, field_type) in extra_fields {
                    let rust_field = to_rust_ident(field_name);
                    output.push_str(&format!("        {rust_field}: {field_type},\n"));
                }
                output.push_str("    },\n");
            }
        }

        output.push_str("}\n\n");

        output
    }
}

impl Codegen for RustCodegen {
    fn generate(decl: &Declaration) -> String {
        RustCodegen::generate(decl)
    }
}

impl TypeMapper for RustCodegen {
    fn map_type(ty: &Type) -> String {
        match ty {
            Type::Void => "()".to_string(),
            Type::Bool => "bool".to_string(),
            Type::Int8 => "i8".to_string(),
            Type::Int16 => "i16".to_string(),
            Type::Int32 => "i32".to_string(),
            Type::Int64 => "i64".to_string(),
            Type::UInt8 => "u8".to_string(),
            Type::UInt16 => "u16".to_string(),
            Type::UInt32 => "u32".to_string(),
            Type::UInt64 => "isize".to_string(),
            Type::Float32 => "f32".to_string(),
            Type::Float64 => "f64".to_string(),
            Type::String => "String".to_string(),
            Type::Function {
                params,
                return_type,
            } => {
                let param_types: Vec<_> = params.iter().map(Self::map_type).collect();
                let ret = Self::map_type(return_type);
                format!("fn({}) -> {}", param_types.join(", "), ret)
            }
            Type::Tuple(types) => {
                let mapped: Vec<_> = types.iter().map(Self::map_type).collect();
                format!("({})", mapped.join(", "))
            }
            Type::Generic { name, args } => {
                let mapped_args: Vec<_> = args.iter().map(Self::map_type).collect();
                // Map DOL generic types to Rust equivalents
                let rust_name = match name.as_str() {
                    "List" => "Vec",
                    "Map" => "std::collections::HashMap",
                    "Option" => "Option",
                    "Result" => "Result",
                    _ => name.as_str(),
                };
                if args.is_empty() {
                    to_pascal_case(name)
                } else {
                    format!("{}<{}>", rust_name, mapped_args.join(", "))
                }
            }
            Type::Var(id) => format!("T{}", id),
            Type::Any => "Box<dyn std::any::Any>".to_string(),
            Type::Unknown => "/* unknown */".to_string(),
            Type::Never => "!".to_string(),
            Type::Error => "/* error */".to_string(),
        }
    }

    fn map_type_expr(ty: &TypeExpr) -> String {
        match ty {
            TypeExpr::Named(name) => match name.as_str() {
                // DOL canonical types (PascalCase)
                "Int8" => "i8".to_string(),
                "Int16" => "i16".to_string(),
                "Int32" => "i32".to_string(),
                "Int64" => "i64".to_string(),
                "UInt8" => "u8".to_string(),
                "UInt16" => "u16".to_string(),
                "UInt32" => "u32".to_string(),
                "UInt64" => "u64".to_string(),
                "Float32" => "f32".to_string(),
                "Float64" => "f64".to_string(),
                "String" => "String".to_string(),
                "Char" => "char".to_string(),
                "Bool" => "bool".to_string(),
                "Void" => "()".to_string(),
                // Rust-style aliases (for ergonomics in DOL source)
                "i8" => "i8".to_string(),
                "i16" => "i16".to_string(),
                "i32" => "i32".to_string(),
                "i64" => "i64".to_string(),
                "u8" => "u8".to_string(),
                "u16" => "u16".to_string(),
                "u32" => "u32".to_string(),
                "u64" => "u64".to_string(),
                "f32" => "f32".to_string(),
                "f64" => "f64".to_string(),
                "bool" => "bool".to_string(),
                "isize" => "isize".to_string(),
                "usize" => "usize".to_string(),
                _ => to_pascal_case(name),
            },
            TypeExpr::Generic { name, args } => {
                let mapped_args: Vec<_> = args.iter().map(Self::map_type_expr).collect();
                let rust_name = match name.as_str() {
                    "List" => "Vec",
                    "Map" => "std::collections::HashMap",
                    "Option" => "Option",
                    "Result" => "Result",
                    _ => name,
                };
                format!("{}<{}>", rust_name, mapped_args.join(", "))
            }
            TypeExpr::Function {
                params,
                return_type,
            } => {
                let param_types: Vec<_> = params.iter().map(Self::map_type_expr).collect();
                let ret = Self::map_type_expr(return_type);
                format!("fn({}) -> {}", param_types.join(", "), ret)
            }
            TypeExpr::Tuple(types) => {
                let mapped: Vec<_> = types.iter().map(Self::map_type_expr).collect();
                format!("({})", mapped.join(", "))
            }
            TypeExpr::Never => "!".to_string(),
            TypeExpr::Enum { variants } => {
                // Inline enums should be extracted and generated separately
                // This fallback generates a placeholder comment listing variants
                let variant_names: Vec<_> = variants.iter().map(|v| v.name.as_str()).collect();
                format!("/* inline enum: {} */", variant_names.join(" | "))
            }
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::ast::Span;

    #[test]
    fn test_generate_gene_struct() {
        let gene = Gene {
            name: "container.exists".to_string(),
            extends: None,
            statements: vec![
                Statement::Has {
                    subject: "container".to_string(),
                    property: "id".to_string(),
                    span: Span::default(),
                },
                Statement::Has {
                    subject: "container".to_string(),
                    property: "image".to_string(),
                    span: Span::default(),
                },
            ],
            exegesis: "A container is the fundamental unit.".to_string(),
            span: Span::default(),
        };

        let code = RustCodegen::generate(&Declaration::Gene(gene));

        assert!(code.contains("pub struct ContainerExists"));
        assert!(code.contains("pub id: String"));
        assert!(code.contains("pub image: String"));
        assert!(code.contains("/// A container is the fundamental unit."));
    }

    #[test]
    fn test_generate_trait() {
        let trait_decl = Trait {
            name: "container.lifecycle".to_string(),
            statements: vec![
                Statement::Uses {
                    reference: "container.exists".to_string(),
                    span: Span::default(),
                },
                Statement::Is {
                    subject: "container".to_string(),
                    state: "created".to_string(),
                    span: Span::default(),
                },
                Statement::Is {
                    subject: "container".to_string(),
                    state: "started".to_string(),
                    span: Span::default(),
                },
            ],
            exegesis: "Container lifecycle management.".to_string(),
            span: Span::default(),
        };

        let code = RustCodegen::generate(&Declaration::Trait(trait_decl));

        assert!(code.contains("pub trait ContainerLifecycle: ContainerExists"));
        assert!(code.contains("fn is_created(&self) -> bool"));
        assert!(code.contains("fn is_started(&self) -> bool"));
    }

    #[test]
    fn test_map_type() {
        assert_eq!(RustCodegen::map_type(&Type::Int32), "i32");
        assert_eq!(RustCodegen::map_type(&Type::String), "String");
        assert_eq!(RustCodegen::map_type(&Type::Bool), "bool");
        assert_eq!(
            RustCodegen::map_type(&Type::Generic {
                name: "Option".to_string(),
                args: vec![Type::String]
            }),
            "Option<String>"
        );
        assert_eq!(
            RustCodegen::map_type(&Type::Generic {
                name: "List".to_string(),
                args: vec![Type::Int32]
            }),
            "Vec<i32>"
        );
        assert_eq!(
            RustCodegen::map_type(&Type::Generic {
                name: "Map".to_string(),
                args: vec![Type::String, Type::Int64]
            }),
            "std::collections::HashMap<String, i64>"
        );
    }

    #[test]
    fn test_map_type_expr() {
        assert_eq!(
            RustCodegen::map_type_expr(&TypeExpr::Named("Int32".to_string())),
            "i32"
        );
        assert_eq!(
            RustCodegen::map_type_expr(&TypeExpr::Generic {
                name: "List".to_string(),
                args: vec![TypeExpr::Named("String".to_string())]
            }),
            "Vec<String>"
        );
        assert_eq!(
            RustCodegen::map_type_expr(&TypeExpr::Generic {
                name: "Map".to_string(),
                args: vec![
                    TypeExpr::Named("String".to_string()),
                    TypeExpr::Named("Int32".to_string())
                ]
            }),
            "std::collections::HashMap<String, i32>"
        );
    }

    #[test]
    fn test_generate_constraint() {
        let constraint = Constraint {
            name: "container.integrity".to_string(),
            statements: vec![
                Statement::Matches {
                    subject: "state".to_string(),
                    target: "declared_state".to_string(),
                    span: Span::default(),
                },
                Statement::Never {
                    subject: "identity".to_string(),
                    action: "changes".to_string(),
                    span: Span::default(),
                },
            ],
            exegesis: "Container integrity constraints.".to_string(),
            span: Span::default(),
        };

        let code = RustCodegen::generate(&Declaration::Constraint(constraint));

        assert!(code.contains("fn validate_container_integrity"));
        assert!(code.contains("// state matches declared_state"));
        assert!(code.contains("// identity never changes"));
    }

    #[test]
    fn test_generate_system() {
        let system = System {
            name: "univrs.orchestrator".to_string(),
            version: "0.1.0".to_string(),
            requirements: vec![crate::ast::Requirement {
                name: "container.lifecycle".to_string(),
                constraint: ">=".to_string(),
                version: "0.0.2".to_string(),
                span: Span::default(),
            }],
            statements: vec![],
            exegesis: "The Univrs orchestrator.".to_string(),
            span: Span::default(),
        };

        let code = RustCodegen::generate(&Declaration::System(system));

        assert!(code.contains("pub mod univrs_orchestrator"));
        assert!(code.contains("/// System version: 0.1.0"));
        assert!(code.contains("`container.lifecycle` >= 0.0.2"));
    }

    // === SEX Code Generation Tests ===

    #[test]
    fn test_gen_type_primitives() {
        let gen = RustCodegen::new();

        assert_eq!(gen.gen_type(&TypeExpr::Named("Int32".to_string())), "i32");
        assert_eq!(gen.gen_type(&TypeExpr::Named("Int64".to_string())), "i64");
        assert_eq!(gen.gen_type(&TypeExpr::Named("Bool".to_string())), "bool");
        assert_eq!(
            gen.gen_type(&TypeExpr::Named("String".to_string())),
            "String"
        );
        assert_eq!(gen.gen_type(&TypeExpr::Named("Void".to_string())), "()");
    }

    #[test]
    fn test_gen_type_generic() {
        let gen = RustCodegen::new();

        let list_type = TypeExpr::Generic {
            name: "List".to_string(),
            args: vec![TypeExpr::Named("Int32".to_string())],
        };
        assert_eq!(gen.gen_type(&list_type), "Vec<i32>");
    }

    #[test]
    fn test_gen_constant() {
        let gen = RustCodegen::new();

        let var = VarDecl {
            mutability: Mutability::Immutable,
            name: "MAX_SIZE".to_string(),
            type_ann: Some(TypeExpr::Named("Int64".to_string())),
            value: Some(Expr::Literal(Literal::Int(100))),
            span: Span::default(),
        };

        let output = gen.gen_constant(&var);
        assert!(output.contains("const MAX_SIZE: i64 = 100_i64;"));
    }

    #[test]
    fn test_gen_global_var() {
        let gen = RustCodegen::new();

        let var = VarDecl {
            mutability: Mutability::Mutable,
            name: "counter".to_string(),
            type_ann: Some(TypeExpr::Named("Int64".to_string())),
            value: Some(Expr::Literal(Literal::Int(0))),
            span: Span::default(),
        };

        let output = gen.gen_global_var(&var);
        assert!(output.contains("static mut COUNTER: i64 = 0_i64;"));
    }

    #[test]
    fn test_gen_extern() {
        let gen = RustCodegen::new();

        let decl = ExternDecl {
            abi: Some("C".to_string()),
            name: "malloc".to_string(),
            params: vec![FunctionParam {
                name: "size".to_string(),
                type_ann: TypeExpr::Named("UInt64".to_string()),
            }],
            return_type: Some(TypeExpr::Generic {
                name: "Ptr".to_string(),
                args: vec![TypeExpr::Named("Void".to_string())],
            }),
            span: Span::default(),
        };

        let output = gen.gen_extern(&decl);
        assert!(output.contains("extern \"C\" {"));
        // Note: UInt64 maps to isize to handle DOL code that passes negative values
        assert!(output.contains("fn malloc(size: isize) -> Ptr<()>;"));
    }

    #[test]
    fn test_gen_global_access() {
        let gen = RustCodegen::new();
        assert_eq!(gen.gen_global_access("counter"), "unsafe { COUNTER }");
    }

    #[test]
    fn test_gen_global_mutation() {
        let gen = RustCodegen::new();
        assert_eq!(
            gen.gen_global_mutation("counter", "42"),
            "unsafe { COUNTER = 42; }"
        );
    }

    #[test]
    fn test_gen_literal() {
        let gen = RustCodegen::new();
        assert_eq!(gen.gen_literal(&Literal::Int(42)), "42_i64");
        assert_eq!(gen.gen_literal(&Literal::Float(2.5)), "2.5_f64");
        assert_eq!(gen.gen_literal(&Literal::Float(3.0)), "3.0_f64");
        assert_eq!(gen.gen_literal(&Literal::Bool(true)), "true");
        assert_eq!(
            gen.gen_literal(&Literal::String("hello".to_string())),
            "\"hello\".to_string()"
        );
        assert_eq!(gen.gen_literal(&Literal::Null), "None");
    }

    #[test]
    fn test_gen_visibility() {
        let gen = RustCodegen::new();
        assert_eq!(gen.gen_visibility(crate::ast::Visibility::Public), "pub ");
        assert_eq!(
            gen.gen_visibility(crate::ast::Visibility::PubSpirit),
            "pub(crate) "
        );
        assert_eq!(
            gen.gen_visibility(crate::ast::Visibility::PubParent),
            "pub(super) "
        );
        assert_eq!(gen.gen_visibility(crate::ast::Visibility::Private), "");
    }

    #[test]
    fn test_gen_sex_function() {
        let gen = RustCodegen::new();

        let func = FunctionDecl {
            visibility: crate::ast::Visibility::Public,
            purity: crate::ast::Purity::Sex,
            name: "mutate".to_string(),
            type_params: None,
            params: vec![FunctionParam {
                name: "x".to_string(),
                type_ann: TypeExpr::Named("Int32".to_string()),
            }],
            return_type: Some(TypeExpr::Named("Int32".to_string())),
            body: vec![Stmt::Return(Some(Expr::Binary {
                left: Box::new(Expr::Identifier("x".to_string())),
                op: crate::ast::BinaryOp::Add,
                right: Box::new(Expr::Literal(Literal::Int(1))),
            }))],
            exegesis: String::new(),
            span: Span::default(),
        };

        let output = gen.gen_sex_function(crate::ast::Visibility::Public, &func);
        assert!(output.contains("/// Side-effectful function"));
        assert!(output.contains("pub fn mutate(x: i32) -> i32"));
        assert!(output.contains("return (x + 1_i64);"));
    }

    #[test]
    fn test_gen_expr_binary() {
        let gen = RustCodegen::new();
        let expr = Expr::Binary {
            left: Box::new(Expr::Literal(Literal::Int(2))),
            op: crate::ast::BinaryOp::Mul,
            right: Box::new(Expr::Literal(Literal::Int(3))),
        };
        assert_eq!(gen.gen_expr(&expr), "(2_i64 * 3_i64)");
    }

    #[test]
    fn test_gen_expr_call() {
        let gen = RustCodegen::new();
        let expr = Expr::Call {
            callee: Box::new(Expr::Identifier("foo".to_string())),
            args: vec![
                Expr::Literal(Literal::Int(1)),
                Expr::Literal(Literal::Int(2)),
            ],
        };
        assert_eq!(gen.gen_expr(&expr), "foo(1_i64, 2_i64)");
    }

    // === Lambda Expression Tests ===

    #[test]
    fn test_gen_lambda_simple() {
        let gen = RustCodegen::new();
        let expr = Expr::Lambda {
            params: vec![("x".to_string(), None)],
            return_type: None,
            body: Box::new(Expr::Binary {
                left: Box::new(Expr::Identifier("x".to_string())),
                op: crate::ast::BinaryOp::Add,
                right: Box::new(Expr::Literal(Literal::Int(1))),
            }),
        };
        assert_eq!(gen.gen_expr(&expr), "|x| { (x + 1_i64) }");
    }

    #[test]
    fn test_gen_lambda_with_type() {
        let gen = RustCodegen::new();
        let expr = Expr::Lambda {
            params: vec![("x".to_string(), Some(TypeExpr::Named("Int32".to_string())))],
            return_type: None,
            body: Box::new(Expr::Binary {
                left: Box::new(Expr::Identifier("x".to_string())),
                op: crate::ast::BinaryOp::Mul,
                right: Box::new(Expr::Literal(Literal::Int(2))),
            }),
        };
        assert_eq!(gen.gen_expr(&expr), "|x: i32| { (x * 2_i64) }");
    }

    #[test]
    fn test_gen_lambda_multiple_params() {
        let gen = RustCodegen::new();
        let expr = Expr::Lambda {
            params: vec![
                ("x".to_string(), Some(TypeExpr::Named("Int32".to_string()))),
                ("y".to_string(), Some(TypeExpr::Named("Int32".to_string()))),
            ],
            return_type: None,
            body: Box::new(Expr::Binary {
                left: Box::new(Expr::Identifier("x".to_string())),
                op: crate::ast::BinaryOp::Add,
                right: Box::new(Expr::Identifier("y".to_string())),
            }),
        };
        assert_eq!(gen.gen_expr(&expr), "|x: i32, y: i32| { (x + y) }");
    }

    #[test]
    fn test_gen_lambda_with_return_type() {
        let gen = RustCodegen::new();
        let expr = Expr::Lambda {
            params: vec![("x".to_string(), Some(TypeExpr::Named("Int32".to_string())))],
            return_type: Some(TypeExpr::Named("Int32".to_string())),
            body: Box::new(Expr::Identifier("x".to_string())),
        };
        assert_eq!(gen.gen_expr(&expr), "|x: i32| -> i32 { x }");
    }

    #[test]
    fn test_gen_lambda_with_block_body() {
        let gen = RustCodegen::new();
        let expr = Expr::Lambda {
            params: vec![("x".to_string(), None)],
            return_type: None,
            body: Box::new(Expr::Block {
                statements: vec![Stmt::Let {
                    name: "doubled".to_string(),
                    type_ann: None,
                    value: Expr::Binary {
                        left: Box::new(Expr::Identifier("x".to_string())),
                        op: crate::ast::BinaryOp::Mul,
                        right: Box::new(Expr::Literal(Literal::Int(2))),
                    },
                }],
                final_expr: Some(Box::new(Expr::Identifier("doubled".to_string()))),
            }),
        };
        let result = gen.gen_expr(&expr);
        assert!(result.starts_with("|x| {"));
        assert!(result.contains("let mut doubled = (x * 2_i64);"));
        assert!(result.contains("doubled"));
    }

    #[test]
    fn test_gen_lambda_no_params() {
        let gen = RustCodegen::new();
        let expr = Expr::Lambda {
            params: vec![],
            return_type: None,
            body: Box::new(Expr::Literal(Literal::Int(42))),
        };
        assert_eq!(gen.gen_expr(&expr), "|| { 42_i64 }");
    }

    #[test]
    fn test_gen_lambda_nested() {
        let gen = RustCodegen::new();
        // Create a lambda that returns another lambda: |x| |y| x + y
        let inner_lambda = Expr::Lambda {
            params: vec![("y".to_string(), None)],
            return_type: None,
            body: Box::new(Expr::Binary {
                left: Box::new(Expr::Identifier("x".to_string())),
                op: crate::ast::BinaryOp::Add,
                right: Box::new(Expr::Identifier("y".to_string())),
            }),
        };
        let outer_lambda = Expr::Lambda {
            params: vec![("x".to_string(), None)],
            return_type: None,
            body: Box::new(inner_lambda),
        };
        assert_eq!(gen.gen_expr(&outer_lambda), "|x| { |y| { (x + y) } }");
    }

    // === Method Call Tests ===

    #[test]
    fn test_gen_method_call_simple() {
        let gen = RustCodegen::new();
        // obj.method(arg)
        let expr = Expr::Call {
            callee: Box::new(Expr::Member {
                object: Box::new(Expr::Identifier("obj".to_string())),
                field: "method".to_string(),
            }),
            args: vec![Expr::Literal(Literal::Int(42))],
        };
        assert_eq!(gen.gen_expr(&expr), "obj.method(42_i64)");
    }

    #[test]
    fn test_gen_method_call_no_args() {
        let gen = RustCodegen::new();
        // obj.get()
        let expr = Expr::Call {
            callee: Box::new(Expr::Member {
                object: Box::new(Expr::Identifier("obj".to_string())),
                field: "get".to_string(),
            }),
            args: vec![],
        };
        assert_eq!(gen.gen_expr(&expr), "obj.get()");
    }

    #[test]
    fn test_gen_method_call_multiple_args() {
        let gen = RustCodegen::new();
        // obj.calculate(1, 2, 3)
        let expr = Expr::Call {
            callee: Box::new(Expr::Member {
                object: Box::new(Expr::Identifier("obj".to_string())),
                field: "calculate".to_string(),
            }),
            args: vec![
                Expr::Literal(Literal::Int(1)),
                Expr::Literal(Literal::Int(2)),
                Expr::Literal(Literal::Int(3)),
            ],
        };
        assert_eq!(gen.gen_expr(&expr), "obj.calculate(1_i64, 2_i64, 3_i64)");
    }

    #[test]
    fn test_gen_method_call_chained() {
        let gen = RustCodegen::new();
        // obj.method1().method2(42)
        let inner_call = Expr::Call {
            callee: Box::new(Expr::Member {
                object: Box::new(Expr::Identifier("obj".to_string())),
                field: "method1".to_string(),
            }),
            args: vec![],
        };
        let outer_call = Expr::Call {
            callee: Box::new(Expr::Member {
                object: Box::new(inner_call),
                field: "method2".to_string(),
            }),
            args: vec![Expr::Literal(Literal::Int(42))],
        };
        assert_eq!(gen.gen_expr(&outer_call), "obj.method1().method2(42_i64)");
    }

    #[test]
    fn test_gen_method_call_on_member() {
        let gen = RustCodegen::new();
        // obj.field.method(arg)
        let expr = Expr::Call {
            callee: Box::new(Expr::Member {
                object: Box::new(Expr::Member {
                    object: Box::new(Expr::Identifier("obj".to_string())),
                    field: "field".to_string(),
                }),
                field: "method".to_string(),
            }),
            args: vec![Expr::Literal(Literal::String("test".to_string()))],
        };
        assert_eq!(
            gen.gen_expr(&expr),
            "obj.field.method(\"test\".to_string())"
        );
    }

    #[test]
    fn test_gen_method_length_to_len() {
        let gen = RustCodegen::new();
        // path.length() -> path.len()
        let expr = Expr::Call {
            callee: Box::new(Expr::Member {
                object: Box::new(Expr::Identifier("path".to_string())),
                field: "length".to_string(),
            }),
            args: vec![],
        };
        assert_eq!(gen.gen_expr(&expr), "path.len()");
    }

    #[test]
    fn test_gen_lambda_as_argument() {
        let gen = RustCodegen::new();
        // map(|x| x + 1)
        let lambda = Expr::Lambda {
            params: vec![("x".to_string(), None)],
            return_type: None,
            body: Box::new(Expr::Binary {
                left: Box::new(Expr::Identifier("x".to_string())),
                op: crate::ast::BinaryOp::Add,
                right: Box::new(Expr::Literal(Literal::Int(1))),
            }),
        };
        let call = Expr::Call {
            callee: Box::new(Expr::Identifier("map".to_string())),
            args: vec![lambda],
        };
        assert_eq!(gen.gen_expr(&call), "map(|x| { (x + 1_i64) })");
    }

    #[test]
    fn test_gen_lambda_in_method_call() {
        let gen = RustCodegen::new();
        // collection.map(|x| x * 2)
        let lambda = Expr::Lambda {
            params: vec![("x".to_string(), None)],
            return_type: None,
            body: Box::new(Expr::Binary {
                left: Box::new(Expr::Identifier("x".to_string())),
                op: crate::ast::BinaryOp::Mul,
                right: Box::new(Expr::Literal(Literal::Int(2))),
            }),
        };
        let method_call = Expr::Call {
            callee: Box::new(Expr::Member {
                object: Box::new(Expr::Identifier("collection".to_string())),
                field: "map".to_string(),
            }),
            args: vec![lambda],
        };
        assert_eq!(
            gen.gen_expr(&method_call),
            "collection.into_iter().map(|x| { (x * 2_i64) }).collect::<Vec<_>>()"
        );
    }

    // === Meta-Programming Tests ===

    #[test]
    fn test_gen_quote() {
        let gen = RustCodegen::new();
        // '(1 + 2)
        let expr = Expr::Quote(Box::new(Expr::Binary {
            left: Box::new(Expr::Literal(Literal::Int(1))),
            op: crate::ast::BinaryOp::Add,
            right: Box::new(Expr::Literal(Literal::Int(2))),
        }));
        assert_eq!(
            gen.gen_expr(&expr),
            "QuotedExpr::from_expr(&(1_i64 + 2_i64))"
        );
    }

    #[test]
    fn test_gen_quote_identifier() {
        let gen = RustCodegen::new();
        // 'x
        let expr = Expr::Quote(Box::new(Expr::Identifier("x".to_string())));
        assert_eq!(gen.gen_expr(&expr), "QuotedExpr::from_expr(&x)");
    }

    #[test]
    fn test_gen_eval() {
        let gen = RustCodegen::new();
        // eval(quoted_expr)
        let expr = Expr::Eval(Box::new(Expr::Identifier("quoted_expr".to_string())));
        assert_eq!(gen.gen_expr(&expr), "eval(quoted_expr)");
    }

    #[test]
    fn test_gen_eval_with_quote() {
        let gen = RustCodegen::new();
        // eval('(1 + 2))
        let expr = Expr::Eval(Box::new(Expr::Quote(Box::new(Expr::Binary {
            left: Box::new(Expr::Literal(Literal::Int(1))),
            op: crate::ast::BinaryOp::Add,
            right: Box::new(Expr::Literal(Literal::Int(2))),
        }))));
        assert_eq!(
            gen.gen_expr(&expr),
            "eval(QuotedExpr::from_expr(&(1_i64 + 2_i64)))"
        );
    }

    #[test]
    fn test_gen_reflect() {
        let gen = RustCodegen::new();
        // ?Int32
        let expr = Expr::Reflect(Box::new(TypeExpr::Named("Int32".to_string())));
        assert_eq!(gen.gen_expr(&expr), "TypeInfo::get::<i32>()");
    }

    #[test]
    fn test_gen_reflect_generic() {
        let gen = RustCodegen::new();
        // ?List<Int32>
        let expr = Expr::Reflect(Box::new(TypeExpr::Generic {
            name: "List".to_string(),
            args: vec![TypeExpr::Named("Int32".to_string())],
        }));
        assert_eq!(gen.gen_expr(&expr), "TypeInfo::get::<Vec<i32>>()");
    }

    #[test]
    fn test_gen_quasi_quote() {
        let gen = RustCodegen::new();
        // `(1 + 2)
        let expr = Expr::QuasiQuote(Box::new(Expr::Binary {
            left: Box::new(Expr::Literal(Literal::Int(1))),
            op: crate::ast::BinaryOp::Add,
            right: Box::new(Expr::Literal(Literal::Int(2))),
        }));
        assert_eq!(
            gen.gen_expr(&expr),
            "QuotedExpr::from_expr(&(1_i64 + 2_i64))"
        );
    }

    #[test]
    fn test_gen_unquote() {
        let gen = RustCodegen::new();
        // ,x (inside a quasi-quote)
        let expr = Expr::Unquote(Box::new(Expr::Identifier("x".to_string())));
        assert_eq!(gen.gen_expr(&expr), "x");
    }

    #[test]
    fn test_gen_idiom_bracket_no_args() {
        let gen = RustCodegen::new();
        // [| f |] => f
        let expr = Expr::IdiomBracket {
            func: Box::new(Expr::Identifier("f".to_string())),
            args: vec![],
        };
        assert_eq!(gen.gen_expr(&expr), "f");
    }

    #[test]
    fn test_gen_idiom_bracket_one_arg() {
        let gen = RustCodegen::new();
        // [| f a |] => a.map(f)
        let expr = Expr::IdiomBracket {
            func: Box::new(Expr::Identifier("f".to_string())),
            args: vec![Expr::Identifier("a".to_string())],
        };
        assert_eq!(gen.gen_expr(&expr), "a.map(f)");
    }

    #[test]
    fn test_gen_idiom_bracket_two_args() {
        let gen = RustCodegen::new();
        // [| f a b |] => a.map(f).ap(b)
        let expr = Expr::IdiomBracket {
            func: Box::new(Expr::Identifier("f".to_string())),
            args: vec![
                Expr::Identifier("a".to_string()),
                Expr::Identifier("b".to_string()),
            ],
        };
        assert_eq!(gen.gen_expr(&expr), "a.map(f).ap(b)");
    }

    #[test]
    fn test_gen_idiom_bracket_three_args() {
        let gen = RustCodegen::new();
        // [| f a b c |] => a.map(f).ap(b).ap(c)
        let expr = Expr::IdiomBracket {
            func: Box::new(Expr::Identifier("f".to_string())),
            args: vec![
                Expr::Identifier("a".to_string()),
                Expr::Identifier("b".to_string()),
                Expr::Identifier("c".to_string()),
            ],
        };
        assert_eq!(gen.gen_expr(&expr), "a.map(f).ap(b).ap(c)");
    }

    #[test]
    fn test_gen_idiom_bracket_with_lambda() {
        let gen = RustCodegen::new();
        // [| |x| x + 1  opt_val |] => opt_val.map(|x| { (x + 1_i64) })
        let lambda = Expr::Lambda {
            params: vec![("x".to_string(), None)],
            return_type: None,
            body: Box::new(Expr::Binary {
                left: Box::new(Expr::Identifier("x".to_string())),
                op: crate::ast::BinaryOp::Add,
                right: Box::new(Expr::Literal(Literal::Int(1))),
            }),
        };
        let expr = Expr::IdiomBracket {
            func: Box::new(lambda),
            args: vec![Expr::Identifier("opt_val".to_string())],
        };
        assert_eq!(gen.gen_expr(&expr), "opt_val.map(|x| { (x + 1_i64) })");
    }

    #[test]
    fn test_gen_nested_quote() {
        let gen = RustCodegen::new();
        // ''x
        let expr = Expr::Quote(Box::new(Expr::Quote(Box::new(Expr::Identifier(
            "x".to_string(),
        )))));
        assert_eq!(
            gen.gen_expr(&expr),
            "QuotedExpr::from_expr(&QuotedExpr::from_expr(&x))"
        );
    }

    #[test]
    fn test_gen_quote_function_call() {
        let gen = RustCodegen::new();
        // '(f(1, 2))
        let expr = Expr::Quote(Box::new(Expr::Call {
            callee: Box::new(Expr::Identifier("f".to_string())),
            args: vec![
                Expr::Literal(Literal::Int(1)),
                Expr::Literal(Literal::Int(2)),
            ],
        }));
        assert_eq!(
            gen.gen_expr(&expr),
            "QuotedExpr::from_expr(&f(1_i64, 2_i64))"
        );
    }

    #[test]
    fn test_gen_reflect_function_type() {
        let gen = RustCodegen::new();
        // ?(Int32 -> Bool)
        let expr = Expr::Reflect(Box::new(TypeExpr::Function {
            params: vec![TypeExpr::Named("Int32".to_string())],
            return_type: Box::new(TypeExpr::Named("Bool".to_string())),
        }));
        assert_eq!(gen.gen_expr(&expr), "TypeInfo::get::<fn(i32) -> bool>()");
    }

    // === Pattern Matching Codegen Tests ===

    #[test]
    fn test_gen_pattern_wildcard() {
        let gen = RustCodegen::new();
        let pattern = crate::ast::Pattern::Wildcard;
        assert_eq!(gen.gen_pattern(&pattern), "_");
    }

    #[test]
    fn test_gen_pattern_identifier() {
        let gen = RustCodegen::new();
        let pattern = crate::ast::Pattern::Identifier("x".to_string());
        assert_eq!(gen.gen_pattern(&pattern), "x");
    }

    #[test]
    fn test_gen_pattern_literal_int() {
        let gen = RustCodegen::new();
        let pattern = crate::ast::Pattern::Literal(Literal::Int(42));
        assert_eq!(gen.gen_pattern(&pattern), "42_i64");
    }

    #[test]
    fn test_gen_pattern_literal_string() {
        let gen = RustCodegen::new();
        let pattern = crate::ast::Pattern::Literal(Literal::String("hello".to_string()));
        assert_eq!(gen.gen_pattern(&pattern), "\"hello\"");
    }

    #[test]
    fn test_gen_pattern_literal_bool() {
        let gen = RustCodegen::new();
        let pattern = crate::ast::Pattern::Literal(Literal::Bool(true));
        assert_eq!(gen.gen_pattern(&pattern), "true");
    }

    #[test]
    fn test_gen_pattern_constructor_no_fields() {
        let gen = RustCodegen::new();
        let pattern = crate::ast::Pattern::Constructor {
            name: "None".to_string(),
            fields: vec![],
        };
        assert_eq!(gen.gen_pattern(&pattern), "None");
    }

    #[test]
    fn test_gen_pattern_constructor_with_fields() {
        let gen = RustCodegen::new();
        let pattern = crate::ast::Pattern::Constructor {
            name: "Some".to_string(),
            fields: vec![crate::ast::Pattern::Identifier("x".to_string())],
        };
        assert_eq!(gen.gen_pattern(&pattern), "Some(x)");
    }

    #[test]
    fn test_gen_pattern_constructor_multiple_fields() {
        let gen = RustCodegen::new();
        let pattern = crate::ast::Pattern::Constructor {
            name: "Point".to_string(),
            fields: vec![
                crate::ast::Pattern::Identifier("x".to_string()),
                crate::ast::Pattern::Identifier("y".to_string()),
            ],
        };
        assert_eq!(gen.gen_pattern(&pattern), "Point(x, y)");
    }

    #[test]
    fn test_gen_pattern_tuple() {
        let gen = RustCodegen::new();
        let pattern = crate::ast::Pattern::Tuple(vec![
            crate::ast::Pattern::Identifier("x".to_string()),
            crate::ast::Pattern::Identifier("y".to_string()),
        ]);
        assert_eq!(gen.gen_pattern(&pattern), "(x, y)");
    }

    #[test]
    fn test_gen_pattern_nested_constructor() {
        let gen = RustCodegen::new();
        // Some(Point(x, y))
        let pattern = crate::ast::Pattern::Constructor {
            name: "Some".to_string(),
            fields: vec![crate::ast::Pattern::Constructor {
                name: "Point".to_string(),
                fields: vec![
                    crate::ast::Pattern::Identifier("x".to_string()),
                    crate::ast::Pattern::Identifier("y".to_string()),
                ],
            }],
        };
        assert_eq!(gen.gen_pattern(&pattern), "Some(Point(x, y))");
    }

    #[test]
    fn test_gen_match_simple() {
        let gen = RustCodegen::new();
        // match value { Some(x) => x, None => 0_i64 }
        let scrutinee = Expr::Identifier("value".to_string());
        let arms = vec![
            crate::ast::MatchArm {
                pattern: crate::ast::Pattern::Constructor {
                    name: "Some".to_string(),
                    fields: vec![crate::ast::Pattern::Identifier("x".to_string())],
                },
                guard: None,
                body: Box::new(Expr::Identifier("x".to_string())),
            },
            crate::ast::MatchArm {
                pattern: crate::ast::Pattern::Constructor {
                    name: "None".to_string(),
                    fields: vec![],
                },
                guard: None,
                body: Box::new(Expr::Literal(Literal::Int(0))),
            },
        ];
        let result = gen.gen_match(&scrutinee, &arms);
        assert!(result.contains("match value {"));
        assert!(result.contains("Some(x) => x"));
        assert!(result.contains("None => 0_i64"));
    }

    #[test]
    fn test_gen_match_with_guard() {
        let gen = RustCodegen::new();
        // match value { x if x > 0 => x, _ => 0 }
        let scrutinee = Expr::Identifier("value".to_string());
        let arms = vec![
            crate::ast::MatchArm {
                pattern: crate::ast::Pattern::Identifier("x".to_string()),
                guard: Some(Box::new(Expr::Binary {
                    left: Box::new(Expr::Identifier("x".to_string())),
                    op: crate::ast::BinaryOp::Gt,
                    right: Box::new(Expr::Literal(Literal::Int(0))),
                })),
                body: Box::new(Expr::Identifier("x".to_string())),
            },
            crate::ast::MatchArm {
                pattern: crate::ast::Pattern::Wildcard,
                guard: None,
                body: Box::new(Expr::Literal(Literal::Int(0))),
            },
        ];
        let result = gen.gen_match(&scrutinee, &arms);
        assert!(result.contains("match value {"));
        assert!(result.contains("x if (x > 0_i64) => x"));
        assert!(result.contains("_ => 0_i64"));
    }

    #[test]
    fn test_gen_match_tuple_patterns() {
        let gen = RustCodegen::new();
        // match point { (0, 0) => "origin", (x, 0) => "x-axis", (0, y) => "y-axis", _ => "plane" }
        let scrutinee = Expr::Identifier("point".to_string());
        let arms = vec![
            crate::ast::MatchArm {
                pattern: crate::ast::Pattern::Tuple(vec![
                    crate::ast::Pattern::Literal(Literal::Int(0)),
                    crate::ast::Pattern::Literal(Literal::Int(0)),
                ]),
                guard: None,
                body: Box::new(Expr::Literal(Literal::String("origin".to_string()))),
            },
            crate::ast::MatchArm {
                pattern: crate::ast::Pattern::Tuple(vec![
                    crate::ast::Pattern::Identifier("x".to_string()),
                    crate::ast::Pattern::Literal(Literal::Int(0)),
                ]),
                guard: None,
                body: Box::new(Expr::Literal(Literal::String("x-axis".to_string()))),
            },
            crate::ast::MatchArm {
                pattern: crate::ast::Pattern::Tuple(vec![
                    crate::ast::Pattern::Literal(Literal::Int(0)),
                    crate::ast::Pattern::Identifier("y".to_string()),
                ]),
                guard: None,
                body: Box::new(Expr::Literal(Literal::String("y-axis".to_string()))),
            },
            crate::ast::MatchArm {
                pattern: crate::ast::Pattern::Wildcard,
                guard: None,
                body: Box::new(Expr::Literal(Literal::String("plane".to_string()))),
            },
        ];
        let result = gen.gen_match(&scrutinee, &arms);
        assert!(result.contains("match point {"));
        assert!(result.contains("(0_i64, 0_i64) => \"origin\""));
        assert!(result.contains("(x, 0_i64) => \"x-axis\""));
        assert!(result.contains("(0_i64, y) => \"y-axis\""));
        assert!(result.contains("_ => \"plane\""));
    }

    #[test]
    fn test_gen_expr_match() {
        let gen = RustCodegen::new();
        // match option { Some(x) => x, None => 0 }
        let expr = Expr::Match {
            scrutinee: Box::new(Expr::Identifier("option".to_string())),
            arms: vec![
                crate::ast::MatchArm {
                    pattern: crate::ast::Pattern::Constructor {
                        name: "Some".to_string(),
                        fields: vec![crate::ast::Pattern::Identifier("x".to_string())],
                    },
                    guard: None,
                    body: Box::new(Expr::Identifier("x".to_string())),
                },
                crate::ast::MatchArm {
                    pattern: crate::ast::Pattern::Constructor {
                        name: "None".to_string(),
                        fields: vec![],
                    },
                    guard: None,
                    body: Box::new(Expr::Literal(Literal::Int(0))),
                },
            ],
        };
        let result = gen.gen_expr(&expr);
        assert!(result.contains("match option {"));
        assert!(result.contains("Some(x) => x"));
        assert!(result.contains("None => 0_i64"));
    }

    #[test]
    fn test_gen_match_nested_patterns() {
        let gen = RustCodegen::new();
        // match result { Ok(Some(x)) => x, Ok(None) => 0, Err(_) => -1 }
        let scrutinee = Expr::Identifier("result".to_string());
        let arms = vec![
            crate::ast::MatchArm {
                pattern: crate::ast::Pattern::Constructor {
                    name: "Ok".to_string(),
                    fields: vec![crate::ast::Pattern::Constructor {
                        name: "Some".to_string(),
                        fields: vec![crate::ast::Pattern::Identifier("x".to_string())],
                    }],
                },
                guard: None,
                body: Box::new(Expr::Identifier("x".to_string())),
            },
            crate::ast::MatchArm {
                pattern: crate::ast::Pattern::Constructor {
                    name: "Ok".to_string(),
                    fields: vec![crate::ast::Pattern::Constructor {
                        name: "None".to_string(),
                        fields: vec![],
                    }],
                },
                guard: None,
                body: Box::new(Expr::Literal(Literal::Int(0))),
            },
            crate::ast::MatchArm {
                pattern: crate::ast::Pattern::Constructor {
                    name: "Err".to_string(),
                    fields: vec![crate::ast::Pattern::Wildcard],
                },
                guard: None,
                body: Box::new(Expr::Literal(Literal::Int(-1))),
            },
        ];
        let result = gen.gen_match(&scrutinee, &arms);
        assert!(result.contains("match result {"));
        assert!(result.contains("Ok(Some(x)) => x"));
        assert!(result.contains("Ok(None) => 0_i64"));
        assert!(result.contains("Err(_) => -1_i64"));
    }

    #[test]
    fn test_gen_match_with_complex_body() {
        let gen = RustCodegen::new();
        // match value { Some(x) => x + 1, None => 0 }
        let scrutinee = Expr::Identifier("value".to_string());
        let arms = vec![
            crate::ast::MatchArm {
                pattern: crate::ast::Pattern::Constructor {
                    name: "Some".to_string(),
                    fields: vec![crate::ast::Pattern::Identifier("x".to_string())],
                },
                guard: None,
                body: Box::new(Expr::Binary {
                    left: Box::new(Expr::Identifier("x".to_string())),
                    op: crate::ast::BinaryOp::Add,
                    right: Box::new(Expr::Literal(Literal::Int(1))),
                }),
            },
            crate::ast::MatchArm {
                pattern: crate::ast::Pattern::Constructor {
                    name: "None".to_string(),
                    fields: vec![],
                },
                guard: None,
                body: Box::new(Expr::Literal(Literal::Int(0))),
            },
        ];
        let result = gen.gen_match(&scrutinee, &arms);
        assert!(result.contains("match value {"));
        assert!(result.contains("Some(x) => (x + 1_i64)"));
        assert!(result.contains("None => 0_i64"));
    }

    #[test]
    fn test_gen_file() {
        let gen = RustCodegen::new();
        let gene = Gene {
            name: "TestStruct".to_string(),
            extends: None,
            statements: vec![],
            exegesis: "Test".to_string(),
            span: Span::default(),
        };
        let output = gen.gen_file(&[Declaration::Gene(gene)]);
        assert!(output.contains("// Generated by DOL compiler"));
        assert!(output.contains("pub struct TestStruct"));
    }

    #[test]
    fn test_gen_file_with_hashmap() {
        let gen = RustCodegen::new();
        let gene = Gene {
            name: "TestStruct".to_string(),
            extends: None,
            statements: vec![Statement::HasField(Box::new(crate::ast::HasField {
                name: "data".to_string(),
                type_: TypeExpr::Generic {
                    name: "Map".to_string(),
                    args: vec![
                        TypeExpr::Named("String".to_string()),
                        TypeExpr::Named("Int32".to_string()),
                    ],
                },
                default: None,
                constraint: None,
                span: Span::default(),
            }))],
            exegesis: "Test with HashMap".to_string(),
            span: Span::default(),
        };
        let output = gen.gen_file(&[Declaration::Gene(gene)]);
        assert!(output.contains("// Generated by DOL compiler"));
        assert!(output.contains("use std::collections::HashMap;"));
        assert!(output.contains("pub struct TestStruct"));
    }

    #[test]
    fn test_gen_imports() {
        let gen = RustCodegen::new();
        let gene = Gene {
            name: "TestStruct".to_string(),
            extends: None,
            statements: vec![Statement::HasField(Box::new(crate::ast::HasField {
                name: "data".to_string(),
                type_: TypeExpr::Generic {
                    name: "Map".to_string(),
                    args: vec![
                        TypeExpr::Named("String".to_string()),
                        TypeExpr::Named("Int32".to_string()),
                    ],
                },
                default: None,
                constraint: None,
                span: Span::default(),
            }))],
            exegesis: "Test".to_string(),
            span: Span::default(),
        };
        let imports = gen.gen_imports(&[Declaration::Gene(gene)]);
        assert!(imports.contains("use std::collections::HashMap;"));
    }
}
