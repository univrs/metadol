system reconciliation.loop @ 0.1.0 {
  requires reconciliation.sense >= 0.0.1
  requires reconciliation.compare >= 0.0.1
  requires reconciliation.plan >= 0.0.1
  requires reconciliation.actuate >= 0.0.1

  uses state.concurrency
  uses event.emission
  uses error.handling
}

exegesis {
  The reconciliation.loop system composes the four phases of the Kubernetes-style
  control loop pattern: sense -> compare -> plan -> actuate -> repeat.

  This is the core pattern that enables declarative orchestration. Instead of
  users issuing imperative commands ("create container X"), they declare desired
  state ("I want container X running") and the reconciliation loop continuously
  works to make reality match the declaration.

  The loop operates as follows:

  1. SENSE: Read current state from the cluster (nodes, containers, instances).
     This provides a consistent snapshot of reality.

  2. COMPARE: Diff current state against desired state (workload definitions).
     This identifies what needs to change: additions, modifications, deletions.

  3. PLAN: Generate an ordered sequence of actions with dependencies, rollback
     points, and optimizations for minimal disruption.

  4. ACTUATE: Execute the plan, handling failures with retries or rollbacks,
     and emitting events for observability.

  5. REPEAT: After actuation, start the cycle again. The loop continues until
     current state converges with desired state (within tolerance) or timeout.

  Key characteristics:

  - Eventually consistent: The system may not immediately reflect desired state,
    but will converge toward it over time.

  - Idempotent: Running the loop multiple times with no state changes produces
    no additional actions (empty diffs lead to empty plans).

  - Observable: Each phase emits events and tracks correlation IDs, enabling
    full tracing of why any action was taken.

  - Resilient: Failures in one cycle don't prevent future cycles. The loop
    continues operating, attempting to make progress.

  Dependencies:
  - state.concurrency: Thread-safe state access during sensing
  - event.emission: Publishing reconciliation events
  - error.handling: Structured error types for failure classification

  Version 0.1.0 indicates early development. Future versions may add:
  - Parallel reconciliation of independent resource types
  - Prioritized reconciliation queues
  - Rate limiting and back-pressure
  - Leader election for distributed reconciliation
}
