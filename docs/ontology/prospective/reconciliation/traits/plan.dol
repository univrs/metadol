trait reconciliation.plan {
  uses reconciliation.compare

  plan has diff
  plan has action_sequence

  diff derives from compare

  action_sequence has ordered_actions
  action_sequence has dependencies
  action_sequence has rollback_points

  action has type
  action has target
  action has preconditions
  action has estimated_duration
  action has risk_level
  action has reversibility

  target is entity_reference
  target has current_state
  target has desired_state

  preconditions requires satisfaction

  each plan is validated
  each plan is auditable
}

exegesis {
  The plan trait implements the third phase of reconciliation: translating the
  diff into a concrete sequence of actions that will transform current state
  into desired state.

  Planning is not simply executing all diffs in order. It requires:

  1. Dependency ordering: Some actions must complete before others (e.g.,
     create network before creating container that uses it).

  2. Rollback points: Marking safe states to return to if actions fail,
     enabling partial rollback rather than full reversion.

  3. Preconditions: Each action may have requirements that must be met,
     either from other actions completing or external state checks.

  4. Optimization: Multiple strategies exist for sequencing:
     - Minimal disruption: Batch similar actions, use rolling updates
     - Resource efficiency: Consider capacity during transitions
     - Failure isolation: Group actions so failures don't cascade

  Action types cover the full lifecycle: create, update, delete, migrate, scale.

  Each action carries metadata:
  - Estimated duration: For progress tracking and timeout detection
  - Risk level: For approval workflows and alerting
  - Reversibility: Whether the action can be undone

  Plans are validated before execution (dry-run) and auditable for compliance.
}
