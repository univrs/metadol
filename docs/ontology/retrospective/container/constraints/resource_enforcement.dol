constraint resource.enforcement {
  allocation matches cgroup.limits
  usage never exceeds.quota
}

exegesis {
  The resource.enforcement constraint ensures that resource limits specified in
  the container configuration are properly enforced by the Linux kernel via
  cgroups v2. Containers cannot exceed their allocated CPU quota, memory limit,
  or PID maximum.

  CPU enforcement:
  - Limit specified as cores (e.g., 0.5, 2.0)
  - Converted to quota/period: quota = cores * 100000 microseconds
  - Period = 100000 microseconds (100ms)
  - Enforced by cpu.max cgroup controller
  - Example: 0.5 cores = 50000/100000 = container gets 50ms per 100ms

  Memory enforcement:
  - Limit specified in MB
  - Converted to bytes: mb * 1024 * 1024
  - Set in memory.max cgroup file
  - Kernel OOM killer terminates process if limit exceeded
  - Soft limit (reservation) set to 50% for gradual throttling

  PIDs enforcement:
  - Maximum number of processes/threads
  - Default: 1024
  - Set in pids.max cgroup file
  - Fork fails with EAGAIN when limit reached

  Cgroup path structure:
  - /sys/fs/cgroup/youki/<container_id>/
  - Files: cpu.max, cpu.stat, memory.current, memory.max, pids.current, pids.max

  Implementation: Resources struct in oci_bundle/spec.rs:
  - CpuResources::from_cores(cores): Sets quota and period
  - MemoryResources::from_mb(mb): Sets limit and reservation
  - PidsResources ( limit ): Sets max PIDs

  The OCI spec is written to config.json, then youki/libcontainer applies the
  limits by writing to cgroup controllers during container creation. The kernel
  enforces limits, not the runtime.

  Monitoring: YoukiCliRuntime.get_stats() reads cgroup files:
  - cpu.stat "usage_usec" for CPU time
  - memory.current for memory usage
  Returns ContainerStats(cpu_usage_ns, memory_usage_bytes)
}
