trait runtime.execution {
  uses process.spawning
  uses namespace.creation
  uses cgroup.enforcement
  uses signal.delivery
  execution is platform.specific
  execution emits execution.events
}

exegesis {
  The runtime.execution trait handles the low-level container execution either
  through direct libcontainer calls or by shelling out to the youki CLI binary.
  Execution involves creating Linux namespaces (pid, net, ipc, uts, mount),
  setting up cgroups for resource limits, and spawning the container process.

  Two implementation strategies:

  1. YoukiRuntime (libcontainer direct):
  - ContainerBuilder::new(id, SyscallType::default()): Create builder
  - with_root_path(state_dir): Set state directory
  - as_init(bundle_path): Initialize from bundle
  - with_detach(true): Run in background
  - build(): Returns Container object
  - container.start(): Spawn process in namespaces

  2. YoukiCliRuntime (CLI wrapper):
  - youki_create(id, bundle_path): Execute "youki create <id> --bundle <path>"
  - youki_start(id): Execute "youki start <id>"
  - youki_kill(id, signal): Execute "youki kill <id> <signal>"
  - youki_delete(id, force): Execute "youki delete [--force] <id>"
  - youki_state(id): Execute "youki state <id>", parse JSON to YoukiState

  All CLI commands include "--root <state_root>" for state directory and have
  configurable timeouts (default 30s) with timeout error handling.

  The CLI approach is more portable (doesn't require libcontainer linkage) but
  has higher overhead. The libcontainer approach is more efficient but requires
  careful async wrapping (spawn_blocking) since libcontainer is synchronous.
}
