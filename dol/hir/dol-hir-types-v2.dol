// DOL HIR (High-level Intermediate Representation)
// 
// Version: 0.1.0
// Updated: 2025-12-26
// 
// Design decisions:
// - val/var for bindings (not let/mut)
// - type as primary keyword (gene supported for compatibility)
// - forall as unified quantifier
// - Minimal canonical forms (22 node types)

mod dol.hir @ 0.1.0

// ============================================================================
// SYMBOLS & IDENTIFIERS
// ============================================================================

/// Interned string symbol for fast comparison
pub type Symbol {
    id: UInt32  // Index into symbol table
}

/// Qualified name (e.g., dol.hir.Symbol)
pub type QualName {
    segments: List<Symbol>
}

// ============================================================================
// TYPES (8 forms)
// ============================================================================

/// HIR type representation
pub type HirType {
    kind: enum {
        // Primitives
        Void,
        Bool,
        Int { bits: UInt8, signed: Bool },    // Int8, UInt64, etc
        Float { bits: UInt8 },                 // Float32, Float64
        String,
        
        // Compound
        Array { elem: Box<HirType> },
        Tuple { elems: List<HirType> },
        Record { fields: List<(Symbol, HirType)> },
        Function { params: List<HirType>, ret: Box<HirType> },
        
        // Named
        Named { name: QualName, args: List<HirType> },
        
        // Generic
        Generic { name: Symbol },
        
        // Inference placeholder
        Infer { id: UInt32 }
    }
}

// ============================================================================
// LITERALS (6 forms)
// ============================================================================

pub type HirLit {
    kind: enum {
        Bool { value: Bool },
        Int { value: Int64, ty: HirType },
        Float { value: Float64, ty: HirType },
        String { value: String },
        Char { value: UInt32 },
        Unit
    }
}

// ============================================================================
// EXPRESSIONS (12 forms)
// ============================================================================

pub type HirExpr {
    ty: HirType           // Every expression has a type
    kind: HirExprKind
}

pub type HirExprKind {
    kind: enum {
        // === Atoms ===
        Lit { value: HirLit },
        Var { name: Symbol },
        
        // === Compound ===
        Binary { left: Box<HirExpr>, op: BinOp, right: Box<HirExpr> },
        Unary { op: UnOp, operand: Box<HirExpr> },
        Call { func: Box<HirExpr>, args: List<HirExpr> },
        Field { expr: Box<HirExpr>, field: Symbol },
        Index { expr: Box<HirExpr>, index: Box<HirExpr> },
        
        // === Control ===
        If { cond: Box<HirExpr>, then_: Box<HirExpr>, else_: Box<HirExpr> },
        Match { scrutinee: Box<HirExpr>, arms: List<HirArm> },
        Loop { body: Box<HirExpr>, label: Option<Symbol> },
        
        // === Functions ===
        Lambda { params: List<HirParam>, body: Box<HirExpr> },
        
        // === Construction ===
        Record { fields: List<(Symbol, HirExpr)> },
        Array { elems: List<HirExpr> },
        Tuple { elems: List<HirExpr> }
    }
}

// ============================================================================
// PATTERNS (6 forms)
// ============================================================================

pub type HirPat {
    ty: HirType
    kind: HirPatKind
}

pub type HirPatKind {
    kind: enum {
        Wildcard,                                    // _
        Bind { name: Symbol, mutable: Bool },       // x, var x
        Lit { value: HirLit },                       // 42, "hello"
        Ctor { name: QualName, fields: List<HirPat> },  // Some(x), Ok(v)
        Tuple { elems: List<HirPat> },              // (a, b, c)
        Or { patterns: List<HirPat> }               // A | B | C
    }
}

pub type HirArm {
    pattern: HirPat
    guard: Option<HirExpr>
    body: HirExpr
}

// ============================================================================
// STATEMENTS (6 forms)
// ============================================================================

pub type HirStmt {
    kind: enum {
        // Bindings - val/var naming!
        Val { name: Symbol, ty: HirType, value: HirExpr },  // Immutable
        Var { name: Symbol, ty: HirType, value: HirExpr },  // Mutable
        
        // Effects
        Assign { target: HirExpr, value: HirExpr },
        Expr { expr: HirExpr },
        
        // Control
        Return { value: Option<HirExpr> },
        Break { value: Option<HirExpr>, label: Option<Symbol> }
    }
}

// ============================================================================
// DECLARATIONS (4 forms)
// ============================================================================

pub type HirDecl {
    kind: enum {
        // Type declaration (unifies gene/type/struct/enum)
        Type {
            name: Symbol,
            vis: Visibility,
            generics: List<HirGeneric>,
            kind: TypeKind,
            constraints: List<HirExpr>,
            docs: Option<String>
        },
        
        // Trait declaration
        Trait {
            name: Symbol,
            vis: Visibility,
            generics: List<HirGeneric>,
            bounds: List<HirType>,
            methods: List<HirMethod>,
            laws: List<HirLaw>,
            docs: Option<String>
        },
        
        // Function declaration
        Function {
            name: Symbol,
            vis: Visibility,
            generics: List<HirGeneric>,
            params: List<HirParam>,
            ret_type: HirType,
            body: Option<HirExpr>,
            effects: Effects,
            docs: Option<String>
        },
        
        // Module declaration
        Module {
            name: Symbol,
            vis: Visibility,
            version: Option<Version>,
            imports: List<HirImport>,
            items: List<HirDecl>
        }
    }
}

// ============================================================================
// SUPPORTING TYPES
// ============================================================================

pub type TypeKind {
    kind: enum {
        // Record type (struct-like)
        Record { fields: List<HirField> },
        
        // Enum type
        Enum { variants: List<HirVariant> },
        
        // Alias type
        Alias { target: HirType }
    }
}

pub type HirField {
    name: Symbol
    ty: HirType
    default: Option<HirExpr>
    docs: Option<String>
}

pub type HirVariant {
    name: Symbol
    fields: List<HirField>
    docs: Option<String>
}

pub type HirParam {
    name: Symbol
    ty: HirType
    mutable: Bool
    default: Option<HirExpr>
}

pub type HirGeneric {
    name: Symbol
    bounds: List<HirType>
    default: Option<HirType>
}

pub type HirMethod {
    name: Symbol
    params: List<HirParam>
    ret_type: HirType
    default_impl: Option<HirExpr>
    docs: Option<String>
}

pub type HirLaw {
    name: Symbol
    body: HirExpr
    docs: Option<String>
}

pub type HirImport {
    path: QualName
    items: ImportKind
}

pub type ImportKind {
    kind: enum {
        All,                          // use foo.*
        Items { names: List<Symbol> }, // use foo.{ a, b }
        Alias { name: Symbol }         // use foo as bar
    }
}

// ============================================================================
// ENUMS FOR OPERATORS AND VISIBILITY
// ============================================================================

pub type BinOp {
    kind: enum {
        // Arithmetic
        Add, Sub, Mul, Div, Mod, Pow,
        // Comparison
        Eq, Ne, Lt, Le, Gt, Ge,
        // Logical
        And, Or,
        // Bitwise
        BitAnd, BitOr, BitXor, Shl, Shr
    }
}

pub type UnOp {
    kind: enum {
        Neg,    // -x
        Not,    // !x / not x
        Deref   // *x
    }
}

pub type Visibility {
    kind: enum {
        Private,
        Public,
        Spirit,
        Parent
    }
}

pub type Effects {
    kind: enum {
        Pure,      // No side effects
        Sex,       // Has side effects
        Extern     // External function
    }
}

pub type Version {
    major: UInt16
    minor: UInt16
    patch: UInt16
}

// ============================================================================
// HIR MODULE (Top-level)
// ============================================================================

pub type HirModule {
    name: QualName
    version: Option<Version>
    imports: List<HirImport>
    decls: List<HirDecl>
}

// ============================================================================
// DESUGARING REFERENCE
// ============================================================================
//
// Surface Syntax          →  HIR Form
// ─────────────────────────────────────────────────────────
// let x = 1               →  Val { name: x, ... }     (DEPRECATED)
// val x = 1               →  Val { name: x, ... }     (NEW)
// var x = 1               →  Var { name: x, ... }
// gene Foo { }            →  Type { ... }             (COMPAT)
// type Foo { }            →  Type { ... }             (PREFERRED)
// each x in xs            →  Loop + Match             (DEPRECATED)
// forall x in xs          →  Loop + Match
// x |> f |> g             →  Call(g, Call(f, x))
// f >> g                  →  Lambda { Call(g, Call(f, param)) }
// while cond { }          →  Loop { If(cond, body, Break) }
// for x in xs { }         →  Loop + Iterator pattern
// a && b                  →  If(a, b, false)
// a || b                  →  If(a, true, b)
// x += 1                  →  Assign(x, Binary(x, Add, 1))
//
// ============================================================================

// ============================================================================
// SUMMARY
// ============================================================================
//
// Total node types: 22
// - HirType:     8 variants
// - HirExprKind: 12 variants  
// - HirPatKind:  6 variants
// - HirStmt:     6 variants (Val/Var, not Let/Mut!)
// - HirDecl:     4 variants
//
// Keyword changes:
// - let → val (immutable value)
// - mut → var (mutable variable)
// - gene → type (gradual migration)
// - each/all → forall
// - module → mod
// - never → not
// - derives from → extends
// - matches → ==
//
// Benefits:
// 1. val/var symmetry (value vs variable)
// 2. Simpler codegen (fewer cases)
// 3. Canonical forms (one way per concept)
// 4. Language cleanup enabled
