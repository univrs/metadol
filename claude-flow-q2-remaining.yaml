# claude-flow-q2-remaining.yaml
#
# Mission: Complete remaining Q2 Meta-Programming tasks
# Tasks: 4.3 Macro, 4.4 Reflect, 4.5 Idiom Brackets
#
# Run: npx claude-flow@alpha swarm "read claude-flow-q2-remaining.yaml --workflow q2-complete"

name: q2-remaining
description: Complete Q2 Meta-Programming - Macro, Reflect, Idiom Brackets

# ═══════════════════════════════════════════════════════════════════
# CONTEXT
# ═══════════════════════════════════════════════════════════════════

context:
  completed:
    - "4.1 Quote (') - 6c8c671"
    - "4.2 Eval (!) - 6c8c671"
    - "4.6 AST Transform Framework - b0911d1"
    - "4.7 Codegen TODO cleanup - 0a9b235"
    
  remaining:
    - "4.3 Macro (#) - Compile-time code transformation"
    - "4.4 Reflect (?) - Runtime type introspection"
    - "4.5 Idiom Brackets ([| |]) - Applicative functor lifting"
    
  existing_infrastructure:
    - "src/eval/ - Interpreter for quote/eval"
    - "src/transform/ - AST transformation passes"
    - "src/lexer.rs - Already has # ? [| |] tokens"
    - "src/typechecker.rs - Type inference"

# ═══════════════════════════════════════════════════════════════════
# AGENTS
# ═══════════════════════════════════════════════════════════════════

agents:
  # ─────────────────────────────────────────────────────────────────
  # Task 4.3: Macro System
  # ─────────────────────────────────────────────────────────────────
  macro-module:
    name: Macro Module Creator
    role: Create the macro system module structure
    instructions: |
      Create the macro system module for DOL.
      
      The macro system enables compile-time code transformation using #.
      
      CREATE src/macros/mod.rs:
      
      ```rust
      //! DOL Macro System
      //! 
      //! Macros are compile-time code transformations invoked with #.
      //! 
      //! # Examples
      //! ```dol
      //! #derive(Debug, Clone)
      //! gene Container { has id: UInt64 }
      //! 
      //! result = #stringify(x + y)  // "x + y"
      //! ```
      
      pub mod builtin;
      pub mod expand;
      pub mod registry;
      
      use crate::ast::{Declaration, Expr, Span};
      use std::collections::HashMap;
      
      /// Error during macro expansion
      #[derive(Debug, Clone)]
      pub struct MacroError {
          pub message: String,
          pub span: Span,
      }
      
      /// Input to a macro
      #[derive(Debug, Clone)]
      pub enum MacroInput {
          /// Attribute macro on a declaration: #[derive(Debug)] gene Foo {}
          Attribute {
              args: Vec<Expr>,
              item: Declaration,
          },
          /// Expression macro: #stringify(expr)
          Expression {
              args: Vec<Expr>,
          },
      }
      
      /// Output from a macro
      #[derive(Debug, Clone)]
      pub enum MacroOutput {
          /// Replace with single declaration
          Declaration(Declaration),
          /// Replace with multiple declarations
          Declarations(Vec<Declaration>),
          /// Replace with expression
          Expression(Expr),
          /// No output (remove)
          None,
      }
      
      /// Trait for implementing macros
      pub trait Macro: Send + Sync {
          /// Name of the macro (without #)
          fn name(&self) -> &str;
          
          /// Expand the macro
          fn expand(&self, input: MacroInput, span: Span) -> Result<MacroOutput, MacroError>;
      }
      ```
      
      FILE: ~/repos/metadol/src/macros/mod.rs

  macro-builtins:
    name: Macro Builtins
    role: Implement built-in macros
    dependencies:
      - macro-module
    instructions: |
      Implement the built-in macros.
      
      CREATE src/macros/builtin.rs:
      
      ```rust
      //! Built-in macros
      
      use super::{Macro, MacroInput, MacroOutput, MacroError};
      use crate::ast::{Expr, Literal, Span};
      
      /// #stringify(expr) - Convert expression to string
      pub struct Stringify;
      
      impl Macro for Stringify {
          fn name(&self) -> &str { "stringify" }
          
          fn expand(&self, input: MacroInput, span: Span) -> Result<MacroOutput, MacroError> {
              match input {
                  MacroInput::Expression { args } => {
                      if args.len() != 1 {
                          return Err(MacroError {
                              message: "stringify expects exactly 1 argument".into(),
                              span,
                          });
                      }
                      // Convert AST to string representation
                      let expr_str = format!("{:?}", args[0]); // TODO: pretty print
                      Ok(MacroOutput::Expression(Expr::Literal {
                          value: Literal::String(expr_str),
                          span,
                      }))
                  }
                  _ => Err(MacroError {
                      message: "stringify is an expression macro".into(),
                      span,
                  }),
              }
          }
      }
      
      /// #concat(a, b, ...) - Concatenate string literals
      pub struct Concat;
      
      impl Macro for Concat {
          fn name(&self) -> &str { "concat" }
          
          fn expand(&self, input: MacroInput, span: Span) -> Result<MacroOutput, MacroError> {
              match input {
                  MacroInput::Expression { args } => {
                      let mut result = String::new();
                      for arg in args {
                          if let Expr::Literal { value: Literal::String(s), .. } = arg {
                              result.push_str(&s);
                          } else {
                              return Err(MacroError {
                                  message: "concat expects string literals".into(),
                                  span,
                              });
                          }
                      }
                      Ok(MacroOutput::Expression(Expr::Literal {
                          value: Literal::String(result),
                          span,
                      }))
                  }
                  _ => Err(MacroError {
                      message: "concat is an expression macro".into(),
                      span,
                  }),
              }
          }
      }
      
      /// #env("VAR") - Read environment variable at compile time
      pub struct Env;
      
      impl Macro for Env {
          fn name(&self) -> &str { "env" }
          
          fn expand(&self, input: MacroInput, span: Span) -> Result<MacroOutput, MacroError> {
              match input {
                  MacroInput::Expression { args } => {
                      if args.len() != 1 {
                          return Err(MacroError {
                              message: "env expects exactly 1 argument".into(),
                              span,
                          });
                      }
                      if let Expr::Literal { value: Literal::String(var_name), .. } = &args[0] {
                          let value = std::env::var(var_name).unwrap_or_default();
                          Ok(MacroOutput::Expression(Expr::Literal {
                              value: Literal::String(value),
                              span,
                          }))
                      } else {
                          Err(MacroError {
                              message: "env expects a string literal".into(),
                              span,
                          })
                      }
                  }
                  _ => Err(MacroError {
                      message: "env is an expression macro".into(),
                      span,
                  }),
              }
          }
      }
      
      /// #cfg(condition) - Conditional compilation
      pub struct Cfg;
      
      impl Macro for Cfg {
          fn name(&self) -> &str { "cfg" }
          
          fn expand(&self, input: MacroInput, span: Span) -> Result<MacroOutput, MacroError> {
              match input {
                  MacroInput::Attribute { args, item } => {
                      // Evaluate cfg condition
                      let condition_met = evaluate_cfg_condition(&args);
                      if condition_met {
                          Ok(MacroOutput::Declaration(item))
                      } else {
                          Ok(MacroOutput::None)
                      }
                  }
                  _ => Err(MacroError {
                      message: "cfg is an attribute macro".into(),
                      span,
                  }),
              }
          }
      }
      
      fn evaluate_cfg_condition(args: &[Expr]) -> bool {
          // TODO: Implement proper cfg evaluation
          // For now, check common conditions
          if args.is_empty() {
              return false;
          }
          
          // Check for target.wasm, target.native, etc.
          if let Expr::Member { object, field, .. } = &args[0] {
              if let Expr::Identifier { name, .. } = object.as_ref() {
                  if name == "target" {
                      // Check against current compilation target
                      return match field.as_str() {
                          "wasm" => cfg!(target_arch = "wasm32"),
                          "native" => !cfg!(target_arch = "wasm32"),
                          "linux" => cfg!(target_os = "linux"),
                          "macos" => cfg!(target_os = "macos"),
                          "windows" => cfg!(target_os = "windows"),
                          _ => false,
                      };
                  }
              }
          }
          
          true // Default to true for unknown conditions
      }
      
      /// #derive(Trait1, Trait2, ...) - Generate trait implementations
      pub struct Derive;
      
      impl Macro for Derive {
          fn name(&self) -> &str { "derive" }
          
          fn expand(&self, input: MacroInput, span: Span) -> Result<MacroOutput, MacroError> {
              match input {
                  MacroInput::Attribute { args, item } => {
                      // For now, just pass through the item
                      // In full implementation, would generate trait impls
                      let mut declarations = vec![item.clone()];
                      
                      // TODO: Generate trait implementations based on args
                      // e.g., #derive(Debug) would generate a debug() method
                      
                      Ok(MacroOutput::Declarations(declarations))
                  }
                  _ => Err(MacroError {
                      message: "derive is an attribute macro".into(),
                      span,
                  }),
              }
          }
      }
      
      /// #todo(message) - Compile-time TODO marker
      pub struct Todo;
      
      impl Macro for Todo {
          fn name(&self) -> &str { "todo" }
          
          fn expand(&self, input: MacroInput, span: Span) -> Result<MacroOutput, MacroError> {
              match input {
                  MacroInput::Expression { args } => {
                      let message = if let Some(Expr::Literal { value: Literal::String(s), .. }) = args.first() {
                          s.clone()
                      } else {
                          "not yet implemented".to_string()
                      };
                      
                      // Return a panic expression
                      Ok(MacroOutput::Expression(Expr::Call {
                          callee: Box::new(Expr::Identifier {
                              name: "panic".to_string(),
                              span,
                          }),
                          args: vec![Expr::Literal {
                              value: Literal::String(format!("TODO: {}", message)),
                              span,
                          }],
                          span,
                      }))
                  }
                  _ => Err(MacroError {
                      message: "todo is an expression macro".into(),
                      span,
                  }),
              }
          }
      }
      
      /// #unreachable(message) - Mark unreachable code
      pub struct Unreachable;
      
      impl Macro for Unreachable {
          fn name(&self) -> &str { "unreachable" }
          
          fn expand(&self, input: MacroInput, span: Span) -> Result<MacroOutput, MacroError> {
              match input {
                  MacroInput::Expression { args } => {
                      let message = if let Some(Expr::Literal { value: Literal::String(s), .. }) = args.first() {
                          s.clone()
                      } else {
                          "entered unreachable code".to_string()
                      };
                      
                      Ok(MacroOutput::Expression(Expr::Call {
                          callee: Box::new(Expr::Identifier {
                              name: "panic".to_string(),
                              span,
                          }),
                          args: vec![Expr::Literal {
                              value: Literal::String(message),
                              span,
                          }],
                          span,
                      }))
                  }
                  _ => Err(MacroError {
                      message: "unreachable is an expression macro".into(),
                      span,
                  }),
              }
          }
      }
      ```
      
      FILE: ~/repos/metadol/src/macros/builtin.rs

  macro-registry:
    name: Macro Registry
    role: Create macro registry and expansion
    dependencies:
      - macro-builtins
    instructions: |
      Create the macro registry and expansion infrastructure.
      
      CREATE src/macros/registry.rs:
      
      ```rust
      //! Macro registry - stores and looks up macros
      
      use super::{Macro, MacroError};
      use super::builtin::*;
      use std::collections::HashMap;
      use std::sync::Arc;
      
      /// Registry of all available macros
      pub struct MacroRegistry {
          macros: HashMap<String, Arc<dyn Macro>>,
      }
      
      impl MacroRegistry {
          /// Create a new registry with built-in macros
          pub fn new() -> Self {
              let mut registry = Self {
                  macros: HashMap::new(),
              };
              
              // Register built-in macros
              registry.register(Arc::new(Stringify));
              registry.register(Arc::new(Concat));
              registry.register(Arc::new(Env));
              registry.register(Arc::new(Cfg));
              registry.register(Arc::new(Derive));
              registry.register(Arc::new(Todo));
              registry.register(Arc::new(Unreachable));
              
              registry
          }
          
          /// Register a macro
          pub fn register(&mut self, m: Arc<dyn Macro>) {
              self.macros.insert(m.name().to_string(), m);
          }
          
          /// Look up a macro by name
          pub fn get(&self, name: &str) -> Option<Arc<dyn Macro>> {
              self.macros.get(name).cloned()
          }
          
          /// Check if a macro exists
          pub fn contains(&self, name: &str) -> bool {
              self.macros.contains_key(name)
          }
          
          /// List all registered macros
          pub fn list(&self) -> Vec<&str> {
              self.macros.keys().map(|s| s.as_str()).collect()
          }
      }
      
      impl Default for MacroRegistry {
          fn default() -> Self {
              Self::new()
          }
      }
      ```
      
      CREATE src/macros/expand.rs:
      
      ```rust
      //! Macro expansion pass
      
      use super::{MacroRegistry, MacroInput, MacroOutput, MacroError};
      use crate::ast::{Declaration, Expr, Stmt, Module, Span};
      
      /// Macro expander - transforms AST by expanding macros
      pub struct MacroExpander {
          registry: MacroRegistry,
          errors: Vec<MacroError>,
      }
      
      impl MacroExpander {
          pub fn new() -> Self {
              Self {
                  registry: MacroRegistry::new(),
                  errors: Vec::new(),
              }
          }
          
          pub fn with_registry(registry: MacroRegistry) -> Self {
              Self {
                  registry,
                  errors: Vec::new(),
              }
          }
          
          /// Expand all macros in a module
          pub fn expand_module(&mut self, module: Module) -> Result<Module, Vec<MacroError>> {
              let mut declarations = Vec::new();
              
              for decl in module.declarations {
                  match self.expand_declaration(decl) {
                      Ok(expanded) => declarations.extend(expanded),
                      Err(e) => self.errors.push(e),
                  }
              }
              
              if self.errors.is_empty() {
                  Ok(Module {
                      declarations,
                      ..module
                  })
              } else {
                  Err(std::mem::take(&mut self.errors))
              }
          }
          
          /// Expand macros in a declaration
          fn expand_declaration(&mut self, decl: Declaration) -> Result<Vec<Declaration>, MacroError> {
              // Check for attribute macros on this declaration
              if let Some((macro_name, args, span)) = self.extract_attribute_macro(&decl) {
                  if let Some(m) = self.registry.get(&macro_name) {
                      let input = MacroInput::Attribute {
                          args,
                          item: decl,
                      };
                      match m.expand(input, span)? {
                          MacroOutput::Declaration(d) => return Ok(vec![d]),
                          MacroOutput::Declarations(ds) => return Ok(ds),
                          MacroOutput::None => return Ok(vec![]),
                          MacroOutput::Expression(_) => {
                              return Err(MacroError {
                                  message: "Attribute macro cannot return expression".into(),
                                  span,
                              });
                          }
                      }
                  }
              }
              
              // Recursively expand macros in declaration body
              Ok(vec![self.expand_decl_body(decl)?])
          }
          
          /// Expand macros in expressions
          pub fn expand_expr(&mut self, expr: Expr) -> Result<Expr, MacroError> {
              match expr {
                  Expr::Macro { name, args, span } => {
                      if let Some(m) = self.registry.get(&name) {
                          let input = MacroInput::Expression { args };
                          match m.expand(input, span)? {
                              MacroOutput::Expression(e) => Ok(e),
                              _ => Err(MacroError {
                                  message: "Expression macro must return expression".into(),
                                  span,
                              }),
                          }
                      } else {
                          Err(MacroError {
                              message: format!("Unknown macro: {}", name),
                              span,
                          })
                      }
                  }
                  // Recursively expand in sub-expressions
                  Expr::Binary { op, left, right, span } => Ok(Expr::Binary {
                      op,
                      left: Box::new(self.expand_expr(*left)?),
                      right: Box::new(self.expand_expr(*right)?),
                      span,
                  }),
                  Expr::Unary { op, operand, span } => Ok(Expr::Unary {
                      op,
                      operand: Box::new(self.expand_expr(*operand)?),
                      span,
                  }),
                  Expr::Call { callee, args, span } => Ok(Expr::Call {
                      callee: Box::new(self.expand_expr(*callee)?),
                      args: args.into_iter()
                          .map(|a| self.expand_expr(a))
                          .collect::<Result<Vec<_>, _>>()?,
                      span,
                  }),
                  Expr::If { condition, then_branch, else_branch, span } => Ok(Expr::If {
                      condition: Box::new(self.expand_expr(*condition)?),
                      then_branch: Box::new(self.expand_expr(*then_branch)?),
                      else_branch: else_branch.map(|e| self.expand_expr(*e)).transpose()?.map(Box::new),
                      span,
                  }),
                  Expr::Block { statements, expr, span } => Ok(Expr::Block {
                      statements: statements.into_iter()
                          .map(|s| self.expand_stmt(s))
                          .collect::<Result<Vec<_>, _>>()?,
                      expr: expr.map(|e| self.expand_expr(*e)).transpose()?.map(Box::new),
                      span,
                  }),
                  // Pass through other expressions unchanged
                  other => Ok(other),
              }
          }
          
          fn expand_stmt(&mut self, stmt: Stmt) -> Result<Stmt, MacroError> {
              match stmt {
                  Stmt::Expr(e) => Ok(Stmt::Expr(self.expand_expr(e)?)),
                  Stmt::Let { name, type_ann, value, span } => Ok(Stmt::Let {
                      name,
                      type_ann,
                      value: self.expand_expr(value)?,
                      span,
                  }),
                  Stmt::Return(Some(e), span) => Ok(Stmt::Return(Some(self.expand_expr(e)?), span)),
                  other => Ok(other),
              }
          }
          
          fn extract_attribute_macro(&self, _decl: &Declaration) -> Option<(String, Vec<Expr>, Span)> {
              // TODO: Extract #[macro_name(args)] from declaration attributes
              None
          }
          
          fn expand_decl_body(&mut self, decl: Declaration) -> Result<Declaration, MacroError> {
              // TODO: Expand macros in declaration body (functions, etc.)
              Ok(decl)
          }
      }
      
      impl Default for MacroExpander {
          fn default() -> Self {
              Self::new()
          }
      }
      ```
      
      FILES:
      - ~/repos/metadol/src/macros/registry.rs
      - ~/repos/metadol/src/macros/expand.rs

  macro-tests:
    name: Macro Tests
    role: Write tests for the macro system
    dependencies:
      - macro-registry
    instructions: |
      Write comprehensive tests for the macro system.
      
      CREATE tests/macro_tests.rs:
      
      ```rust
      use metadol::macros::{MacroRegistry, MacroExpander, MacroInput, MacroOutput};
      use metadol::ast::{Expr, Literal, Span};
      
      fn test_span() -> Span {
          Span { start: 0, end: 0 }
      }
      
      #[test]
      fn test_registry_has_builtins() {
          let registry = MacroRegistry::new();
          
          assert!(registry.contains("stringify"));
          assert!(registry.contains("concat"));
          assert!(registry.contains("env"));
          assert!(registry.contains("cfg"));
          assert!(registry.contains("derive"));
          assert!(registry.contains("todo"));
          assert!(registry.contains("unreachable"));
      }
      
      #[test]
      fn test_stringify_macro() {
          let registry = MacroRegistry::new();
          let m = registry.get("stringify").unwrap();
          
          let input = MacroInput::Expression {
              args: vec![Expr::Binary {
                  op: metadol::ast::BinaryOp::Add,
                  left: Box::new(Expr::Literal {
                      value: Literal::Int(1),
                      span: test_span(),
                  }),
                  right: Box::new(Expr::Literal {
                      value: Literal::Int(2),
                      span: test_span(),
                  }),
                  span: test_span(),
              }],
          };
          
          let output = m.expand(input, test_span()).unwrap();
          
          match output {
              MacroOutput::Expression(Expr::Literal { value: Literal::String(s), .. }) => {
                  assert!(s.contains("Add") || s.contains("+") || s.contains("1") && s.contains("2"));
              }
              _ => panic!("Expected string literal"),
          }
      }
      
      #[test]
      fn test_concat_macro() {
          let registry = MacroRegistry::new();
          let m = registry.get("concat").unwrap();
          
          let input = MacroInput::Expression {
              args: vec![
                  Expr::Literal {
                      value: Literal::String("Hello, ".to_string()),
                      span: test_span(),
                  },
                  Expr::Literal {
                      value: Literal::String("World!".to_string()),
                      span: test_span(),
                  },
              ],
          };
          
          let output = m.expand(input, test_span()).unwrap();
          
          match output {
              MacroOutput::Expression(Expr::Literal { value: Literal::String(s), .. }) => {
                  assert_eq!(s, "Hello, World!");
              }
              _ => panic!("Expected string literal"),
          }
      }
      
      #[test]
      fn test_todo_macro() {
          let registry = MacroRegistry::new();
          let m = registry.get("todo").unwrap();
          
          let input = MacroInput::Expression {
              args: vec![Expr::Literal {
                  value: Literal::String("implement later".to_string()),
                  span: test_span(),
              }],
          };
          
          let output = m.expand(input, test_span()).unwrap();
          
          match output {
              MacroOutput::Expression(Expr::Call { callee, args, .. }) => {
                  if let Expr::Identifier { name, .. } = *callee {
                      assert_eq!(name, "panic");
                  }
                  assert!(!args.is_empty());
              }
              _ => panic!("Expected call expression"),
          }
      }
      
      #[test]
      fn test_macro_expander() {
          let mut expander = MacroExpander::new();
          
          // Test expanding a macro expression
          let expr = Expr::Macro {
              name: "concat".to_string(),
              args: vec![
                  Expr::Literal {
                      value: Literal::String("a".to_string()),
                      span: test_span(),
                  },
                  Expr::Literal {
                      value: Literal::String("b".to_string()),
                      span: test_span(),
                  },
              ],
              span: test_span(),
          };
          
          let expanded = expander.expand_expr(expr).unwrap();
          
          match expanded {
              Expr::Literal { value: Literal::String(s), .. } => {
                  assert_eq!(s, "ab");
              }
              _ => panic!("Expected expanded string"),
          }
      }
      
      #[test]
      fn test_unknown_macro_error() {
          let mut expander = MacroExpander::new();
          
          let expr = Expr::Macro {
              name: "nonexistent".to_string(),
              args: vec![],
              span: test_span(),
          };
          
          let result = expander.expand_expr(expr);
          assert!(result.is_err());
      }
      ```
      
      FILE: ~/repos/metadol/tests/macro_tests.rs
      
      Update src/lib.rs to export the macros module:
      
      ```rust
      pub mod macros;
      ```

  # ───────────────────────────────────────────────────────
  # Task 4.4: Reflect Operator
  # ─────────────────────────────────────────────────────────────────
  reflect-module:
    name: Reflect Module
    role: Create reflection system
    dependencies:
      - macro-tests
    instructio      Create the reflection system for runtime type introspection.
      
      CREATE src/reflect.rs:
      
      ```rust
      //! DOL Reflection System
      //!
      //! The reflect operator (?) provides runtime type introspection.
      //!
      //! # Examples
      //! ```dol
      //! info = ?Container
      //! // info.name == "Container"
      //! // info.fields == [...]
      //! ```
      
      use std::collections::HashMap;
      
      /// Runtime type information
      #[derive(Debug, Clone, PartialEq)]
      pub struct TypeInfo {
          /// Name of the type
          pub name: String,
          /// Kind of type (Gene, Trait, System, etc.)
          pub kind: TypeKind,
          /// Fields (for genes/structs)
          pub fields: Vec<FieldInfo>,
          /// Methods (for traits)
          pub methods: Vec<MethodInfo>,
          /// Constraints
          pub constraints: Vec<ConstraintInfo>,
          /// Exegesis documentation
          pub exegesis: Option<String>,
          /// Generic parameters
          pub type_params: Vec<String>,
      }
      
      /// Kind of type
      #[derive(Debug, Clone, Copy, PartialEq, Eq)]
      pub enum TypeKind {
          Gene,
          Trait,
          System,
          Primitive,
          Compound,
          Function,
      }
      
      /// Information about a field
      #[derive(Debug, Clone, PartialEq)]
      pub struct FieldInfo {
          pub name: String,
          pub type_name: String,
          pub is_required: bool,
          pub default_value: Option<String>,
      }
      
      /// Information about a method
      #[derive(Debug, Clone, PartialEq)]
      pub struct MethodInfo {
          pub name: String,
          pub params: Vec<ParamInfo>,
          pub return_type: String,
          pub is_sex: bool,  // Has side effects
      }
      
      /// Information about a parameter
      #[derive(Debug, Clone, PartialEq)]
      pub struct ParamInfo {
          pub name: String,
          pub type_name: String,
      }
      
      /// Information about a constraint
      #[derive(Debug, Clone, PartialEq)]
      pub struct ConstraintInfo {
          pub name: String,
          pub expression: String,
      }
      
      /// Registry of type information for reflection
      #[derive(Debug, Default)]
      pub struct TypeRegistry {
          types: HashMap<String, TypeInfo>,
      }
      
      impl TypeRegistry {
          pub fn new() -> Self {
              Self::default()
          }
          
          /// Register a type
          pub fn register(&mut self, info: TypeInfo) {
              self.types.insert(info.name.clone(), info);
          }
          
          /// Look up type info by name
          pub fn get(&self, name: &str) -> Option<&TypeInfo> {
              self.types.get(name)
          }
          
          /// Check if type is registered
          pub fn contains(&self, name: &str) -> bool {
              self.types.contains_key(name)
          }
          
          /// List all registered types
          pub fn list(&self) -> Vec<&str> {
              self.types.keys().map(|s| s.as_str()).collect()
          }
      }
      
      impl TypeInfo {
          /// Create TypeInfo for a primitive type
          pub fn primitive(name: &str) -> Self {
              Self {
                  name: name.to_string(),
                  kind: TypeKind::Primitive,
                  fields: vec![],
                  methods: vec![],
                  constraints: vec![],
                  exegesis: None,
                  type_params: vec![],
              }
          }
          
          /// Builder pattern for creating TypeInfo
          pub fn gene(name: &str) -> TypeInfoBuilder {
              TypeInfoBuilder::new(name, TypeKind::Gene)
          }
          
          pub fn trait_type(name: &str) -> TypeInfoBuilder {
              TypeInfoBuilder::new(name, TypeKind::Trait)
          }
      }
      
      /// Builder for TypeInfo
      pub struct TypeInfoBuilder {
          info: TypeInfo,
      }
      
      impl TypeInfoBuilder {
          pub fn new(name: &str, kind: TypeKind) -> Self {
              Self {
                  info: TypeInfo {
                      name: name.to_string(),
                      kind,
                      fields: vec![],
                      methods: vec![],
                      constraints: vec![],
                      exegesis: None,
                      type_params: vec![],
                  },
              }
          }
          
          pub fn field(mut self, name: &str, type_name: &str) -> Self {
              self.info.fields.push(FieldInfo {
                  name: name.to_string(),
                  type_name: type_name.to_string(),
                  is_required: true,
                  default_value: None,
              });
              self
          }
          
          pub fn method(mut self, name: &str, return_type: &str) -> Self {
              self.info.methods.push(MethodInfo {
                  name: name.to_string(),
                  params: vec![],
                  return_type: return_type.to_string(),
                  is_sex: false,
              });
              self
          }
          
          pub fn constraint(mut self, name: &str, expr: &str) -> Self {
              self.info.constraints.push(ConstraintInfo {
                  name: name.to_string(),
                  expression: expr.to_string(),
              });
              self
          }
          
          pub fn exegesis(mut self, doc: &str) -> Self {
              self.info.exegesis = Some(doc.to_string());
              self
          }
          
          pub fn type_param(mut self, name: &str) -> Self {
              self.info.type_params.push(name.to_string());
              self
          }
          
          pub fn build(self) -> TypeInfo {
              self.info
          }
      }
      ```
      
      FILE: ~/repos/metadol/src/reflect.rs

  reflect-typechecker:
    name: Reflect TypeChecker
    role: Add reflect operator to type checker
    dependencies:
      - reflect-module
    instructions: |
      Update the type checker to handle the reflect operator (?).
      
      UPDATE src/typechecker.rs:
      
      Add handling for Expr::Reflect in check_expr:
      
      ```rust
      Expr::Unary { op: UnaryOp::Reflect, operand, span } => {
          // The operand should be a type identifier
          // Return TypeInfo type
          match operand.as_ref() {
              Expr::Identifier { name, .. } => {
                  // Check if it's a known type
                  if self.type_registry.contains(name) || self.is_type_name(name) {
                      Ok(Type::Generic {
                          name: "TypeInfo".to_string(),
                          params: vec![],
                      })
                  } else {
                      Err(TypeError::UndefinedType {
                          name: name.clone(),
                          span: *span,
                      })
                  }
              }
              _ => {
                  Err(TypeError::InvalidReflect {
                      message: "Reflect operator requires a type name".to_string(),
                      span: *span,
                  })
              }
          }
      }
      ```
      
      Add new error variant if needed:
      
      ```rust
      pub enum TypeError {
          // ... existing variants ...
          InvalidReflect { message: String, span: Span },
          UndefinedType { name: String, span: Span },
      }
      ```
      
      FILE: ~/repos/metadol/src/typechecker.rs

  reflect-tests:
    name: Reflect Tests
    role: Write tests for reflection
    dependencies:
      - reflect-typechecker
    instructions: |
      Write tests for the reflection system.
      
      CREATE tests/reflect_tests.rs:
      
      ```rust
      use metadol::reflect::*;
      
      #[test]
      fn test_type_info_primitive() {
          let info = TypeInfo::primitive("Int64");
          
          assert_eq!(info.name, "Int64");
          assert_eq!(info.kind, TypeKind::Primitive);
          assert!(info.fields.is_empty());
      }
      
      #[test]
      fn test_type_info_builder() {
          let info = TypeInfo::gene("Container")
              .field("id", "UInt64")
              .field("name", "String")
              .constraint("valid_id", "this.id > 0")
              .exegesis("A container is an isolated execution environment.")
              .build();
          
          assert_eq!(info.name, "Container");
          assert_eq!(info.kind, TypeKind::Gene);
          assert_eq!(info.fields.len(), 2);
          assert_eq!(info.fields[0].name, "id");
          assert_eq!(info.fields[0].type_name, "UInt64");
          assert_eq!(info.constraints.len(), 1);
          assert!(info.exegesis.is_some());
      }
      
      #[test]
      fn test_type_registry() {
          let mut registry = TypeRegistry::new();
          
          let container = TypeInfo::gene("Container")
              .field("id", "UInt64")
              .build();
          
          registry.register(container);
          
          assert!(registry.contains("Container"));
          assert!(!registry.contains("Unknown"));
          
          let info = registry.get("Container").unwrap();
          assert_eq!(info.fields.len(), 1);
      }
      
      #[test]
      fn test_trait_type_info() {
          let info = TypeInfo::trait_type("Runnable")
              .method("start", "Bool")
              .method("stop", "Bool")
              .type_param("T")
              .build();
          
          assert_eq!(info.name, "Runnable");
          assert_eq!(info.kind, TypeKind::Trait);
          assert_eq!(info.methods.len(), 2);
          assert_eq!(info.type_params.len(), 1);
      }
      ```
      
      FILE: ~/repos/metadol/tests/reflect_tests.rs

  # ─────────────────────────────────────────────────────────────────
  # Task 4.5: Idiom Brackets
  # ─────────────────â──────────────────────────────────────────
  idiom-parser:
    name: Idiom Parser
    role: Parse idiom brackets [| |]
    dependencies:
      - reflect-tests
    instructions: |
      Update the parser to handle idiom brackets [| ... |].
      
      Idiom brackets are syntactic sugar for applicative functor operations.
      
      ```dol
      // [| f x y |] desugars to: f <$> x <*> y
      // [| f x y z |] desugars to> x <*> y <*> z
      ```
      
      UPDATE src/ast.rs - add IdiomBracket variant:
      
      ```rust
      pub enum Expr {
          // ... existing variants ...
          
          /// Idiom brackets [| f x y |]
          /// Desugars to applicative style: f <$> x <*> y
          IdiomBracket {
              /// The function to apply
              func: Box<Expr>,
              /// Arguments to lift and apply
              args: Vec<Expr>,
              span: Span,
          },
      }
      ```
      
      UPDATE src/pratt.rs - parse [| ... |]:
      
      ```rust
      // In parse_primary or parse_prefix
      Token::IdiomOpen => {
          let start = self.current_span();
          self.advance(); // consume [|
          
          // Parse function
          let func = self.parse_expr_bp(0)?;
          
          // Parse arguments until |]
          let mut args = vec![];
          while !self.check(Token::IdiomClose) && !self.is_at_end() {
              args.push(self.parse_expr_bp(0)?);
          }
          
          let end = self.current_span();
          self.expect(Token::IdiomClose)?;
          
          Ok(Expr::IdiomBracket {
              func: Box::new(func),
              args,
              span: start.merge(&end),
          })
      }
      ```
      
      FILES:
      - ~/repos/metadol/src/ast.rs
      - ~/repos/metadol/src/pratt.rs

  idiom-desugar:
    name: Idiom Desugaring
    role: Desugar idiom brackets to applicative operations
    dependencies:
      - idiom-parser
    instructions: |
      Create a desugaring pass for idiom brackets.
      
      CREATE src/transform/desugar_idiom.rs:
      
      ```rust
      //! Desugar idiom brackets to applicative operations
      //!
      //! [| f x y |] becomes f <$> x <*> y
      
      use crate::ast::{Expr, BinaryOp, Span};
      use crate::transform::{Pass, MutVisitor};
      
      /// Desugaring pass for idiom brackets
      pub struct DesugarIdiom;
      
      impl Pass for DesugarIdiom {
          fn name(&self) -> &str {
              "desugar_idiom"
          }
          
          fn run(&self, module: &mut crate::ast::Module) {
              let mut visitor = IdiomDesugarer;
              visitor.visit_module(module);
          }
      }
      
      struct IdiomDesugarer;
      
      impl MutVisitor for IdiomDesugarer {
          fn visit_expr(&mut self, expr: &mut Expr) {
              // First, recursively visit children
              match expr {
                  Expr::Binary { left, right, .. } => {
                      self.visit_expr(left);
                      self.visit_expr(right);
                  }
                  Expr::Unary { operand, .. } => {
                      self.visit_expr(operand);
                  }
                  Expr::Call { callee, args, .. } => {
                      self.visit_expr(callee);
                      for arg in args {
                          self.visit_expr(arg);
                      }
                  }
                  Expr::IdiomBracket { func, args, span } => {
                      // Desugar: [| f x y z |] -> ((f <$> x) <*> y) <*> z
                      self.visit_expr(func);
                      for arg in args.iter_mut() {
                          self.visit_expr(arg);
                      }
                      
                      if args.is_empty() {
                          // [| f |] -> pure f
                          *expr = Expr::Call {
                              callee: Box::new(Expr::Identifier {
                                  name: "pure".to_string(),
                                  span: *span,
                              }),
                              args: vec![*func.clone()],
                              span: *span,
                          };
                      } else {
                          // Start with f <$> first_arg
                          let mut result = Expr::Binary {
                              op: BinaryOp::Map,  // <$>
                              left: func.clone(),
                              right: Box::new(args[0].clone()),
                              span: *span,
                          };
                          
                          // Apply remaining args with <*>
                          for arg in &args[1..] {
                              result = Expr::Binary {
                                  op: BinaryOp::Ap,  // <*>
                                  left: Box::new(result),
                                  right: Box::new(arg.clone()),
                                  span: *span,
                              };
                          }
                          
                          *expr = result;
                      }
                  }
                  _ => {}
              }
          }
      }
      ```
      
      Note: You may need to add Map (<$>) and Ap (<*>) to BinaryOp enum if not present.
      
      FILE: ~/repos/metadol/src/transform/desugar_idiom.rs

  idiom-tests:
    name: Idiom Tests
    role: Write tests for idiom brackets
    dependencies:
      - idiom-desugar
    instructions: |
      Write tests for idiom bracket parsing and desugaring.
      
      CREATE tests/idiom_tests.rs:
      
      ```rust
      use metadol::parse;
      use metadol::ast::{Expr, BinaryOp};
      
      #[test]
      fn test_parse_idiom_empty() {
          let source = "[| f |]";
          let result = parse(source);
          assert!(result.is_ok());
      }
      
      #[test]
      fn test_parse_idiom_one_arg() {
          let source = "[| f x |]";
          let result = parse(source);
          assert!(result.is_ok());
          
          // Should parse as IdiomBracket with func=f and args=[x]
      }
      
      #[test]
      fn test_parse_idiom_two_args() {
          let source = "[| f x y |]";
          let result = parse(source);
          assert!(result.is_ok());
      }
      
      #[test]
      fn test_parse_idiom_three_args() {
          let source = "[| add x y z |]";
          let result = parse(source);
          assert!(result.is_ok());
      }
      
      #[test]
      fn test_parse_idiom_nested() {
          let source = "[| f [| g x |] y |]";
          let result = parse(source);
          assert!(result.is_ok());
      }
      
      #[test]
      fn test_parse_idiom_with_expressions() {
          let source = "[| add (x + 1) (y * 2) |]";
          let result = parse(source);
          assert!(result.is_ok());
      }
      
      // Desugaring tests would require running the transform pass
      #[test]
      fn test_idiom_desugar_concept() {
          // [| f x y |] should become: (f <$> x) <*> y
          // This is a conceptual test - actual desugaring tested in transform tests
      }
      ```
      
      FILE: ~/repos/metadol/tests/idiom_tests.rs

  # ─────────────────────────────────────────────────────────────────
  # Final Validation
  # ─────────────────────â─────────────────────────────
  validator:
    name: Q2 Final Validator
    role: Validate all Q2 features work together
    dependencies:
      - idiom-tests
    instructions: |
      Validate all Q2 meta-programming features.
      
      ```bash
      cd ~/repos/metadol
      
      # Update lib.rs to export new modules
      # Add to src/lib.rs:
      # pub mod macros;
      # pub mod reflect;
      
      # Format
      cargo fmt --all
      t
      cargo clippy -- -D warnings
      
      # Run all tests
      cargo test
      
      # Count tests
      cargo test 2>&1 | grep -E "^test result"
      ```
      
      Expected: All tests passing including new:
      - Quote/Eval tests (33)
      - Macro tests (~10)
      - Reflect tests (~5)
      - Idiom tests (~7)
      
      When all pass, commit:
      
      ```bash
      git add -A
      git commit -m "feat(meta): complete Q2 meta-programming
      
      - Macros (#): stringify, concat, env, cfg, derive, todo, unreachable
      - Reflect (?): TypeInfo, TypeRegistry, runtime introspection
      - Idiom brackets ([| |]): applicative functor syntax
      - Macro expansion pass
      - Idiom desugaring pass
      
      Q2 Meta-Programming complete!"
      
      git push
      ```

# ═══════════════════════════════════════════════════════════════════
# WORKFLOW═════════════════════════════════════════════════════════════════

workflows:
  q2-complete:
    name: Complete Q2 Meta-Programming
    description: Implement Macro, Reflect, Idiom Brackets
    stages:
      - name: task-4.3-macro
        description: Macro system
        agents:
          - macro-module
          - macro-builtins
          - macro-registry
          - macro-test          
      - name: task-4.4-reflect
        description: Reflect operator
        agents:
          - reflect-module
          - reflect-typechecker
          - reflect-tests
        depends_on:
          - task-4.3-macro
          
      - name: task-4.5-idiom
        description: Idiom brackets
        agents:
          - idiom-parser
          - idiom-desugar
          - idiom-tests
        depends_on:
          - task-4.4-reflect
          
      - name: validate
        description: Final validation
        agents:
          - validator
        depends_on:
          - task-4.5-idiom

  # Focused workflows for individual tasks
  macro-only:
    name: Macro System Only
    stages:
      - name: macro
        agents: [macro-module, macro-builtins, macro-registry, macro-tests]

  reflect-only:
    name: Reflect Only
    stages:
      - name: reflect
        agents: [reflect-module, reflect-typechecker, reflect-tests]

  idiom-only:
    name: Idiom Brackets Only
    stages:
      - name: idiom
        agents: [idiom-parser, idiom-desugar, idiom-tests]
