trait functor.applicative {
  uses functor.base

  applicative has pure
  applicative has apply

  pure is value_lifting
  pure has input_value
  pure has output_wrapped

  apply is function_application
  apply has wrapped_function
  apply has wrapped_value
  apply has wrapped_result

  applicative is functor
  applicative is composable
}

exegesis {
  Applicative extends Functor with the ability to apply wrapped functions
  to wrapped values. This enables function application within a context.

  Core operations:

  PURE lifts a plain value into the applicative context.
    pure(x) wraps x in the minimal context
    For Optional: pure(5) becomes Some(5)
    For List: pure(5) becomes [5]

  APPLY takes a wrapped function and wrapped value, returns wrapped result.
    apply(Some(f), Some(x)) becomes Some(f(x))
    apply(None, Some(x)) becomes None
    apply(Some(f), None) becomes None

  Laws that must hold:
  1. Identity: apply(pure(id), v) equals v
  2. Composition: apply(apply(apply(pure(compose), u), v), w) equals apply(u, apply(v, w))
  3. Homomorphism: apply(pure(f), pure(x)) equals pure(f(x))
  4. Interchange: apply(u, pure(y)) equals apply(pure(fn applies y), u)

  See traits.applicative-spec.md for full specification with generics.
}
